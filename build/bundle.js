/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 39);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* Riot v2.6.7, @license MIT */\n\n;(function(window, undefined) {\n  'use strict';\nvar riot = { version: 'v2.6.7', settings: {} },\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n\n  // counter to give a unique id to all the Tag instances\n  __uid = 0,\n  // tags instances cache\n  __virtualDom = [],\n  // tags implementation cache\n  __tagImpl = {},\n\n  /**\n   * Const\n   */\n  GLOBAL_MIXIN = '__global_mixin',\n\n  // riot specific prefixes\n  RIOT_PREFIX = 'riot-',\n  RIOT_TAG = RIOT_PREFIX + 'tag',\n  RIOT_TAG_IS = 'data-is',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n  XLINK_NS = 'http://www.w3.org/1999/xlink',\n  XLINK_REGEX = /^xlink:(\\w+)/,\n  // special native tags that cannot be treated like the others\n  SPECIAL_TAGS_REGEX = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n  RESERVED_WORDS_BLACKLIST = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|parent|opts|trigger|o(?:n|ff|ne))$/,\n  // SVG tags list https://www.w3.org/TR/SVG/attindex.html#PresentationAttributes\n  SVG_TAGS_LIST = ['altGlyph', 'animate', 'animateColor', 'circle', 'clipPath', 'defs', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feFlood', 'feGaussianBlur', 'feImage', 'feMerge', 'feMorphology', 'feOffset', 'feSpecularLighting', 'feTile', 'feTurbulence', 'filter', 'font', 'foreignObject', 'g', 'glyph', 'glyphRef', 'image', 'line', 'linearGradient', 'marker', 'mask', 'missing-glyph', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'switch', 'symbol', 'text', 'textPath', 'tref', 'tspan', 'use'],\n\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (window && window.document || {}).documentMode | 0,\n\n  // detect firefox to fix #1374\n  FIREFOX = window && !!window.InstallTrigger\n/* istanbul ignore next */\nriot.observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice\n\n  /**\n   * Private Methods\n   */\n\n  /**\n   * Helper function needed to get and loop all the events in a string\n   * @param   { String }   e - event string\n   * @param   {Function}   fn - callback\n   */\n  function onEachEvent(e, fn) {\n    var es = e.split(' '), l = es.length, i = 0\n    for (; i < l; i++) {\n      var name = es[i]\n      if (name) fn(name, i)\n    }\n  }\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given space separated list of `events` and\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } events - events ids\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(events, fn) {\n        if (typeof fn != 'function')  return el\n\n        onEachEvent(events, function(name, pos) {\n          (callbacks[name] = callbacks[name] || []).push(fn)\n          fn.typed = pos > 0\n        })\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given space separated list of `events` listeners\n     * @param   { String } events - events ids\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(events, fn) {\n        if (events == '*' && !fn) callbacks = {}\n        else {\n          onEachEvent(events, function(name, pos) {\n            if (fn) {\n              var arr = callbacks[name]\n              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n                if (cb == fn) arr.splice(i--, 1)\n              }\n            } else delete callbacks[name]\n          })\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given space separated list of `events` and\n     * execute the `callback` at most once\n     * @param   { String } events - events ids\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(events, fn) {\n        function on() {\n          el.off(events, on)\n          fn.apply(el, arguments)\n        }\n        return el.on(events, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given space separated list of `events`\n     * @param   { String } events - events ids\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(events) {\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns\n\n        for (var i = 0; i < arglen; i++) {\n          args[i] = arguments[i + 1] // skip first argument\n        }\n\n        onEachEvent(events, function(name, pos) {\n\n          fns = slice.call(callbacks[name] || [], 0)\n\n          for (var i = 0, fn; fn = fns[i]; ++i) {\n            if (fn.busy) continue\n            fn.busy = 1\n            fn.apply(el, fn.typed ? [name].concat(args) : args)\n            if (fns[i] !== fn) { i-- }\n            fn.busy = 0\n          }\n\n          if (callbacks['*'] && name != '*')\n            el.trigger.apply(el, ['*', name].concat(args))\n\n        })\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  })\n\n  return el\n\n}\n/* istanbul ignore next */\n;(function(riot) {\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\n\nvar RE_ORIGIN = /^.+?\\/\\/+[^\\/]+/,\n  EVENT_LISTENER = 'EventListener',\n  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n  HAS_ATTRIBUTE = 'hasAttribute',\n  REPLACE = 'replace',\n  POPSTATE = 'popstate',\n  HASHCHANGE = 'hashchange',\n  TRIGGER = 'trigger',\n  MAX_EMIT_STACK_LEVEL = 3,\n  win = typeof window != 'undefined' && window,\n  doc = typeof document != 'undefined' && document,\n  hist = win && history,\n  loc = win && (hist.location || win.location), // see html5-history-api\n  prot = Router.prototype, // to minify more\n  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n  started = false,\n  central = riot.observable(),\n  routeFound = false,\n  debouncedEmit,\n  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n    args = path.match(re)\n\n  if (args) return args.slice(1)\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t\n  return function () {\n    clearTimeout(t)\n    t = setTimeout(fn, delay)\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1)\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n  doc[ADD_EVENT_LISTENER](clickEvent, click)\n  if (autoExec) emit(true)\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = []\n  riot.observable(this) // make it observable\n  central.on('stop', this.s.bind(this))\n  central.on('emit', this.e.bind(this))\n}\n\nfunction normalize(path) {\n  return path[REPLACE](/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href)[REPLACE](RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] == '#'\n    ? (href || loc.href || '').split(base)[1] || ''\n    : (loc ? getPathFromRoot(href) : href || '')[REPLACE](base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel == 0, first\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\n  emitStackLevel++\n  emitStack.push(function() {\n    var path = getPathFromBase()\n    if (force || path != current) {\n      central[TRIGGER]('emit', path)\n      current = path\n    }\n  })\n  if (isRoot) {\n    while (first = emitStack.shift()) first() // stack increses within this call\n    emitStackLevel = 0\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which != 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) return\n\n  var el = e.target\n  while (el && el.nodeName != 'A') el = el.parentNode\n\n  if (\n    !el || el.nodeName != 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target != '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n  ) return\n\n  if (el.href != loc.href\n    && (\n      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n      || base[0] != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || base[0] == '#' && el.href.split(base)[0] != loc.href.split(base)[0] // outside of #base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    )) return\n\n  e.preventDefault()\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @param {boolean} shouldReplace - use replaceState or pushState\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title, shouldReplace) {\n  // Server-side usage: directly execute handlers for the path\n  if (!hist) return central[TRIGGER]('emit', getPathFromBase(path))\n\n  path = base + normalize(path)\n  title = title || doc.title\n  // browsers ignores the second parameter `title`\n  shouldReplace\n    ? hist.replaceState(null, title, path)\n    : hist.pushState(null, title, path)\n  // so we need to set it manually\n  doc.title = title\n  routeFound = false\n  emit()\n  return routeFound\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * two strings and boolean:        replace history with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n * @param {boolean} third - replace flag\n */\nprot.m = function(first, second, third) {\n  if (isString(first) && (!second || isString(second))) go(first, second, third || false)\n  else if (second) this.r(first, second)\n  else this.r('@', first)\n}\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*')\n  this.$ = []\n}\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args))\n      return routeFound = true // exit from loop\n    }\n  }, this)\n}\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter != '@') {\n    filter = '/' + normalize(filter)\n    this.$.push(filter)\n  }\n  this.on(filter, action)\n}\n\nvar mainRouter = new Router()\nvar route = mainRouter.m.bind(mainRouter)\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router()\n  // assign sub-router's main method\n  var router = newSubRouter.m.bind(newSubRouter)\n  // stop only this sub-router\n  router.stop = newSubRouter.s.bind(newSubRouter)\n  return router\n}\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#'\n  current = getPathFromBase() // recalculate current path\n}\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true)\n}\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER\n    secondParser = DEFAULT_SECOND_PARSER\n  }\n  if (fn) parser = fn\n  if (fn2) secondParser = fn2\n}\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {}\n  var href = loc.href || current\n  href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n  return q\n}\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    if (win) {\n      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n      doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n    }\n    central[TRIGGER]('stop')\n    started = false\n  }\n}\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (win) {\n      if (document.readyState == 'complete') start(autoExec)\n      // the timeout is needed to solve\n      // a weird safari bug https://github.com/riot/route/issues/33\n      else win[ADD_EVENT_LISTENER]('load', function() {\n        setTimeout(function() { start(autoExec) }, 1)\n      })\n    }\n    started = true\n  }\n}\n\n/** Prepare the router **/\nroute.base()\nroute.parser()\n\nriot.route = route\n})(riot)\n/* istanbul ignore next */\n\n/**\n * The riot template engine\n * @version v2.4.2\n */\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n    },\n\n    DEFAULT = '{ }'\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ]\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) bp = _cache\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) return _pairs\n\n    var arr = pair.split(' ')\n\n    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '))\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr)\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr)\n    arr[6] = _rewrite(_pairs[6], arr)\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB)\n    arr[8] = pair\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) _bp = _cache\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6]\n\n    isexpr = start = re.lastIndex = 0\n\n    while ((match = re.exec(str))) {\n\n      pos = match.index\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(str, match[2], re.lastIndex)\n          continue\n        }\n        if (!match[3]) {\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos))\n        start = re.lastIndex\n        re = _bp[6 + (isexpr ^= 1)]\n        re.lastIndex = start\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start))\n    }\n\n    return parts\n\n    function unescapeStr (s) {\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'))\n      } else {\n        parts.push(s)\n      }\n    }\n\n    function skipBraces (s, ch, ix) {\n      var\n        match,\n        recch = FINDBRACES[ch]\n\n      recch.lastIndex = ix\n      ix = 1\n      while ((match = recch.exec(s))) {\n        if (match[1] &&\n          !(match[1] === ch ? ++ix : --ix)) break\n      }\n      return ix ? s.length : recch.lastIndex\n    }\n  }\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  }\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9])\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  }\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  }\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair)\n      _regex = pair === DEFAULT ? _loopback : _rewrite\n      _cache[9] = _regex(_pairs[9])\n    }\n    cachedBrackets = pair\n  }\n\n  function _setSettings (o) {\n    var b\n\n    o = o || {}\n    b = o.brackets\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    })\n    _settings = o\n    _reset(b)\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  })\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n  _brackets.set = _reset\n\n  _brackets.R_STRINGS = R_STRINGS\n  _brackets.R_MLCOMMS = R_MLCOMMS\n  _brackets.S_QBLOCKS = S_QBLOCKS\n\n  return _brackets\n\n})()\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var _cache = {}\n\n  function _tmpl (str, data) {\n    if (!str) return str\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.haveRaw = brackets.hasRaw\n\n  _tmpl.hasExpr = brackets.hasExpr\n\n  _tmpl.loopKeys = brackets.loopKeys\n\n  // istanbul ignore next\n  _tmpl.clearCache = function () { _cache = {} }\n\n  _tmpl.errorHandler = null\n\n  function _logErr (err, ctx) {\n\n    if (_tmpl.errorHandler) {\n\n      err.riotData = {\n        tagName: ctx && ctx.root && ctx.root.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      }\n      _tmpl.errorHandler(err)\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str)\n\n    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\n    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n  }\n\n  var\n    CH_IDEXPR = String.fromCharCode(0x2057),\n    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_DQUOTE = /\\u2057/g,\n    RE_QBMARK = /\\u2057(\\d+)~/g\n\n  function _getTmpl (str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1)\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = []\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i]\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) list[j++] = expr\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")'\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr)\n    }\n\n    if (qstr[0]) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      })\n    }\n    return expr\n  }\n\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    }\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g\n\n        expr = RegExp.rightContext\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\n        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\n        jsb  = expr.slice(0, match.index)\n        expr = RegExp.rightContext\n\n        list[cnt++] = _wrapExpr(jsb, 1, key)\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch]\n\n      ir.lastIndex = re.lastIndex\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) ++lv\n        else if (!--lv) break\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/\n\n  function _wrapExpr (expr, asText, key) {\n    var tb\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos))\n        }\n      }\n      return match\n    })\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"'\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)'\n    }\n\n    return expr\n  }\n\n  _tmpl.version = brackets.version = 'v2.4.2'\n\n  return _tmpl\n\n})()\n\n/*\n  lib/browser/tag/mkdom.js\n\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\nvar mkdom = (function _mkdom() {\n  var\n    reHasYield  = /<yield\\b/i,\n    reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n    reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n    reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig\n  var\n    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n    tblTags = IE_VERSION && IE_VERSION < 10\n      ? SPECIAL_TAGS_REGEX : /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/\n\n  /**\n   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n   *\n   * @param   { String } templ  - The template coming from the custom tag definition\n   * @param   { String } [html] - HTML content that comes from the DOM element where you\n   *           will mount the tag, mostly the original tag in the page\n   * @param   { Boolean } checkSvg - flag needed to know if we need to force the svg rendering in case of loop nodes\n   * @returns {HTMLElement} DOM element with _templ_ merged through `YIELD` with the _html_.\n   */\n  function _mkdom(templ, html, checkSvg) {\n    var\n      match   = templ && templ.match(/^\\s*<([-\\w]+)/),\n      tagName = match && match[1].toLowerCase(),\n      el = mkEl('div', checkSvg && isSVGTag(tagName))\n\n    // replace all the yield tags with the tag inner html\n    templ = replaceYield(templ, html)\n\n    /* istanbul ignore next */\n    if (tblTags.test(tagName))\n      el = specialTags(el, templ, tagName)\n    else\n      setInnerHTML(el, templ)\n\n    el.stub = true\n\n    return el\n  }\n\n  /*\n    Creates the root element for table or select child elements:\n    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n  */\n  function specialTags(el, templ, tagName) {\n    var\n      select = tagName[0] === 'o',\n      parent = select ? 'select>' : 'table>'\n\n    // trim() is important here, this ensures we don't have artifacts,\n    // so we can check if we have only one element inside the parent\n    el.innerHTML = '<' + parent + templ.trim() + '</' + parent\n    parent = el.firstChild\n\n    // returns the immediate parent if tr/th/td/col is the only element, if not\n    // returns the whole tree, as this can include additional elements\n    if (select) {\n      parent.selectedIndex = -1  // for IE9, compatible w/current riot behavior\n    } else {\n      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n      var tname = rootEls[tagName]\n      if (tname && parent.childElementCount === 1) parent = $(tname, parent)\n    }\n    return parent\n  }\n\n  /*\n    Replace the yield tag from any tag template with the innerHTML of the\n    original tag in the page\n  */\n  function replaceYield(templ, html) {\n    // do nothing if no yield\n    if (!reHasYield.test(templ)) return templ\n\n    // be careful with #1343 - string on the source having `$1`\n    var src = {}\n\n    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n      src[ref] = src[ref] || text   // preserve first definition\n      return ''\n    }).trim()\n\n    return templ\n      .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n        return src[ref] || def || ''\n      })\n      .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n        return html || def || ''\n      })\n  }\n\n  return _mkdom\n\n})()\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n\n  var i = tags.length,\n    j = items.length,\n    t\n\n  while (i > j) {\n    t = tags[--i]\n    tags.splice(i, 1)\n    t.unmount()\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @param   { Object } child - non custom loop tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(child, i) {\n  Object.keys(child.tags).forEach(function(tagName) {\n    var tag = child.tags[tagName]\n    if (isArray(tag))\n      each(tag, function (t) {\n        moveChildTag(t, tagName, i)\n      })\n    else\n      moveChildTag(tag, tagName, i)\n  })\n}\n\n/**\n * Adds the elements for a virtual tag\n * @param { Tag } tag - the tag whose root's children will be inserted or appended\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction addVirtual(tag, src, target) {\n  var el = tag._root, sib\n  tag._virts = []\n  while (el) {\n    sib = el.nextSibling\n    if (target)\n      src.insertBefore(el, target._root)\n    else\n      src.appendChild(el)\n\n    tag._virts.push(el) // hold for unmounting\n    el = sib\n  }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @param { Tag } tag - first child reference used to start move\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n * @param { Number } len - how many child nodes to move\n */\nfunction moveVirtual(tag, src, target, len) {\n  var el = tag._root, sib, i = 0\n  for (; i < len; i++) {\n    sib = el.nextSibling\n    src.insertBefore(el, target._root)\n    el = sib\n  }\n}\n\n/**\n * Insert a new tag avoiding the insert for the conditional tags\n * @param   {Boolean} isVirtual [description]\n * @param   { Tag }  prevTag - tag instance used as reference to prepend our new tag\n * @param   { Tag }  newTag - new tag to be inserted\n * @param   { HTMLElement }  root - loop parent node\n * @param   { Array }  tags - array containing the current tags list\n * @param   { Function }  virtualFn - callback needed to move or insert virtual DOM\n * @param   { Object } dom - DOM node we need to loop\n */\nfunction insertTag(isVirtual, prevTag, newTag, root, tags, virtualFn, dom) {\n  if (isInStub(prevTag.root)) return\n  if (isVirtual) virtualFn(prevTag, root, newTag, dom.childNodes.length)\n  else root.insertBefore(prevTag.root, newTag.root) // #1374 some browsers reset selected here\n}\n\n\n/**\n * Manage tags having the 'each'\n * @param   { Object } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, 'each')\n\n  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n    tagName = getTagName(dom),\n    impl = __tagImpl[tagName] || { tmpl: getOuterHTML(dom) },\n    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n    root = dom.parentNode,\n    ref = document.createTextNode(''),\n    child = getTag(dom),\n    isOption = tagName.toLowerCase() === 'option', // the option tags must be treated differently\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isVirtual = dom.tagName == 'VIRTUAL'\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr)\n\n  // insert a marked where the loop tags will be injected\n  root.insertBefore(ref, dom)\n\n  // clean template code\n  parent.one('before-mount', function () {\n\n    // remove the original DOM node\n    dom.parentNode.removeChild(dom)\n    if (root.stub) root = parent.root\n\n  }).on('update', function () {\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      // create a fragment to hold the new DOM nodes to inject in the parent tag\n      frag = document.createDocumentFragment()\n\n    // object loop. any changes cause full redraw\n    if (!isArray(items)) {\n      hasKeys = items || false\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, key, items[key])\n        }) : []\n    }\n\n    // loop all the new items\n    var i = 0,\n      itemsLength = items.length\n\n    for (; i < itemsLength; i++) {\n      // reorder only if the items are objects\n      var\n        item = items[i],\n        _mustReorder = mustReorder && typeof item == T_OBJECT && !hasKeys,\n        oldPos = oldItems.indexOf(item),\n        pos = ~oldPos && _mustReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos]\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\n      // new tag\n      if (\n        !_mustReorder && !tag // with no-reorder we just update the old tags\n        ||\n        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n      ) {\n\n        tag = new Tag(impl, {\n          parent: parent,\n          isLoop: true,\n          hasImpl: !!__tagImpl[tagName],\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML)\n\n        tag.mount()\n\n        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n        // this tag must be appended\n        if (i == tags.length || !tags[i]) { // fix 1581\n          if (isVirtual)\n            addVirtual(tag, frag)\n          else frag.appendChild(tag.root)\n        }\n        // this tag must be insert\n        else {\n          insertTag(isVirtual, tag, tags[i], root, tags, addVirtual, dom)\n          oldItems.splice(i, 0, item)\n        }\n\n        tags.splice(i, 0, tag)\n        pos = i // handled here so no move\n      } else tag.update(item, true)\n\n      // reorder the tag if it's not located in its previous position\n      if (\n        pos !== i && _mustReorder &&\n        tags[i] // fix 1581 unable to reproduce it in a test!\n      ) {\n        // #closes 2040 PLEASE DON'T REMOVE IT!\n        // there are no tests for this feature\n        if (contains(items, oldItems[i]))\n          insertTag(isVirtual, tag, tags[i], root, tags, moveVirtual, dom)\n\n        // update the position attribute if it exists\n        if (expr.pos)\n          tag[expr.pos] = i\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0])\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) moveNestedTags(tag, i)\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent)\n    }\n\n    // remove the redundant tags\n    unmountRedundant(items, tags)\n\n    // insert the new nodes\n    root.insertBefore(frag, ref)\n    if (isOption) {\n\n      // #1374 FireFox bug in <option selected={expression}>\n      if (FIREFOX && !root.multiple) {\n        for (var n = 0; n < root.length; n++) {\n          if (root[n].__riot1374) {\n            root.selectedIndex = n  // clear other options\n            delete root[n].__riot1374\n            break\n          }\n        }\n      }\n    }\n\n    // set the 'tags' property of the parent tag\n    // if child is 'undefined' it means that we don't need to set this property\n    // for example:\n    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n    if (child) parent.tags[tagName] = tags\n\n    // clone the items array\n    oldItems = items.slice()\n\n  })\n\n}\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = (function(_riot) {\n\n  if (!window) return { // skip injection on the server\n    add: function () {},\n    inject: function () {}\n  }\n\n  var styleNode = (function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style')\n    setAttr(newNode, 'type', 'text/css')\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]')\n    if (userNode) {\n      if (userNode.id) newNode.id = userNode.id\n      userNode.parentNode.replaceChild(newNode, userNode)\n    }\n    else document.getElementsByTagName('head')[0].appendChild(newNode)\n\n    return newNode\n  })()\n\n  // Create cache and shortcut to the correct property\n  var cssTextProp = styleNode.styleSheet,\n    stylesToInject = ''\n\n  // Expose the style node in a non-modificable property\n  Object.defineProperty(_riot, 'styleNode', {\n    value: styleNode,\n    writable: true\n  })\n\n  /**\n   * Public api\n   */\n  return {\n    /**\n     * Save a tag style to be later injected into DOM\n     * @param   { String } css [description]\n     */\n    add: function(css) {\n      stylesToInject += css\n    },\n    /**\n     * Inject all previously saved tag styles into DOM\n     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n     */\n    inject: function() {\n      if (stylesToInject) {\n        if (cssTextProp) cssTextProp.cssText += stylesToInject\n        else styleNode.innerHTML += stylesToInject\n        stylesToInject = ''\n      }\n    }\n  }\n\n})(riot)\n\n\nfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = dom.isLoop ||\n                  (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each'))\n                    ? 1 : 0\n\n      // custom child tag\n      if (childTags) {\n        var child = getTag(dom)\n\n        if (child && !dom.isLoop)\n          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n      }\n\n      if (!dom.isLoop || forceParsingNamed)\n        setNamed(dom, tag, [])\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (tmpl.hasExpr(val)) {\n      expressions.push(extend({ dom: dom, expr: val }, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType,\n      attr\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    attr = getAttr(dom, 'each')\n\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n    opts = inherit(conf.opts) || {},\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    hasImpl = conf.hasImpl,\n    item = cleanUpData(conf.item),\n    expressions = [],\n    childTags = [],\n    root = conf.root,\n    tagName = root.tagName.toLowerCase(),\n    attr = {},\n    propsInSyncWithParent = [],\n    dom\n\n  // only call unmount if we have a valid __tagImpl (has name property)\n  if (impl.name && root._tag) root._tag.unmount(true)\n\n  // not yet mounted\n  this.isMounted = false\n  root.isLoop = isLoop\n\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\n  extend(this, { parent: parent, root: root, opts: opts}, item)\n  // protect the \"tags\" property from being overridden\n  defineProperty(this, 'tags', {})\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    var val = el.value\n    // remember attributes with expressions only\n    if (tmpl.hasExpr(val)) attr[el.name] = val\n  })\n\n  dom = mkdom(impl.tmpl, innerHTML, isLoop)\n\n  // options\n  function updateOpts() {\n    var ctx = hasImpl && isLoop ? self : parent || self\n\n    // update opts from current DOM attributes\n    each(root.attributes, function(el) {\n      var val = el.value\n      opts[toCamel(el.name)] = tmpl.hasExpr(val) ? tmpl(val, ctx) : val\n    })\n    // recover those with expressions\n    each(Object.keys(attr), function(name) {\n      opts[toCamel(name)] = tmpl(attr[name], ctx)\n    })\n  }\n\n  function normalizeData(data) {\n    for (var key in item) {\n      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n        self[key] = data[key]\n    }\n  }\n\n  function inheritFrom(target) {\n    each(Object.keys(target), function(k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = !RESERVED_WORDS_BLACKLIST.test(k) && contains(propsInSyncWithParent, k)\n\n      if (typeof self[k] === T_UNDEF || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) propsInSyncWithParent.push(k)\n        self[k] = target[k]\n      }\n    })\n  }\n\n  /**\n   * Update the tag expressions and options\n   * @param   { * }  data - data we want to use to extend the tag properties\n   * @param   { Boolean } isInherited - is this update coming from a parent tag?\n   * @returns { self }\n   */\n  defineProperty(this, 'update', function(data, isInherited) {\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data)\n    // inherit properties from the parent in loop\n    if (isLoop) {\n      inheritFrom(self.parent)\n    }\n    // normalize the tag properties in case an item object was initially passed\n    if (data && isObject(item)) {\n      normalizeData(data)\n      item = data\n    }\n    extend(self, data)\n    updateOpts()\n    self.trigger('update', data)\n    update(expressions, self)\n\n    // the updated event will be triggered\n    // once the DOM will be ready and all the re-flows are completed\n    // this is useful if you want to get the \"real\" root properties\n    // 4 ex: root.offsetWidth ...\n    if (isInherited && self.parent)\n      // closes #1599\n      self.parent.one('updated', function() { self.trigger('updated') })\n    else rAF(function() { self.trigger('updated') })\n\n    return this\n  })\n\n  defineProperty(this, 'mixin', function() {\n    each(arguments, function(mix) {\n      var instance,\n        props = [],\n        obj\n\n      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix()\n      } else instance = mix\n\n      var proto = Object.getPrototypeOf(instance)\n\n      // build multilevel prototype inheritance chain property list\n      do props = props.concat(Object.getOwnPropertyNames(obj || instance))\n      while (obj = Object.getPrototypeOf(obj || instance))\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function(key) {\n        // bind methods to self\n        // allow mixins to override other properties/parent mixins\n        if (key != 'init') {\n          // check for getters/setters\n          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key)\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set)\n\n          // apply method only if it does not already exist on the instance\n          if (!self.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(self, key, descriptor)\n          } else {\n            self[key] = isFunction(instance[key]) ?\n              instance[key].bind(self) :\n              instance[key]\n          }\n        }\n      })\n\n      // init method will be called automatically\n      if (instance.init) instance.init.bind(self)()\n    })\n    return this\n  })\n\n  defineProperty(this, 'mount', function() {\n\n    updateOpts()\n\n    // add global mixins\n    var globalMixin = riot.mixin(GLOBAL_MIXIN)\n\n    if (globalMixin)\n      for (var i in globalMixin)\n        if (globalMixin.hasOwnProperty(i))\n          self.mixin(globalMixin[i])\n\n    // children in loop should inherit from true parent\n    if (self._parent && self._parent.root.isLoop) {\n      inheritFrom(self._parent)\n    }\n\n    // initialiation\n    if (impl.fn) impl.fn.call(self, opts)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    // mount the child tags\n    toggle(true)\n\n    // update the root adding custom attributes coming from the compiler\n    // it fixes also #1087\n    if (impl.attrs)\n      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })\n    if (impl.attrs || hasImpl)\n      parseExpressions(self.root, self, expressions)\n\n    if (!self.parent || isLoop) self.update(item)\n\n    // internal use only, fixes #403\n    self.trigger('before-mount')\n\n    if (isLoop && !hasImpl) {\n      // update the root attribute for the looped elements\n      root = dom.firstChild\n    } else {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n      if (root.stub) root = parent.root\n    }\n\n    defineProperty(self, 'root', root)\n\n    // parse the named dom nodes in the looped child\n    // adding them to the parent as well\n    if (isLoop)\n      parseNamedElements(self.root, self.parent, null, true)\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent || self.parent.isMounted) {\n      self.isMounted = true\n      self.trigger('mount')\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() {\n      // avoid to trigger the `mount` event for the tags\n      // not visible included in an if statement\n      if (!isInStub(self.root)) {\n        self.parent.isMounted = self.isMounted = true\n        self.trigger('mount')\n      }\n    })\n  })\n\n\n  defineProperty(this, 'unmount', function(keepRootTag) {\n    var el = root,\n      p = el.parentNode,\n      ptag,\n      tagIndex = __virtualDom.indexOf(self)\n\n    self.trigger('before-unmount')\n\n    // remove this tag instance from the global virtualDom variable\n    if (~tagIndex)\n      __virtualDom.splice(tagIndex, 1)\n\n    if (p) {\n\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent)\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (isArray(ptag.tags[tagName]))\n          each(ptag.tags[tagName], function(tag, i) {\n            if (tag._riot_id == self._riot_id)\n              ptag.tags[tagName].splice(i, 1)\n          })\n        else\n          // otherwise just delete the tag instance\n          ptag.tags[tagName] = undefined\n      }\n\n      else\n        while (el.firstChild) el.removeChild(el.firstChild)\n\n      if (!keepRootTag)\n        p.removeChild(el)\n      else {\n        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n        remAttr(p, RIOT_TAG_IS)\n        remAttr(p, RIOT_TAG) // this will be removed in riot 3.0.0\n      }\n\n    }\n\n    if (this._virts) {\n      each(this._virts, function(v) {\n        if (v.parentNode) v.parentNode.removeChild(v)\n      })\n    }\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    self.isMounted = false\n    delete root._tag\n\n  })\n\n  // proxy function to bind updates\n  // dispatched from a parent tag\n  function onChildUpdate(data) { self.update(data, true) }\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (!parent) return\n    var evt = isMount ? 'on' : 'off'\n\n    // the loop tags will be always in sync with the parent automatically\n    if (isLoop)\n      parent[evt]('unmount', self.unmount)\n    else {\n      parent[evt]('update', onChildUpdate)[evt]('unmount', self.unmount)\n    }\n  }\n\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n}\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n\n  dom[name] = function(e) {\n\n    var ptag = tag._parent,\n      item = tag._item,\n      el\n\n    if (!item)\n      while (ptag && !item) {\n        item = ptag._item\n        ptag = ptag._parent\n      }\n\n    // cross browser event fix\n    e = e || window.event\n\n    // override the event properties\n    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n    if (isWritable(e, 'target')) e.target = e.srcElement\n    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      if (e.preventDefault) e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      el = item ? getImmediateCustomParentTag(ptag) : tag\n      el.update()\n    }\n\n  }\n\n}\n\n\n/**\n * Insert a DOM node replacing another one (used by if- attribute)\n * @param   { Object } root - parent node\n * @param   { Object } node - node replaced\n * @param   { Object } before - node added\n */\nfunction insertTo(root, node, before) {\n  if (!root) return\n  root.insertBefore(before, node)\n  root.removeChild(node)\n}\n\n/**\n * Update the expressions in a Tag instance\n * @param   { Array } expressions - expression that must be re evaluated\n * @param   { Tag } tag - tag instance\n */\nfunction update(expressions, tag) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n      attrName = expr.attr,\n      value = tmpl(expr.expr, tag),\n      parent = expr.parent || expr.dom.parentNode\n\n    if (expr.bool) {\n      value = !!value\n    } else if (value == null) {\n      value = ''\n    }\n\n    // #1638: regression of #1612, update the dom only if the value of the\n    // expression was changed\n    if (expr.value === value) {\n      return\n    }\n    expr.value = value\n\n    // textarea and text nodes has no attribute name\n    if (!attrName) {\n      // about #815 w/o replace: the browser converts the value to a string,\n      // the comparison by \"==\" does too, but not in the server\n      value += ''\n      // test for parent avoids error with invalid assignment to nodeValue\n      if (parent) {\n        // cache the parent node because somehow it will become null on IE\n        // on the next iteration\n        expr.parent = parent\n        if (parent.tagName === 'TEXTAREA') {\n          parent.value = value                    // #1113\n          if (!IE_VERSION) dom.nodeValue = value  // #1625 IE throws here, nodeValue\n        }                                         // will be available on 'updated'\n        else dom.nodeValue = value\n      }\n      return\n    }\n\n    // ~~#1612: look for changes in dom.value when updating the value~~\n    if (attrName === 'value') {\n      if (dom.value !== value) {\n        dom.value = value\n        setAttr(dom, attrName, value)\n      }\n      return\n    } else {\n      // remove original attribute\n      remAttr(dom, attrName)\n    }\n\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, tag)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub,\n        add = function() { insertTo(stub.parentNode, stub, dom) },\n        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\n      // add to DOM\n      if (value) {\n        if (stub) {\n          add()\n          dom.inStub = false\n          // avoid to trigger the mount event if the tags is not visible yet\n          // maybe we can optimize this avoiding to mount the tag at all\n          if (!isInStub(dom)) {\n            walk(dom, function(el) {\n              if (el._tag && !el._tag.isMounted)\n                el._tag.isMounted = !!el._tag.trigger('mount')\n            })\n          }\n        }\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        // if the parentNode is defined we can easily replace the tag\n        if (dom.parentNode)\n          remove()\n        // otherwise we need to wait the updated event\n        else (tag.parent || tag).one('updated', remove)\n\n        dom.inStub = true\n      }\n    // show / hide\n    } else if (attrName === 'show') {\n      dom.style.display = value ? '' : 'none'\n\n    } else if (attrName === 'hide') {\n      dom.style.display = value ? 'none' : ''\n\n    } else if (expr.bool) {\n      dom[attrName] = value\n      if (value) setAttr(dom, attrName, attrName)\n      if (FIREFOX && attrName === 'selected' && dom.tagName === 'OPTION') {\n        dom.__riot1374 = value   // #1374\n      }\n\n    } else if (value === 0 || value && typeof value !== T_OBJECT) {\n      // <img src=\"{ expr }\">\n      if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n        attrName = attrName.slice(RIOT_PREFIX.length)\n      }\n      setAttr(dom, attrName, value)\n    }\n\n  })\n\n}\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } els - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(els, fn) {\n  var len = els ? els.length : 0\n\n  for (var i = 0, el; i < len; i++) {\n    el = els[i]\n    // return false -> current item was removed by fn during the loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\n/**\n * Detect if the argument passed is a function\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isFunction(v) {\n  return typeof v === T_FUNCTION || false   // avoid IE problems\n}\n\n/**\n * Get the outer html of any DOM node SVGs included\n * @param   { Object } el - DOM node to parse\n * @returns { String } el.outerHTML\n */\nfunction getOuterHTML(el) {\n  if (el.outerHTML) return el.outerHTML\n  // some browsers do not support outerHTML on the SVGs tags\n  else {\n    var container = mkEl('div')\n    container.appendChild(el.cloneNode(true))\n    return container.innerHTML\n  }\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we will inject the new html\n * @param { String } html - html to inject\n */\nfunction setInnerHTML(container, html) {\n  if (typeof container.innerHTML != T_UNDEF) container.innerHTML = html\n  // some browsers do not support innerHTML on the SVGs tags\n  else {\n    var doc = new DOMParser().parseFromString(html, 'application/xml')\n    container.appendChild(\n      container.ownerDocument.importNode(doc.documentElement, true)\n    )\n  }\n}\n\n/**\n * Checks wether a DOM node must be considered part of an svg document\n * @param   { String }  name - tag name\n * @returns { Boolean } -\n */\nfunction isSVGTag(name) {\n  return ~SVG_TAGS_LIST.indexOf(name)\n}\n\n/**\n * Detect if the argument passed is an object, exclude null.\n * NOTE: Use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isObject(v) {\n  return v && typeof v === T_OBJECT         // typeof null is 'object'\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } string - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(string) {\n  return string.replace(/-(\\w)/g, function(_, c) {\n    return c.toUpperCase()\n  })\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM/SVG attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  var xlink = XLINK_REGEX.exec(name)\n  if (xlink && xlink[1])\n    dom.setAttributeNS(XLINK_NS, xlink[1], val)\n  else\n    dom.setAttribute(name, val)\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG_IS) ||\n    getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n}\n/**\n * Add a child tag to its parent into the `tags` object\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the new tag will be stored\n * @param   { Object } parent - tag instance where the new child tag will be included\n */\nfunction addChildTag(tag, tagName, parent) {\n  var cachedTag = parent.tags[tagName]\n\n  // if there are multiple children tags having the same name\n  if (cachedTag) {\n    // if the parent tags property is not yet an array\n    // create it adding the first cached tag\n    if (!isArray(cachedTag))\n      // don't add the same tag twice\n      if (cachedTag !== tag)\n        parent.tags[tagName] = [cachedTag]\n    // add the new nested tag to the array\n    if (!contains(parent.tags[tagName], tag))\n      parent.tags[tagName].push(tag)\n  } else {\n    parent.tags[tagName] = tag\n  }\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tag, tagName, newPos) {\n  var parent = tag.parent,\n    tags\n  // no parent no move\n  if (!parent) return\n\n  tags = parent.tags[tagName]\n\n  if (isArray(tags))\n    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n  else addChildTag(tag, tagName, parent)\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag(child, opts, innerHTML),\n    tagName = getTagName(opts.root),\n    ptag = getImmediateCustomParentTag(parent)\n  // fix for the parent attribute in the looped elements\n  tag.parent = ptag\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent\n\n  // add this tag to the custom parent tag\n  addChildTag(tag, tagName, ptag)\n  // and also to the real parent tag\n  if (ptag !== parent)\n    addChildTag(tag, tagName, parent)\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = ''\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag\n  while (!getTag(ptag.root)) {\n    if (!ptag.parent) break\n    ptag = ptag.parent\n  }\n  return ptag\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n* @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options))\n  return el\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom) {\n  var child = getTag(dom),\n    namedTag = getAttr(dom, 'name'),\n    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n\n  return tagName\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          src[key] = obj[key]\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } arr - target array\n * @param   { * } item - item to test\n * @returns { Boolean } Does 'arr' contain 'item'?\n */\nfunction contains(arr, item) {\n  return ~arr.indexOf(item)\n}\n\n/**\n * Check whether an object is a kind of array\n * @param   { * } a - anything\n * @returns {Boolean} is 'a' an array?\n */\nfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\n/**\n * Detect whether a property of an object could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } is this property writable?\n */\nfunction isWritable(obj, key) {\n  var props = Object.getOwnPropertyDescriptor(obj, key)\n  return typeof obj[key] === T_UNDEF || props && props.writable\n}\n\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION))\n    return data\n\n  var o = {}\n  for (var key in data) {\n    if (!RESERVED_WORDS_BLACKLIST.test(key)) o[key] = data[key]\n  }\n  return o\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n */\nfunction walk(dom, fn) {\n  if (dom) {\n    // stop the recursion\n    if (fn(dom) === false) return\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  var m,\n    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\n  while (m = re.exec(html)) {\n    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n  }\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub) return true\n    dom = dom.parentNode\n  }\n  return false\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @param   { Boolean } isSvg - should we use a SVG as parent node?\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name, isSvg) {\n  return isSvg ?\n    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :\n    document.createElement(name)\n}\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Simple object prototypal inheritance\n * @param   { Object } parent - parent object\n * @returns { Object } child instance\n */\nfunction inherit(parent) {\n  return Object.create(parent || null)\n}\n\n/**\n * Get the name property needed to identify a DOM node in riot\n * @param   { Object } dom - DOM node we need to parse\n * @returns { String | undefined } give us back a string to identify this dom node\n */\nfunction getNamedKey(dom) {\n  return getAttr(dom, 'id') || getAttr(dom, 'name')\n}\n\n/**\n * Set the named properties of a tag element\n * @param { Object } dom - DOM node we need to parse\n * @param { Object } parent - tag instance where the named dom element will be eventually added\n * @param { Array } keys - list of all the tag instance properties\n */\nfunction setNamed(dom, parent, keys) {\n  // get the key value we want to add to the tag instance\n  var key = getNamedKey(dom),\n    isArr,\n    // add the node detected to a tag instance using the named property\n    add = function(value) {\n      // avoid to override the tag properties already set\n      if (contains(keys, key)) return\n      // check whether this value is an array\n      isArr = isArray(value)\n      // if the key was never set\n      if (!value)\n        // set it once on the tag instance\n        parent[key] = dom\n      // if it was an array and not yet set\n      else if (!isArr || isArr && !contains(value, dom)) {\n        // add the dom node into the array\n        if (isArr)\n          value.push(dom)\n        else\n          parent[key] = [value, dom]\n      }\n    }\n\n  // skip the elements with no named properties\n  if (!key) return\n\n  // check whether this key has been already evaluated\n  if (tmpl.hasExpr(key))\n    // wait the first updated event only once\n    parent.one('mount', function() {\n      key = getNamedKey(dom)\n      add(parent[key])\n    })\n  else\n    add(parent[key])\n\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } src - source string\n * @param   { String } str - test string\n * @returns { Boolean } -\n */\nfunction startsWith(src, str) {\n  return src.slice(0, str.length) === str\n}\n\n/**\n * requestAnimationFrame function\n * Adapted from https://gist.github.com/paulirish/1579671, license MIT\n */\nvar rAF = (function (w) {\n  var raf = w.requestAnimationFrame    ||\n            w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame\n\n  if (!raf || /iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent)) {  // buggy iOS6\n    var lastTime = 0\n\n    raf = function (cb) {\n      var nowtime = Date.now(), timeout = Math.max(16 - (nowtime - lastTime), 0)\n      setTimeout(function () { cb(lastTime = nowtime + timeout) }, timeout)\n    }\n  }\n  return raf\n\n})(window || {})\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts) {\n  var tag = __tagImpl[tagName],\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    // add this tag to the virtualDom variable\n    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n  }\n\n  return tag\n}\n/**\n * Riot public api\n */\n\n// share methods for other riot parts, e.g. compiler\nriot.util = { brackets: brackets, tmpl: tmpl }\n\n/**\n * Create a mixin that could be globally shared across all the tags\n */\nriot.mixin = (function() {\n  var mixins = {},\n    globals = mixins[GLOBAL_MIXIN] = {},\n    _id = 0\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String }  name - mixin name (global mixin if object)\n   * @param   { Object }  mixin - mixin logic\n   * @param   { Boolean } g - is global?\n   * @returns { Object }  the mixin logic\n   */\n  return function(name, mixin, g) {\n    // Unnamed global\n    if (isObject(name)) {\n      riot.mixin('__unnamed_'+_id++, name, true)\n      return\n    }\n\n    var store = g ? globals : mixins\n\n    // Getter\n    if (!mixin) {\n      if (typeof store[name] === T_UNDEF) {\n        throw new Error('Unregistered mixin: ' + name)\n      }\n      return store[name]\n    }\n    // Setter\n    if (isFunction(mixin)) {\n      extend(mixin.prototype, store[name] || {})\n      store[name] = mixin\n    }\n    else {\n      store[name] = extend(store[name] || {}, mixin)\n    }\n  }\n\n})()\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag = function(name, html, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css\n      css = ''\n    } else attrs = ''\n  }\n  if (css) {\n    if (isFunction(css)) fn = css\n    else styleManager.add(css)\n  }\n  name = name.toLowerCase()\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag2 = function(name, html, css, attrs, fn) {\n  if (css) styleManager.add(css)\n  //if (bpair) riot.settings.brackets = bpair\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { String } selector - tag DOM selector\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nriot.mount = function(selector, tagName, opts) {\n\n  var els,\n    allTags,\n    tags = []\n\n  // helper functions\n\n  function addRiotTags(arr) {\n    var list = ''\n    each(arr, function (e) {\n      if (!/[^-\\w]/.test(e)) {\n        e = e.trim().toLowerCase()\n        list += ',[' + RIOT_TAG_IS + '=\"' + e + '\"],[' + RIOT_TAG + '=\"' + e + '\"]'\n      }\n    })\n    return list\n  }\n\n  function selectAllTags() {\n    var keys = Object.keys(__tagImpl)\n    return keys + addRiotTags(keys)\n  }\n\n  function pushTags(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, RIOT_TAG_IS) || getAttr(root, RIOT_TAG)\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName\n        setAttr(root, RIOT_TAG_IS, tagName)\n        setAttr(root, RIOT_TAG, tagName) // this will be removed in riot 3.0.0\n      }\n      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)\n\n      if (tag) tags.push(tag)\n    } else if (root.length) {\n      each(root, pushTags)   // assume nodeList\n    }\n  }\n\n  // ----- mount code -----\n\n  // inject styles into DOM\n  styleManager.inject()\n\n  if (isObject(tagName)) {\n    opts = tagName\n    tagName = 0\n  }\n\n  // crawl the DOM to find the tag\n  if (typeof selector === T_STRING) {\n    if (selector === '*')\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selectAllTags()\n    else\n      // or just the ones named like the selector\n      selector += addRiotTags(selector.split(/, */))\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    els = selector ? $$(selector) : []\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    els = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectAllTags()\n    // if the root els it's just a single tag\n    if (els.tagName)\n      els = $$(tagName, els)\n    else {\n      // select all the children for all the different root elements\n      var nodeList = []\n      each(els, function (_el) {\n        nodeList.push($$(tagName, _el))\n      })\n      els = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  pushTags(els)\n\n  return tags\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nriot.update = function() {\n  return each(__virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n/**\n * Export the Virtual DOM\n */\nriot.vdom = __virtualDom\n\n/**\n * Export the Tag constructor\n */\nriot.Tag = Tag\n  // support CommonJS, AMD & browser\n  /* istanbul ignore next */\n  if (typeof exports === T_OBJECT)\n    module.exports = riot\n  else if (\"function\" === T_FUNCTION && typeof __webpack_require__(37) !== T_UNDEF)\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return riot }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : void 0);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9qb3JnZS9kZXYvZ2FsbC9ub2RlX21vZHVsZXMvcmlvdC9yaW90LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFJpb3QgdjIuNi43LCBAbGljZW5zZSBNSVQgKi9cblxuOyhmdW5jdGlvbih3aW5kb3csIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG52YXIgcmlvdCA9IHsgdmVyc2lvbjogJ3YyLjYuNycsIHNldHRpbmdzOiB7fSB9LFxuICAvLyBiZSBhd2FyZSwgaW50ZXJuYWwgdXNhZ2VcbiAgLy8gQVRURU5USU9OOiBwcmVmaXggdGhlIGdsb2JhbCBkeW5hbWljIHZhcmlhYmxlcyB3aXRoIGBfX2BcblxuICAvLyBjb3VudGVyIHRvIGdpdmUgYSB1bmlxdWUgaWQgdG8gYWxsIHRoZSBUYWcgaW5zdGFuY2VzXG4gIF9fdWlkID0gMCxcbiAgLy8gdGFncyBpbnN0YW5jZXMgY2FjaGVcbiAgX192aXJ0dWFsRG9tID0gW10sXG4gIC8vIHRhZ3MgaW1wbGVtZW50YXRpb24gY2FjaGVcbiAgX190YWdJbXBsID0ge30sXG5cbiAgLyoqXG4gICAqIENvbnN0XG4gICAqL1xuICBHTE9CQUxfTUlYSU4gPSAnX19nbG9iYWxfbWl4aW4nLFxuXG4gIC8vIHJpb3Qgc3BlY2lmaWMgcHJlZml4ZXNcbiAgUklPVF9QUkVGSVggPSAncmlvdC0nLFxuICBSSU9UX1RBRyA9IFJJT1RfUFJFRklYICsgJ3RhZycsXG4gIFJJT1RfVEFHX0lTID0gJ2RhdGEtaXMnLFxuXG4gIC8vIGZvciB0eXBlb2YgPT0gJycgY29tcGFyaXNvbnNcbiAgVF9TVFJJTkcgPSAnc3RyaW5nJyxcbiAgVF9PQkpFQ1QgPSAnb2JqZWN0JyxcbiAgVF9VTkRFRiAgPSAndW5kZWZpbmVkJyxcbiAgVF9GVU5DVElPTiA9ICdmdW5jdGlvbicsXG4gIFhMSU5LX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICBYTElOS19SRUdFWCA9IC9eeGxpbms6KFxcdyspLyxcbiAgLy8gc3BlY2lhbCBuYXRpdmUgdGFncyB0aGF0IGNhbm5vdCBiZSB0cmVhdGVkIGxpa2UgdGhlIG90aGVyc1xuICBTUEVDSUFMX1RBR1NfUkVHRVggPSAvXig/OnQoPzpib2R5fGhlYWR8Zm9vdHxbcmhkXSl8Y2FwdGlvbnxjb2woPzpncm91cCk/fG9wdCg/Omlvbnxncm91cCkpJC8sXG4gIFJFU0VSVkVEX1dPUkRTX0JMQUNLTElTVCA9IC9eKD86Xyg/Oml0ZW18aWR8cGFyZW50KXx1cGRhdGV8cm9vdHwoPzp1bik/bW91bnR8bWl4aW58aXMoPzpNb3VudGVkfExvb3ApfHRhZ3N8cGFyZW50fG9wdHN8dHJpZ2dlcnxvKD86bnxmZnxuZSkpJC8sXG4gIC8vIFNWRyB0YWdzIGxpc3QgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9hdHRpbmRleC5odG1sI1ByZXNlbnRhdGlvbkF0dHJpYnV0ZXNcbiAgU1ZHX1RBR1NfTElTVCA9IFsnYWx0R2x5cGgnLCAnYW5pbWF0ZScsICdhbmltYXRlQ29sb3InLCAnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2RlZnMnLCAnZWxsaXBzZScsICdmZUJsZW5kJywgJ2ZlQ29sb3JNYXRyaXgnLCAnZmVDb21wb25lbnRUcmFuc2ZlcicsICdmZUNvbXBvc2l0ZScsICdmZUNvbnZvbHZlTWF0cml4JywgJ2ZlRGlmZnVzZUxpZ2h0aW5nJywgJ2ZlRGlzcGxhY2VtZW50TWFwJywgJ2ZlRmxvb2QnLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVJbWFnZScsICdmZU1lcmdlJywgJ2ZlTW9ycGhvbG9neScsICdmZU9mZnNldCcsICdmZVNwZWN1bGFyTGlnaHRpbmcnLCAnZmVUaWxlJywgJ2ZlVHVyYnVsZW5jZScsICdmaWx0ZXInLCAnZm9udCcsICdmb3JlaWduT2JqZWN0JywgJ2cnLCAnZ2x5cGgnLCAnZ2x5cGhSZWYnLCAnaW1hZ2UnLCAnbGluZScsICdsaW5lYXJHcmFkaWVudCcsICdtYXJrZXInLCAnbWFzaycsICdtaXNzaW5nLWdseXBoJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICdzdmcnLCAnc3dpdGNoJywgJ3N5bWJvbCcsICd0ZXh0JywgJ3RleHRQYXRoJywgJ3RyZWYnLCAndHNwYW4nLCAndXNlJ10sXG5cbiAgLy8gdmVyc2lvbiMgZm9yIElFIDgtMTEsIDAgZm9yIG90aGVyc1xuICBJRV9WRVJTSU9OID0gKHdpbmRvdyAmJiB3aW5kb3cuZG9jdW1lbnQgfHwge30pLmRvY3VtZW50TW9kZSB8IDAsXG5cbiAgLy8gZGV0ZWN0IGZpcmVmb3ggdG8gZml4ICMxMzc0XG4gIEZJUkVGT1ggPSB3aW5kb3cgJiYgISF3aW5kb3cuSW5zdGFsbFRyaWdnZXJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5yaW90Lm9ic2VydmFibGUgPSBmdW5jdGlvbihlbCkge1xuXG4gIC8qKlxuICAgKiBFeHRlbmQgdGhlIG9yaWdpbmFsIG9iamVjdCBvciBjcmVhdGUgYSBuZXcgZW1wdHkgb25lXG4gICAqIEB0eXBlIHsgT2JqZWN0IH1cbiAgICovXG5cbiAgZWwgPSBlbCB8fCB7fVxuXG4gIC8qKlxuICAgKiBQcml2YXRlIHZhcmlhYmxlc1xuICAgKi9cbiAgdmFyIGNhbGxiYWNrcyA9IHt9LFxuICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG5cbiAgLyoqXG4gICAqIFByaXZhdGUgTWV0aG9kc1xuICAgKi9cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIG5lZWRlZCB0byBnZXQgYW5kIGxvb3AgYWxsIHRoZSBldmVudHMgaW4gYSBzdHJpbmdcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGUgLSBldmVudCBzdHJpbmdcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgIGZuIC0gY2FsbGJhY2tcbiAgICovXG4gIGZ1bmN0aW9uIG9uRWFjaEV2ZW50KGUsIGZuKSB7XG4gICAgdmFyIGVzID0gZS5zcGxpdCgnICcpLCBsID0gZXMubGVuZ3RoLCBpID0gMFxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGVzW2ldXG4gICAgICBpZiAobmFtZSkgZm4obmFtZSwgaSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIEFwaVxuICAgKi9cblxuICAvLyBleHRlbmQgdGhlIGVsIG9iamVjdCBhZGRpbmcgdGhlIG9ic2VydmFibGUgbWV0aG9kc1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlbCwge1xuICAgIC8qKlxuICAgICAqIExpc3RlbiB0byB0aGUgZ2l2ZW4gc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgYGV2ZW50c2AgYW5kXG4gICAgICogZXhlY3V0ZSB0aGUgYGNhbGxiYWNrYCBlYWNoIHRpbWUgYW4gZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAqIEBwYXJhbSAgeyBTdHJpbmcgfSBldmVudHMgLSBldmVudHMgaWRzXG4gICAgICogQHBhcmFtICB7IEZ1bmN0aW9uIH0gZm4gLSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZWxcbiAgICAgKi9cbiAgICBvbjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGV2ZW50cywgZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPSAnZnVuY3Rpb24nKSAgcmV0dXJuIGVsXG5cbiAgICAgICAgb25FYWNoRXZlbnQoZXZlbnRzLCBmdW5jdGlvbihuYW1lLCBwb3MpIHtcbiAgICAgICAgICAoY2FsbGJhY2tzW25hbWVdID0gY2FsbGJhY2tzW25hbWVdIHx8IFtdKS5wdXNoKGZuKVxuICAgICAgICAgIGZuLnR5cGVkID0gcG9zID4gMFxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiBlbFxuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBgZXZlbnRzYCBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IGV2ZW50cyAtIGV2ZW50cyBpZHNcbiAgICAgKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZWxcbiAgICAgKi9cbiAgICBvZmY6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihldmVudHMsIGZuKSB7XG4gICAgICAgIGlmIChldmVudHMgPT0gJyonICYmICFmbikgY2FsbGJhY2tzID0ge31cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgb25FYWNoRXZlbnQoZXZlbnRzLCBmdW5jdGlvbihuYW1lLCBwb3MpIHtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICB2YXIgYXJyID0gY2FsbGJhY2tzW25hbWVdXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjYjsgY2IgPSBhcnIgJiYgYXJyW2ldOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2IgPT0gZm4pIGFyci5zcGxpY2UoaS0tLCAxKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgZGVsZXRlIGNhbGxiYWNrc1tuYW1lXVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsXG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpc3RlbiB0byB0aGUgZ2l2ZW4gc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgYGV2ZW50c2AgYW5kXG4gICAgICogZXhlY3V0ZSB0aGUgYGNhbGxiYWNrYCBhdCBtb3N0IG9uY2VcbiAgICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IGV2ZW50cyAtIGV2ZW50cyBpZHNcbiAgICAgKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZWxcbiAgICAgKi9cbiAgICBvbmU6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihldmVudHMsIGZuKSB7XG4gICAgICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgICAgIGVsLm9mZihldmVudHMsIG9uKVxuICAgICAgICAgIGZuLmFwcGx5KGVsLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsLm9uKGV2ZW50cywgb24pXG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYWxsIGNhbGxiYWNrIGZ1bmN0aW9ucyB0aGF0IGxpc3RlbiB0b1xuICAgICAqIHRoZSBnaXZlbiBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBgZXZlbnRzYFxuICAgICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gZXZlbnRzIC0gZXZlbnRzIGlkc1xuICAgICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZWxcbiAgICAgKi9cbiAgICB0cmlnZ2VyOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oZXZlbnRzKSB7XG5cbiAgICAgICAgLy8gZ2V0dGluZyB0aGUgYXJndW1lbnRzXG4gICAgICAgIHZhciBhcmdsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFyZ2xlbiksXG4gICAgICAgICAgZm5zXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdsZW47IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdIC8vIHNraXAgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIG9uRWFjaEV2ZW50KGV2ZW50cywgZnVuY3Rpb24obmFtZSwgcG9zKSB7XG5cbiAgICAgICAgICBmbnMgPSBzbGljZS5jYWxsKGNhbGxiYWNrc1tuYW1lXSB8fCBbXSwgMClcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBmbjsgZm4gPSBmbnNbaV07ICsraSkge1xuICAgICAgICAgICAgaWYgKGZuLmJ1c3kpIGNvbnRpbnVlXG4gICAgICAgICAgICBmbi5idXN5ID0gMVxuICAgICAgICAgICAgZm4uYXBwbHkoZWwsIGZuLnR5cGVkID8gW25hbWVdLmNvbmNhdChhcmdzKSA6IGFyZ3MpXG4gICAgICAgICAgICBpZiAoZm5zW2ldICE9PSBmbikgeyBpLS0gfVxuICAgICAgICAgICAgZm4uYnVzeSA9IDBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2tzWycqJ10gJiYgbmFtZSAhPSAnKicpXG4gICAgICAgICAgICBlbC50cmlnZ2VyLmFwcGx5KGVsLCBbJyonLCBuYW1lXS5jb25jYXQoYXJncykpXG5cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gZWxcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGVsXG5cbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG47KGZ1bmN0aW9uKHJpb3QpIHtcblxuLyoqXG4gKiBTaW1wbGUgY2xpZW50LXNpZGUgcm91dGVyXG4gKiBAbW9kdWxlIHJpb3Qtcm91dGVcbiAqL1xuXG5cbnZhciBSRV9PUklHSU4gPSAvXi4rP1xcL1xcLytbXlxcL10rLyxcbiAgRVZFTlRfTElTVEVORVIgPSAnRXZlbnRMaXN0ZW5lcicsXG4gIFJFTU9WRV9FVkVOVF9MSVNURU5FUiA9ICdyZW1vdmUnICsgRVZFTlRfTElTVEVORVIsXG4gIEFERF9FVkVOVF9MSVNURU5FUiA9ICdhZGQnICsgRVZFTlRfTElTVEVORVIsXG4gIEhBU19BVFRSSUJVVEUgPSAnaGFzQXR0cmlidXRlJyxcbiAgUkVQTEFDRSA9ICdyZXBsYWNlJyxcbiAgUE9QU1RBVEUgPSAncG9wc3RhdGUnLFxuICBIQVNIQ0hBTkdFID0gJ2hhc2hjaGFuZ2UnLFxuICBUUklHR0VSID0gJ3RyaWdnZXInLFxuICBNQVhfRU1JVF9TVEFDS19MRVZFTCA9IDMsXG4gIHdpbiA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LFxuICBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQsXG4gIGhpc3QgPSB3aW4gJiYgaGlzdG9yeSxcbiAgbG9jID0gd2luICYmIChoaXN0LmxvY2F0aW9uIHx8IHdpbi5sb2NhdGlvbiksIC8vIHNlZSBodG1sNS1oaXN0b3J5LWFwaVxuICBwcm90ID0gUm91dGVyLnByb3RvdHlwZSwgLy8gdG8gbWluaWZ5IG1vcmVcbiAgY2xpY2tFdmVudCA9IGRvYyAmJiBkb2Mub250b3VjaHN0YXJ0ID8gJ3RvdWNoc3RhcnQnIDogJ2NsaWNrJyxcbiAgc3RhcnRlZCA9IGZhbHNlLFxuICBjZW50cmFsID0gcmlvdC5vYnNlcnZhYmxlKCksXG4gIHJvdXRlRm91bmQgPSBmYWxzZSxcbiAgZGVib3VuY2VkRW1pdCxcbiAgYmFzZSwgY3VycmVudCwgcGFyc2VyLCBzZWNvbmRQYXJzZXIsIGVtaXRTdGFjayA9IFtdLCBlbWl0U3RhY2tMZXZlbCA9IDBcblxuLyoqXG4gKiBEZWZhdWx0IHBhcnNlci4gWW91IGNhbiByZXBsYWNlIGl0IHZpYSByb3V0ZXIucGFyc2VyIG1ldGhvZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gY3VycmVudCBwYXRoIChub3JtYWxpemVkKVxuICogQHJldHVybnMge2FycmF5fSBhcnJheVxuICovXG5mdW5jdGlvbiBERUZBVUxUX1BBUlNFUihwYXRoKSB7XG4gIHJldHVybiBwYXRoLnNwbGl0KC9bLz8jXS8pXG59XG5cbi8qKlxuICogRGVmYXVsdCBwYXJzZXIgKHNlY29uZCkuIFlvdSBjYW4gcmVwbGFjZSBpdCB2aWEgcm91dGVyLnBhcnNlciBtZXRob2QuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIGN1cnJlbnQgcGF0aCAobm9ybWFsaXplZClcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWx0ZXIgLSBmaWx0ZXIgc3RyaW5nIChub3JtYWxpemVkKVxuICogQHJldHVybnMge2FycmF5fSBhcnJheVxuICovXG5mdW5jdGlvbiBERUZBVUxUX1NFQ09ORF9QQVJTRVIocGF0aCwgZmlsdGVyKSB7XG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJ14nICsgZmlsdGVyW1JFUExBQ0VdKC9cXCovZywgJyhbXi8/I10rPyknKVtSRVBMQUNFXSgvXFwuXFwuLywgJy4qJykgKyAnJCcpLFxuICAgIGFyZ3MgPSBwYXRoLm1hdGNoKHJlKVxuXG4gIGlmIChhcmdzKSByZXR1cm4gYXJncy5zbGljZSgxKVxufVxuXG4vKipcbiAqIFNpbXBsZS9jaGVhcCBkZWJvdW5jZSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtICAge2Z1bmN0aW9ufSBmbiAtIGNhbGxiYWNrXG4gKiBAcGFyYW0gICB7bnVtYmVyfSBkZWxheSAtIGRlbGF5IGluIHNlY29uZHNcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gZGVib3VuY2VkIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBkZWxheSkge1xuICB2YXIgdFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0KVxuICAgIHQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSlcbiAgfVxufVxuXG4vKipcbiAqIFNldCB0aGUgd2luZG93IGxpc3RlbmVycyB0byB0cmlnZ2VyIHRoZSByb3V0ZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b0V4ZWMgLSBzZWUgcm91dGUuc3RhcnRcbiAqL1xuZnVuY3Rpb24gc3RhcnQoYXV0b0V4ZWMpIHtcbiAgZGVib3VuY2VkRW1pdCA9IGRlYm91bmNlKGVtaXQsIDEpXG4gIHdpbltBRERfRVZFTlRfTElTVEVORVJdKFBPUFNUQVRFLCBkZWJvdW5jZWRFbWl0KVxuICB3aW5bQUREX0VWRU5UX0xJU1RFTkVSXShIQVNIQ0hBTkdFLCBkZWJvdW5jZWRFbWl0KVxuICBkb2NbQUREX0VWRU5UX0xJU1RFTkVSXShjbGlja0V2ZW50LCBjbGljaylcbiAgaWYgKGF1dG9FeGVjKSBlbWl0KHRydWUpXG59XG5cbi8qKlxuICogUm91dGVyIGNsYXNzXG4gKi9cbmZ1bmN0aW9uIFJvdXRlcigpIHtcbiAgdGhpcy4kID0gW11cbiAgcmlvdC5vYnNlcnZhYmxlKHRoaXMpIC8vIG1ha2UgaXQgb2JzZXJ2YWJsZVxuICBjZW50cmFsLm9uKCdzdG9wJywgdGhpcy5zLmJpbmQodGhpcykpXG4gIGNlbnRyYWwub24oJ2VtaXQnLCB0aGlzLmUuYmluZCh0aGlzKSlcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGhbUkVQTEFDRV0oL15cXC98XFwvJC8sICcnKVxufVxuXG5mdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT0gJ3N0cmluZydcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHBhcnQgYWZ0ZXIgZG9tYWluIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIC0gZnVsbHBhdGhcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHBhdGggZnJvbSByb290XG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhGcm9tUm9vdChocmVmKSB7XG4gIHJldHVybiAoaHJlZiB8fCBsb2MuaHJlZilbUkVQTEFDRV0oUkVfT1JJR0lOLCAnJylcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHBhcnQgYWZ0ZXIgYmFzZVxuICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgLSBmdWxscGF0aFxuICogQHJldHVybnMge3N0cmluZ30gcGF0aCBmcm9tIGJhc2VcbiAqL1xuZnVuY3Rpb24gZ2V0UGF0aEZyb21CYXNlKGhyZWYpIHtcbiAgcmV0dXJuIGJhc2VbMF0gPT0gJyMnXG4gICAgPyAoaHJlZiB8fCBsb2MuaHJlZiB8fCAnJykuc3BsaXQoYmFzZSlbMV0gfHwgJydcbiAgICA6IChsb2MgPyBnZXRQYXRoRnJvbVJvb3QoaHJlZikgOiBocmVmIHx8ICcnKVtSRVBMQUNFXShiYXNlLCAnJylcbn1cblxuZnVuY3Rpb24gZW1pdChmb3JjZSkge1xuICAvLyB0aGUgc3RhY2sgaXMgbmVlZGVkIGZvciByZWRpcmVjdGlvbnNcbiAgdmFyIGlzUm9vdCA9IGVtaXRTdGFja0xldmVsID09IDAsIGZpcnN0XG4gIGlmIChNQVhfRU1JVF9TVEFDS19MRVZFTCA8PSBlbWl0U3RhY2tMZXZlbCkgcmV0dXJuXG5cbiAgZW1pdFN0YWNrTGV2ZWwrK1xuICBlbWl0U3RhY2sucHVzaChmdW5jdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IGdldFBhdGhGcm9tQmFzZSgpXG4gICAgaWYgKGZvcmNlIHx8IHBhdGggIT0gY3VycmVudCkge1xuICAgICAgY2VudHJhbFtUUklHR0VSXSgnZW1pdCcsIHBhdGgpXG4gICAgICBjdXJyZW50ID0gcGF0aFxuICAgIH1cbiAgfSlcbiAgaWYgKGlzUm9vdCkge1xuICAgIHdoaWxlIChmaXJzdCA9IGVtaXRTdGFjay5zaGlmdCgpKSBmaXJzdCgpIC8vIHN0YWNrIGluY3Jlc2VzIHdpdGhpbiB0aGlzIGNhbGxcbiAgICBlbWl0U3RhY2tMZXZlbCA9IDBcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGljayhlKSB7XG4gIGlmIChcbiAgICBlLndoaWNoICE9IDEgLy8gbm90IGxlZnQgY2xpY2tcbiAgICB8fCBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkgLy8gb3IgbWV0YSBrZXlzXG4gICAgfHwgZS5kZWZhdWx0UHJldmVudGVkIC8vIG9yIGRlZmF1bHQgcHJldmVudGVkXG4gICkgcmV0dXJuXG5cbiAgdmFyIGVsID0gZS50YXJnZXRcbiAgd2hpbGUgKGVsICYmIGVsLm5vZGVOYW1lICE9ICdBJykgZWwgPSBlbC5wYXJlbnROb2RlXG5cbiAgaWYgKFxuICAgICFlbCB8fCBlbC5ub2RlTmFtZSAhPSAnQScgLy8gbm90IEEgdGFnXG4gICAgfHwgZWxbSEFTX0FUVFJJQlVURV0oJ2Rvd25sb2FkJykgLy8gaGFzIGRvd25sb2FkIGF0dHJcbiAgICB8fCAhZWxbSEFTX0FUVFJJQlVURV0oJ2hyZWYnKSAvLyBoYXMgbm8gaHJlZiBhdHRyXG4gICAgfHwgZWwudGFyZ2V0ICYmIGVsLnRhcmdldCAhPSAnX3NlbGYnIC8vIGFub3RoZXIgd2luZG93IG9yIGZyYW1lXG4gICAgfHwgZWwuaHJlZi5pbmRleE9mKGxvYy5ocmVmLm1hdGNoKFJFX09SSUdJTilbMF0pID09IC0xIC8vIGNyb3NzIG9yaWdpblxuICApIHJldHVyblxuXG4gIGlmIChlbC5ocmVmICE9IGxvYy5ocmVmXG4gICAgJiYgKFxuICAgICAgZWwuaHJlZi5zcGxpdCgnIycpWzBdID09IGxvYy5ocmVmLnNwbGl0KCcjJylbMF0gLy8gaW50ZXJuYWwganVtcFxuICAgICAgfHwgYmFzZVswXSAhPSAnIycgJiYgZ2V0UGF0aEZyb21Sb290KGVsLmhyZWYpLmluZGV4T2YoYmFzZSkgIT09IDAgLy8gb3V0c2lkZSBvZiBiYXNlXG4gICAgICB8fCBiYXNlWzBdID09ICcjJyAmJiBlbC5ocmVmLnNwbGl0KGJhc2UpWzBdICE9IGxvYy5ocmVmLnNwbGl0KGJhc2UpWzBdIC8vIG91dHNpZGUgb2YgI2Jhc2VcbiAgICAgIHx8ICFnbyhnZXRQYXRoRnJvbUJhc2UoZWwuaHJlZiksIGVsLnRpdGxlIHx8IGRvYy50aXRsZSkgLy8gcm91dGUgbm90IGZvdW5kXG4gICAgKSkgcmV0dXJuXG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG59XG5cbi8qKlxuICogR28gdG8gdGhlIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gZGVzdGluYXRpb24gcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlIC0gcGFnZSB0aXRsZVxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXBsYWNlIC0gdXNlIHJlcGxhY2VTdGF0ZSBvciBwdXNoU3RhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHJvdXRlIG5vdCBmb3VuZCBmbGFnXG4gKi9cbmZ1bmN0aW9uIGdvKHBhdGgsIHRpdGxlLCBzaG91bGRSZXBsYWNlKSB7XG4gIC8vIFNlcnZlci1zaWRlIHVzYWdlOiBkaXJlY3RseSBleGVjdXRlIGhhbmRsZXJzIGZvciB0aGUgcGF0aFxuICBpZiAoIWhpc3QpIHJldHVybiBjZW50cmFsW1RSSUdHRVJdKCdlbWl0JywgZ2V0UGF0aEZyb21CYXNlKHBhdGgpKVxuXG4gIHBhdGggPSBiYXNlICsgbm9ybWFsaXplKHBhdGgpXG4gIHRpdGxlID0gdGl0bGUgfHwgZG9jLnRpdGxlXG4gIC8vIGJyb3dzZXJzIGlnbm9yZXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgYHRpdGxlYFxuICBzaG91bGRSZXBsYWNlXG4gICAgPyBoaXN0LnJlcGxhY2VTdGF0ZShudWxsLCB0aXRsZSwgcGF0aClcbiAgICA6IGhpc3QucHVzaFN0YXRlKG51bGwsIHRpdGxlLCBwYXRoKVxuICAvLyBzbyB3ZSBuZWVkIHRvIHNldCBpdCBtYW51YWxseVxuICBkb2MudGl0bGUgPSB0aXRsZVxuICByb3V0ZUZvdW5kID0gZmFsc2VcbiAgZW1pdCgpXG4gIHJldHVybiByb3V0ZUZvdW5kXG59XG5cbi8qKlxuICogR28gdG8gcGF0aCBvciBzZXQgYWN0aW9uXG4gKiBhIHNpbmdsZSBzdHJpbmc6ICAgICAgICAgICAgICAgIGdvIHRoZXJlXG4gKiB0d28gc3RyaW5nczogICAgICAgICAgICAgICAgICAgIGdvIHRoZXJlIHdpdGggc2V0dGluZyBhIHRpdGxlXG4gKiB0d28gc3RyaW5ncyBhbmQgYm9vbGVhbjogICAgICAgIHJlcGxhY2UgaGlzdG9yeSB3aXRoIHNldHRpbmcgYSB0aXRsZVxuICogYSBzaW5nbGUgZnVuY3Rpb246ICAgICAgICAgICAgICBzZXQgYW4gYWN0aW9uIG9uIHRoZSBkZWZhdWx0IHJvdXRlXG4gKiBhIHN0cmluZy9SZWdFeHAgYW5kIGEgZnVuY3Rpb246IHNldCBhbiBhY3Rpb24gb24gdGhlIHJvdXRlXG4gKiBAcGFyYW0geyhzdHJpbmd8ZnVuY3Rpb24pfSBmaXJzdCAtIHBhdGggLyBhY3Rpb24gLyBmaWx0ZXJcbiAqIEBwYXJhbSB7KHN0cmluZ3xSZWdFeHB8ZnVuY3Rpb24pfSBzZWNvbmQgLSB0aXRsZSAvIGFjdGlvblxuICogQHBhcmFtIHtib29sZWFufSB0aGlyZCAtIHJlcGxhY2UgZmxhZ1xuICovXG5wcm90Lm0gPSBmdW5jdGlvbihmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICBpZiAoaXNTdHJpbmcoZmlyc3QpICYmICghc2Vjb25kIHx8IGlzU3RyaW5nKHNlY29uZCkpKSBnbyhmaXJzdCwgc2Vjb25kLCB0aGlyZCB8fCBmYWxzZSlcbiAgZWxzZSBpZiAoc2Vjb25kKSB0aGlzLnIoZmlyc3QsIHNlY29uZClcbiAgZWxzZSB0aGlzLnIoJ0AnLCBmaXJzdClcbn1cblxuLyoqXG4gKiBTdG9wIHJvdXRpbmdcbiAqL1xucHJvdC5zID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMub2ZmKCcqJylcbiAgdGhpcy4kID0gW11cbn1cblxuLyoqXG4gKiBFbWl0XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHBhdGhcbiAqL1xucHJvdC5lID0gZnVuY3Rpb24ocGF0aCkge1xuICB0aGlzLiQuY29uY2F0KCdAJykuc29tZShmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgYXJncyA9IChmaWx0ZXIgPT0gJ0AnID8gcGFyc2VyIDogc2Vjb25kUGFyc2VyKShub3JtYWxpemUocGF0aCksIG5vcm1hbGl6ZShmaWx0ZXIpKVxuICAgIGlmICh0eXBlb2YgYXJncyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1tUUklHR0VSXS5hcHBseShudWxsLCBbZmlsdGVyXS5jb25jYXQoYXJncykpXG4gICAgICByZXR1cm4gcm91dGVGb3VuZCA9IHRydWUgLy8gZXhpdCBmcm9tIGxvb3BcbiAgICB9XG4gIH0sIHRoaXMpXG59XG5cbi8qKlxuICogUmVnaXN0ZXIgcm91dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWx0ZXIgLSBmaWx0ZXIgZm9yIG1hdGNoaW5nIHRvIHVybFxuICogQHBhcmFtIHtmdW5jdGlvbn0gYWN0aW9uIC0gYWN0aW9uIHRvIHJlZ2lzdGVyXG4gKi9cbnByb3QuciA9IGZ1bmN0aW9uKGZpbHRlciwgYWN0aW9uKSB7XG4gIGlmIChmaWx0ZXIgIT0gJ0AnKSB7XG4gICAgZmlsdGVyID0gJy8nICsgbm9ybWFsaXplKGZpbHRlcilcbiAgICB0aGlzLiQucHVzaChmaWx0ZXIpXG4gIH1cbiAgdGhpcy5vbihmaWx0ZXIsIGFjdGlvbilcbn1cblxudmFyIG1haW5Sb3V0ZXIgPSBuZXcgUm91dGVyKClcbnZhciByb3V0ZSA9IG1haW5Sb3V0ZXIubS5iaW5kKG1haW5Sb3V0ZXIpXG5cbi8qKlxuICogQ3JlYXRlIGEgc3ViIHJvdXRlclxuICogQHJldHVybnMge2Z1bmN0aW9ufSB0aGUgbWV0aG9kIG9mIGEgbmV3IFJvdXRlciBvYmplY3RcbiAqL1xucm91dGUuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuZXdTdWJSb3V0ZXIgPSBuZXcgUm91dGVyKClcbiAgLy8gYXNzaWduIHN1Yi1yb3V0ZXIncyBtYWluIG1ldGhvZFxuICB2YXIgcm91dGVyID0gbmV3U3ViUm91dGVyLm0uYmluZChuZXdTdWJSb3V0ZXIpXG4gIC8vIHN0b3Agb25seSB0aGlzIHN1Yi1yb3V0ZXJcbiAgcm91dGVyLnN0b3AgPSBuZXdTdWJSb3V0ZXIucy5iaW5kKG5ld1N1YlJvdXRlcilcbiAgcmV0dXJuIHJvdXRlclxufVxuXG4vKipcbiAqIFNldCB0aGUgYmFzZSBvZiB1cmxcbiAqIEBwYXJhbSB7KHN0cnxSZWdFeHApfSBhcmcgLSBhIG5ldyBiYXNlIG9yICcjJyBvciAnIyEnXG4gKi9cbnJvdXRlLmJhc2UgPSBmdW5jdGlvbihhcmcpIHtcbiAgYmFzZSA9IGFyZyB8fCAnIydcbiAgY3VycmVudCA9IGdldFBhdGhGcm9tQmFzZSgpIC8vIHJlY2FsY3VsYXRlIGN1cnJlbnQgcGF0aFxufVxuXG4vKiogRXhlYyByb3V0aW5nIHJpZ2h0IG5vdyAqKi9cbnJvdXRlLmV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgZW1pdCh0cnVlKVxufVxuXG4vKipcbiAqIFJlcGxhY2UgdGhlIGRlZmF1bHQgcm91dGVyIHRvIHlvdXJzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIHlvdXIgcGFyc2VyIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbjIgLSB5b3VyIHNlY29uZFBhcnNlciBmdW5jdGlvblxuICovXG5yb3V0ZS5wYXJzZXIgPSBmdW5jdGlvbihmbiwgZm4yKSB7XG4gIGlmICghZm4gJiYgIWZuMikge1xuICAgIC8vIHJlc2V0IHBhcnNlciBmb3IgdGVzdGluZy4uLlxuICAgIHBhcnNlciA9IERFRkFVTFRfUEFSU0VSXG4gICAgc2Vjb25kUGFyc2VyID0gREVGQVVMVF9TRUNPTkRfUEFSU0VSXG4gIH1cbiAgaWYgKGZuKSBwYXJzZXIgPSBmblxuICBpZiAoZm4yKSBzZWNvbmRQYXJzZXIgPSBmbjJcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHVybCBxdWVyeSBhcyBhbiBvYmplY3RcbiAqIEByZXR1cm5zIHtvYmplY3R9IHBhcnNlZCBxdWVyeVxuICovXG5yb3V0ZS5xdWVyeSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcSA9IHt9XG4gIHZhciBocmVmID0gbG9jLmhyZWYgfHwgY3VycmVudFxuICBocmVmW1JFUExBQ0VdKC9bPyZdKC4rPyk9KFteJl0qKS9nLCBmdW5jdGlvbihfLCBrLCB2KSB7IHFba10gPSB2IH0pXG4gIHJldHVybiBxXG59XG5cbi8qKiBTdG9wIHJvdXRpbmcgKiovXG5yb3V0ZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoc3RhcnRlZCkge1xuICAgIGlmICh3aW4pIHtcbiAgICAgIHdpbltSRU1PVkVfRVZFTlRfTElTVEVORVJdKFBPUFNUQVRFLCBkZWJvdW5jZWRFbWl0KVxuICAgICAgd2luW1JFTU9WRV9FVkVOVF9MSVNURU5FUl0oSEFTSENIQU5HRSwgZGVib3VuY2VkRW1pdClcbiAgICAgIGRvY1tSRU1PVkVfRVZFTlRfTElTVEVORVJdKGNsaWNrRXZlbnQsIGNsaWNrKVxuICAgIH1cbiAgICBjZW50cmFsW1RSSUdHRVJdKCdzdG9wJylcbiAgICBzdGFydGVkID0gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFN0YXJ0IHJvdXRpbmdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b0V4ZWMgLSBhdXRvbWF0aWNhbGx5IGV4ZWMgYWZ0ZXIgc3RhcnRpbmcgaWYgdHJ1ZVxuICovXG5yb3V0ZS5zdGFydCA9IGZ1bmN0aW9uIChhdXRvRXhlYykge1xuICBpZiAoIXN0YXJ0ZWQpIHtcbiAgICBpZiAod2luKSB7XG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSBzdGFydChhdXRvRXhlYylcbiAgICAgIC8vIHRoZSB0aW1lb3V0IGlzIG5lZWRlZCB0byBzb2x2ZVxuICAgICAgLy8gYSB3ZWlyZCBzYWZhcmkgYnVnIGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3JvdXRlL2lzc3Vlcy8zM1xuICAgICAgZWxzZSB3aW5bQUREX0VWRU5UX0xJU1RFTkVSXSgnbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzdGFydChhdXRvRXhlYykgfSwgMSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHN0YXJ0ZWQgPSB0cnVlXG4gIH1cbn1cblxuLyoqIFByZXBhcmUgdGhlIHJvdXRlciAqKi9cbnJvdXRlLmJhc2UoKVxucm91dGUucGFyc2VyKClcblxucmlvdC5yb3V0ZSA9IHJvdXRlXG59KShyaW90KVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuLyoqXG4gKiBUaGUgcmlvdCB0ZW1wbGF0ZSBlbmdpbmVcbiAqIEB2ZXJzaW9uIHYyLjQuMlxuICovXG4vKipcbiAqIHJpb3QudXRpbC5icmFja2V0c1xuICpcbiAqIC0gYGJyYWNrZXRzICAgIGAgLSBSZXR1cm5zIGEgc3RyaW5nIG9yIHJlZ2V4IGJhc2VkIG9uIGl0cyBwYXJhbWV0ZXJcbiAqIC0gYGJyYWNrZXRzLnNldGAgLSBDaGFuZ2UgdGhlIGN1cnJlbnQgcmlvdCBicmFja2V0c1xuICpcbiAqIEBtb2R1bGVcbiAqL1xuXG52YXIgYnJhY2tldHMgPSAoZnVuY3Rpb24gKFVOREVGKSB7XG5cbiAgdmFyXG4gICAgUkVHTE9CID0gJ2cnLFxuXG4gICAgUl9NTENPTU1TID0gL1xcL1xcKlteKl0qXFwqKyg/OlteKlxcL11bXipdKlxcKispKlxcLy9nLFxuXG4gICAgUl9TVFJJTkdTID0gL1wiW15cIlxcXFxdKig/OlxcXFxbXFxTXFxzXVteXCJcXFxcXSopKlwifCdbXidcXFxcXSooPzpcXFxcW1xcU1xcc11bXidcXFxcXSopKicvZyxcblxuICAgIFNfUUJMT0NLUyA9IFJfU1RSSU5HUy5zb3VyY2UgKyAnfCcgK1xuICAgICAgLyg/OlxcYnJldHVyblxccyt8KD86WyRcXHdcXClcXF1dfFxcK1xcK3wtLSlcXHMqKFxcLykoPyFbKlxcL10pKS8uc291cmNlICsgJ3wnICtcbiAgICAgIC9cXC8oPz1bXipcXC9dKVteW1xcL1xcXFxdKig/Oig/OlxcWyg/OlxcXFwufFteXFxdXFxcXF0qKSpcXF18XFxcXC4pW15bXFwvXFxcXF0qKSo/KFxcLylbZ2ltXSovLnNvdXJjZSxcblxuICAgIFVOU1VQUE9SVEVEID0gUmVnRXhwKCdbXFxcXCcgKyAneDAwLVxcXFx4MUY8PmEtekEtWjAtOVxcJ1wiLDtcXFxcXFxcXF0nKSxcblxuICAgIE5FRURfRVNDQVBFID0gLyg/PVtbXFxdKCkqKz8uXiR8XSkvZyxcblxuICAgIEZJTkRCUkFDRVMgPSB7XG4gICAgICAnKCc6IFJlZ0V4cCgnKFsoKV0pfCcgICArIFNfUUJMT0NLUywgUkVHTE9CKSxcbiAgICAgICdbJzogUmVnRXhwKCcoW1tcXFxcXV0pfCcgKyBTX1FCTE9DS1MsIFJFR0xPQiksXG4gICAgICAneyc6IFJlZ0V4cCgnKFt7fV0pfCcgICArIFNfUUJMT0NLUywgUkVHTE9CKVxuICAgIH0sXG5cbiAgICBERUZBVUxUID0gJ3sgfSdcblxuICB2YXIgX3BhaXJzID0gW1xuICAgICd7JywgJ30nLFxuICAgICd7JywgJ30nLFxuICAgIC97W159XSp9LyxcbiAgICAvXFxcXChbe31dKS9nLFxuICAgIC9cXFxcKHspfHsvZyxcbiAgICBSZWdFeHAoJ1xcXFxcXFxcKH0pfChbWyh7XSl8KH0pfCcgKyBTX1FCTE9DS1MsIFJFR0xPQiksXG4gICAgREVGQVVMVCxcbiAgICAvXlxccyp7XFxeP1xccyooWyRcXHddKykoPzpcXHMqLFxccyooXFxTKykpP1xccytpblxccysoXFxTLiopXFxzKn0vLFxuICAgIC8oXnxbXlxcXFxdKXs9W1xcU1xcc10qP30vXG4gIF1cblxuICB2YXJcbiAgICBjYWNoZWRCcmFja2V0cyA9IFVOREVGLFxuICAgIF9yZWdleCxcbiAgICBfY2FjaGUgPSBbXSxcbiAgICBfc2V0dGluZ3NcblxuICBmdW5jdGlvbiBfbG9vcGJhY2sgKHJlKSB7IHJldHVybiByZSB9XG5cbiAgZnVuY3Rpb24gX3Jld3JpdGUgKHJlLCBicCkge1xuICAgIGlmICghYnApIGJwID0gX2NhY2hlXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXG4gICAgICByZS5zb3VyY2UucmVwbGFjZSgvey9nLCBicFsyXSkucmVwbGFjZSgvfS9nLCBicFszXSksIHJlLmdsb2JhbCA/IFJFR0xPQiA6ICcnXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZSAocGFpcikge1xuICAgIGlmIChwYWlyID09PSBERUZBVUxUKSByZXR1cm4gX3BhaXJzXG5cbiAgICB2YXIgYXJyID0gcGFpci5zcGxpdCgnICcpXG5cbiAgICBpZiAoYXJyLmxlbmd0aCAhPT0gMiB8fCBVTlNVUFBPUlRFRC50ZXN0KHBhaXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGJyYWNrZXRzIFwiJyArIHBhaXIgKyAnXCInKVxuICAgIH1cbiAgICBhcnIgPSBhcnIuY29uY2F0KHBhaXIucmVwbGFjZShORUVEX0VTQ0FQRSwgJ1xcXFwnKS5zcGxpdCgnICcpKVxuXG4gICAgYXJyWzRdID0gX3Jld3JpdGUoYXJyWzFdLmxlbmd0aCA+IDEgPyAve1tcXFNcXHNdKj99LyA6IF9wYWlyc1s0XSwgYXJyKVxuICAgIGFycls1XSA9IF9yZXdyaXRlKHBhaXIubGVuZ3RoID4gMyA/IC9cXFxcKHt8fSkvZyA6IF9wYWlyc1s1XSwgYXJyKVxuICAgIGFycls2XSA9IF9yZXdyaXRlKF9wYWlyc1s2XSwgYXJyKVxuICAgIGFycls3XSA9IFJlZ0V4cCgnXFxcXFxcXFwoJyArIGFyclszXSArICcpfChbWyh7XSl8KCcgKyBhcnJbM10gKyAnKXwnICsgU19RQkxPQ0tTLCBSRUdMT0IpXG4gICAgYXJyWzhdID0gcGFpclxuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIGZ1bmN0aW9uIF9icmFja2V0cyAocmVPcklkeCkge1xuICAgIHJldHVybiByZU9ySWR4IGluc3RhbmNlb2YgUmVnRXhwID8gX3JlZ2V4KHJlT3JJZHgpIDogX2NhY2hlW3JlT3JJZHhdXG4gIH1cblxuICBfYnJhY2tldHMuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoc3RyLCB0bXBsLCBfYnApIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogX2JwIGlzIGZvciB0aGUgY29tcGlsZXJcbiAgICBpZiAoIV9icCkgX2JwID0gX2NhY2hlXG5cbiAgICB2YXJcbiAgICAgIHBhcnRzID0gW10sXG4gICAgICBtYXRjaCxcbiAgICAgIGlzZXhwcixcbiAgICAgIHN0YXJ0LFxuICAgICAgcG9zLFxuICAgICAgcmUgPSBfYnBbNl1cblxuICAgIGlzZXhwciA9IHN0YXJ0ID0gcmUubGFzdEluZGV4ID0gMFxuXG4gICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoc3RyKSkpIHtcblxuICAgICAgcG9zID0gbWF0Y2guaW5kZXhcblxuICAgICAgaWYgKGlzZXhwcikge1xuXG4gICAgICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgIHJlLmxhc3RJbmRleCA9IHNraXBCcmFjZXMoc3RyLCBtYXRjaFsyXSwgcmUubGFzdEluZGV4KVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRjaFszXSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXRjaFsxXSkge1xuICAgICAgICB1bmVzY2FwZVN0cihzdHIuc2xpY2Uoc3RhcnQsIHBvcykpXG4gICAgICAgIHN0YXJ0ID0gcmUubGFzdEluZGV4XG4gICAgICAgIHJlID0gX2JwWzYgKyAoaXNleHByIF49IDEpXVxuICAgICAgICByZS5sYXN0SW5kZXggPSBzdGFydFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHIgJiYgc3RhcnQgPCBzdHIubGVuZ3RoKSB7XG4gICAgICB1bmVzY2FwZVN0cihzdHIuc2xpY2Uoc3RhcnQpKVxuICAgIH1cblxuICAgIHJldHVybiBwYXJ0c1xuXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVTdHIgKHMpIHtcbiAgICAgIGlmICh0bXBsIHx8IGlzZXhwcikge1xuICAgICAgICBwYXJ0cy5wdXNoKHMgJiYgcy5yZXBsYWNlKF9icFs1XSwgJyQxJykpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5wdXNoKHMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tpcEJyYWNlcyAocywgY2gsIGl4KSB7XG4gICAgICB2YXJcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHJlY2NoID0gRklOREJSQUNFU1tjaF1cblxuICAgICAgcmVjY2gubGFzdEluZGV4ID0gaXhcbiAgICAgIGl4ID0gMVxuICAgICAgd2hpbGUgKChtYXRjaCA9IHJlY2NoLmV4ZWMocykpKSB7XG4gICAgICAgIGlmIChtYXRjaFsxXSAmJlxuICAgICAgICAgICEobWF0Y2hbMV0gPT09IGNoID8gKytpeCA6IC0taXgpKSBicmVha1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl4ID8gcy5sZW5ndGggOiByZWNjaC5sYXN0SW5kZXhcbiAgICB9XG4gIH1cblxuICBfYnJhY2tldHMuaGFzRXhwciA9IGZ1bmN0aW9uIGhhc0V4cHIgKHN0cikge1xuICAgIHJldHVybiBfY2FjaGVbNF0udGVzdChzdHIpXG4gIH1cblxuICBfYnJhY2tldHMubG9vcEtleXMgPSBmdW5jdGlvbiBsb29wS2V5cyAoZXhwcikge1xuICAgIHZhciBtID0gZXhwci5tYXRjaChfY2FjaGVbOV0pXG5cbiAgICByZXR1cm4gbVxuICAgICAgPyB7IGtleTogbVsxXSwgcG9zOiBtWzJdLCB2YWw6IF9jYWNoZVswXSArIG1bM10udHJpbSgpICsgX2NhY2hlWzFdIH1cbiAgICAgIDogeyB2YWw6IGV4cHIudHJpbSgpIH1cbiAgfVxuXG4gIF9icmFja2V0cy5hcnJheSA9IGZ1bmN0aW9uIGFycmF5IChwYWlyKSB7XG4gICAgcmV0dXJuIHBhaXIgPyBfY3JlYXRlKHBhaXIpIDogX2NhY2hlXG4gIH1cblxuICBmdW5jdGlvbiBfcmVzZXQgKHBhaXIpIHtcbiAgICBpZiAoKHBhaXIgfHwgKHBhaXIgPSBERUZBVUxUKSkgIT09IF9jYWNoZVs4XSkge1xuICAgICAgX2NhY2hlID0gX2NyZWF0ZShwYWlyKVxuICAgICAgX3JlZ2V4ID0gcGFpciA9PT0gREVGQVVMVCA/IF9sb29wYmFjayA6IF9yZXdyaXRlXG4gICAgICBfY2FjaGVbOV0gPSBfcmVnZXgoX3BhaXJzWzldKVxuICAgIH1cbiAgICBjYWNoZWRCcmFja2V0cyA9IHBhaXJcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZXRTZXR0aW5ncyAobykge1xuICAgIHZhciBiXG5cbiAgICBvID0gbyB8fCB7fVxuICAgIGIgPSBvLmJyYWNrZXRzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICdicmFja2V0cycsIHtcbiAgICAgIHNldDogX3Jlc2V0LFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZWRCcmFja2V0cyB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pXG4gICAgX3NldHRpbmdzID0gb1xuICAgIF9yZXNldChiKVxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9icmFja2V0cywgJ3NldHRpbmdzJywge1xuICAgIHNldDogX3NldFNldHRpbmdzLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3NldHRpbmdzIH1cbiAgfSlcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaW4gdGhlIGJyb3dzZXIgcmlvdCBpcyBhbHdheXMgaW4gdGhlIHNjb3BlICovXG4gIF9icmFja2V0cy5zZXR0aW5ncyA9IHR5cGVvZiByaW90ICE9PSAndW5kZWZpbmVkJyAmJiByaW90LnNldHRpbmdzIHx8IHt9XG4gIF9icmFja2V0cy5zZXQgPSBfcmVzZXRcblxuICBfYnJhY2tldHMuUl9TVFJJTkdTID0gUl9TVFJJTkdTXG4gIF9icmFja2V0cy5SX01MQ09NTVMgPSBSX01MQ09NTVNcbiAgX2JyYWNrZXRzLlNfUUJMT0NLUyA9IFNfUUJMT0NLU1xuXG4gIHJldHVybiBfYnJhY2tldHNcblxufSkoKVxuXG4vKipcbiAqIEBtb2R1bGUgdG1wbFxuICpcbiAqIHRtcGwgICAgICAgICAgLSBSb290IGZ1bmN0aW9uLCByZXR1cm5zIHRoZSB0ZW1wbGF0ZSB2YWx1ZSwgcmVuZGVyIHdpdGggZGF0YVxuICogdG1wbC5oYXNFeHByICAtIFRlc3QgdGhlIGV4aXN0ZW5jZSBvZiBhIGV4cHJlc3Npb24gaW5zaWRlIGEgc3RyaW5nXG4gKiB0bXBsLmxvb3BLZXlzIC0gR2V0IHRoZSBrZXlzIGZvciBhbiAnZWFjaCcgbG9vcCAodXNlZCBieSBgX2VhY2hgKVxuICovXG5cbnZhciB0bXBsID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgX2NhY2hlID0ge31cblxuICBmdW5jdGlvbiBfdG1wbCAoc3RyLCBkYXRhKSB7XG4gICAgaWYgKCFzdHIpIHJldHVybiBzdHJcblxuICAgIHJldHVybiAoX2NhY2hlW3N0cl0gfHwgKF9jYWNoZVtzdHJdID0gX2NyZWF0ZShzdHIpKSkuY2FsbChkYXRhLCBfbG9nRXJyKVxuICB9XG5cbiAgX3RtcGwuaGF2ZVJhdyA9IGJyYWNrZXRzLmhhc1Jhd1xuXG4gIF90bXBsLmhhc0V4cHIgPSBicmFja2V0cy5oYXNFeHByXG5cbiAgX3RtcGwubG9vcEtleXMgPSBicmFja2V0cy5sb29wS2V5c1xuXG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gIF90bXBsLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IF9jYWNoZSA9IHt9IH1cblxuICBfdG1wbC5lcnJvckhhbmRsZXIgPSBudWxsXG5cbiAgZnVuY3Rpb24gX2xvZ0VyciAoZXJyLCBjdHgpIHtcblxuICAgIGlmIChfdG1wbC5lcnJvckhhbmRsZXIpIHtcblxuICAgICAgZXJyLnJpb3REYXRhID0ge1xuICAgICAgICB0YWdOYW1lOiBjdHggJiYgY3R4LnJvb3QgJiYgY3R4LnJvb3QudGFnTmFtZSxcbiAgICAgICAgX3Jpb3RfaWQ6IGN0eCAmJiBjdHguX3Jpb3RfaWQgIC8vZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIH1cbiAgICAgIF90bXBsLmVycm9ySGFuZGxlcihlcnIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZSAoc3RyKSB7XG4gICAgdmFyIGV4cHIgPSBfZ2V0VG1wbChzdHIpXG5cbiAgICBpZiAoZXhwci5zbGljZSgwLCAxMSkgIT09ICd0cnl7cmV0dXJuICcpIGV4cHIgPSAncmV0dXJuICcgKyBleHByXG5cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdFJywgZXhwciArICc7JykgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctZnVuY1xuICB9XG5cbiAgdmFyXG4gICAgQ0hfSURFWFBSID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDIwNTcpLFxuICAgIFJFX0NTTkFNRSA9IC9eKD86KC0/W19BLVphLXpcXHhBMC1cXHhGRl1bLVxcd1xceEEwLVxceEZGXSopfFxcdTIwNTcoXFxkKyl+KTovLFxuICAgIFJFX1FCTE9DSyA9IFJlZ0V4cChicmFja2V0cy5TX1FCTE9DS1MsICdnJyksXG4gICAgUkVfRFFVT1RFID0gL1xcdTIwNTcvZyxcbiAgICBSRV9RQk1BUksgPSAvXFx1MjA1NyhcXGQrKX4vZ1xuXG4gIGZ1bmN0aW9uIF9nZXRUbXBsIChzdHIpIHtcbiAgICB2YXJcbiAgICAgIHFzdHIgPSBbXSxcbiAgICAgIGV4cHIsXG4gICAgICBwYXJ0cyA9IGJyYWNrZXRzLnNwbGl0KHN0ci5yZXBsYWNlKFJFX0RRVU9URSwgJ1wiJyksIDEpXG5cbiAgICBpZiAocGFydHMubGVuZ3RoID4gMiB8fCBwYXJ0c1swXSkge1xuICAgICAgdmFyIGksIGosIGxpc3QgPSBbXVxuXG4gICAgICBmb3IgKGkgPSBqID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgZXhwciA9IHBhcnRzW2ldXG5cbiAgICAgICAgaWYgKGV4cHIgJiYgKGV4cHIgPSBpICYgMVxuXG4gICAgICAgICAgICA/IF9wYXJzZUV4cHIoZXhwciwgMSwgcXN0cilcblxuICAgICAgICAgICAgOiAnXCInICsgZXhwclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcclxcbj98XFxuL2csICdcXFxcbicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArXG4gICAgICAgICAgICAgICdcIidcblxuICAgICAgICAgICkpIGxpc3RbaisrXSA9IGV4cHJcblxuICAgICAgfVxuXG4gICAgICBleHByID0gaiA8IDIgPyBsaXN0WzBdXG4gICAgICAgICAgIDogJ1snICsgbGlzdC5qb2luKCcsJykgKyAnXS5qb2luKFwiXCIpJ1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgZXhwciA9IF9wYXJzZUV4cHIocGFydHNbMV0sIDAsIHFzdHIpXG4gICAgfVxuXG4gICAgaWYgKHFzdHJbMF0pIHtcbiAgICAgIGV4cHIgPSBleHByLnJlcGxhY2UoUkVfUUJNQVJLLCBmdW5jdGlvbiAoXywgcG9zKSB7XG4gICAgICAgIHJldHVybiBxc3RyW3Bvc11cbiAgICAgICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcbiAgfVxuXG4gIHZhclxuICAgIFJFX0JSRU5EID0ge1xuICAgICAgJygnOiAvWygpXS9nLFxuICAgICAgJ1snOiAvW1tcXF1dL2csXG4gICAgICAneyc6IC9be31dL2dcbiAgICB9XG5cbiAgZnVuY3Rpb24gX3BhcnNlRXhwciAoZXhwciwgYXNUZXh0LCBxc3RyKSB7XG5cbiAgICBleHByID0gZXhwclxuICAgICAgICAgIC5yZXBsYWNlKFJFX1FCTE9DSywgZnVuY3Rpb24gKHMsIGRpdikge1xuICAgICAgICAgICAgcmV0dXJuIHMubGVuZ3RoID4gMiAmJiAhZGl2ID8gQ0hfSURFWFBSICsgKHFzdHIucHVzaChzKSAtIDEpICsgJ34nIDogc1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKClcbiAgICAgICAgICAucmVwbGFjZSgvXFwgPyhbW1xcKHt9LD9cXC46XSlcXCA/L2csICckMScpXG5cbiAgICBpZiAoZXhwcikge1xuICAgICAgdmFyXG4gICAgICAgIGxpc3QgPSBbXSxcbiAgICAgICAgY250ID0gMCxcbiAgICAgICAgbWF0Y2hcblxuICAgICAgd2hpbGUgKGV4cHIgJiZcbiAgICAgICAgICAgIChtYXRjaCA9IGV4cHIubWF0Y2goUkVfQ1NOQU1FKSkgJiZcbiAgICAgICAgICAgICFtYXRjaC5pbmRleFxuICAgICAgICApIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGpzYixcbiAgICAgICAgICByZSA9IC8sfChbW3soXSl8JC9nXG5cbiAgICAgICAgZXhwciA9IFJlZ0V4cC5yaWdodENvbnRleHRcbiAgICAgICAga2V5ICA9IG1hdGNoWzJdID8gcXN0clttYXRjaFsyXV0uc2xpY2UoMSwgLTEpLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykgOiBtYXRjaFsxXVxuXG4gICAgICAgIHdoaWxlIChqc2IgPSAobWF0Y2ggPSByZS5leGVjKGV4cHIpKVsxXSkgc2tpcEJyYWNlcyhqc2IsIHJlKVxuXG4gICAgICAgIGpzYiAgPSBleHByLnNsaWNlKDAsIG1hdGNoLmluZGV4KVxuICAgICAgICBleHByID0gUmVnRXhwLnJpZ2h0Q29udGV4dFxuXG4gICAgICAgIGxpc3RbY250KytdID0gX3dyYXBFeHByKGpzYiwgMSwga2V5KVxuICAgICAgfVxuXG4gICAgICBleHByID0gIWNudCA/IF93cmFwRXhwcihleHByLCBhc1RleHQpXG4gICAgICAgICAgIDogY250ID4gMSA/ICdbJyArIGxpc3Quam9pbignLCcpICsgJ10uam9pbihcIiBcIikudHJpbSgpJyA6IGxpc3RbMF1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcblxuICAgIGZ1bmN0aW9uIHNraXBCcmFjZXMgKGNoLCByZSkge1xuICAgICAgdmFyXG4gICAgICAgIG1tLFxuICAgICAgICBsdiA9IDEsXG4gICAgICAgIGlyID0gUkVfQlJFTkRbY2hdXG5cbiAgICAgIGlyLmxhc3RJbmRleCA9IHJlLmxhc3RJbmRleFxuICAgICAgd2hpbGUgKG1tID0gaXIuZXhlYyhleHByKSkge1xuICAgICAgICBpZiAobW1bMF0gPT09IGNoKSArK2x2XG4gICAgICAgIGVsc2UgaWYgKCEtLWx2KSBicmVha1xuICAgICAgfVxuICAgICAgcmUubGFzdEluZGV4ID0gbHYgPyBleHByLmxlbmd0aCA6IGlyLmxhc3RJbmRleFxuICAgIH1cbiAgfVxuXG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub3QgYm90aFxuICB2YXIgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICBKU19DT05URVhUID0gJ1wiaW4gdGhpcz90aGlzOicgKyAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgPyAnZ2xvYmFsJyA6ICd3aW5kb3cnKSArICcpLicsXG4gICAgSlNfVkFSTkFNRSA9IC9bLHtdW1xcJFxcd10rKD89Oil8KF4gKnxbXiRcXHdcXC57XSkoPyEoPzp0eXBlb2Z8dHJ1ZXxmYWxzZXxudWxsfHVuZGVmaW5lZHxpbnxpbnN0YW5jZW9mfGlzKD86RmluaXRlfE5hTil8dm9pZHxOYU58bmV3fERhdGV8UmVnRXhwfE1hdGgpKD8hWyRcXHddKSkoWyRfQS1aYS16XVskXFx3XSopL2csXG4gICAgSlNfTk9QUk9QUyA9IC9eKD89KFxcLlskXFx3XSspKVxcMSg/OlteLlsoXXwkKS9cblxuICBmdW5jdGlvbiBfd3JhcEV4cHIgKGV4cHIsIGFzVGV4dCwga2V5KSB7XG4gICAgdmFyIHRiXG5cbiAgICBleHByID0gZXhwci5yZXBsYWNlKEpTX1ZBUk5BTUUsIGZ1bmN0aW9uIChtYXRjaCwgcCwgbXZhciwgcG9zLCBzKSB7XG4gICAgICBpZiAobXZhcikge1xuICAgICAgICBwb3MgPSB0YiA/IDAgOiBwb3MgKyBtYXRjaC5sZW5ndGhcblxuICAgICAgICBpZiAobXZhciAhPT0gJ3RoaXMnICYmIG12YXIgIT09ICdnbG9iYWwnICYmIG12YXIgIT09ICd3aW5kb3cnKSB7XG4gICAgICAgICAgbWF0Y2ggPSBwICsgJyhcIicgKyBtdmFyICsgSlNfQ09OVEVYVCArIG12YXJcbiAgICAgICAgICBpZiAocG9zKSB0YiA9IChzID0gc1twb3NdKSA9PT0gJy4nIHx8IHMgPT09ICcoJyB8fCBzID09PSAnWydcbiAgICAgICAgfSBlbHNlIGlmIChwb3MpIHtcbiAgICAgICAgICB0YiA9ICFKU19OT1BST1BTLnRlc3Qocy5zbGljZShwb3MpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hcbiAgICB9KVxuXG4gICAgaWYgKHRiKSB7XG4gICAgICBleHByID0gJ3RyeXtyZXR1cm4gJyArIGV4cHIgKyAnfWNhdGNoKGUpe0UoZSx0aGlzKX0nXG4gICAgfVxuXG4gICAgaWYgKGtleSkge1xuXG4gICAgICBleHByID0gKHRiXG4gICAgICAgICAgPyAnZnVuY3Rpb24oKXsnICsgZXhwciArICd9LmNhbGwodGhpcyknIDogJygnICsgZXhwciArICcpJ1xuICAgICAgICApICsgJz9cIicgKyBrZXkgKyAnXCI6XCJcIidcblxuICAgIH0gZWxzZSBpZiAoYXNUZXh0KSB7XG5cbiAgICAgIGV4cHIgPSAnZnVuY3Rpb24odil7JyArICh0YlxuICAgICAgICAgID8gZXhwci5yZXBsYWNlKCdyZXR1cm4gJywgJ3Y9JykgOiAndj0oJyArIGV4cHIgKyAnKSdcbiAgICAgICAgKSArICc7cmV0dXJuIHZ8fHY9PT0wP3Y6XCJcIn0uY2FsbCh0aGlzKSdcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwclxuICB9XG5cbiAgX3RtcGwudmVyc2lvbiA9IGJyYWNrZXRzLnZlcnNpb24gPSAndjIuNC4yJ1xuXG4gIHJldHVybiBfdG1wbFxuXG59KSgpXG5cbi8qXG4gIGxpYi9icm93c2VyL3RhZy9ta2RvbS5qc1xuXG4gIEluY2x1ZGVzIGhhY2tzIG5lZWRlZCBmb3IgdGhlIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb24gOSBhbmQgYmVsb3dcbiAgU2VlOiBodHRwOi8va2FuZ2F4LmdpdGh1Yi5pby9jb21wYXQtdGFibGUvZXM1LyNpZThcbiAgICAgICBodHRwOi8vY29kZXBsYW5ldC5pby9kcm9wcGluZy1pZTgvXG4qL1xudmFyIG1rZG9tID0gKGZ1bmN0aW9uIF9ta2RvbSgpIHtcbiAgdmFyXG4gICAgcmVIYXNZaWVsZCAgPSAvPHlpZWxkXFxiL2ksXG4gICAgcmVZaWVsZEFsbCAgPSAvPHlpZWxkXFxzKig/OlxcLz58PihbXFxTXFxzXSo/KTxcXC95aWVsZFxccyo+fD4pL2lnLFxuICAgIHJlWWllbGRTcmMgID0gLzx5aWVsZFxccyt0bz1bJ1wiXShbXidcIj5dKilbJ1wiXVxccyo+KFtcXFNcXHNdKj8pPFxcL3lpZWxkXFxzKj4vaWcsXG4gICAgcmVZaWVsZERlc3QgPSAvPHlpZWxkXFxzK2Zyb209WydcIl0/KFstXFx3XSspWydcIl0/XFxzKig/OlxcLz58PihbXFxTXFxzXSo/KTxcXC95aWVsZFxccyo+KS9pZ1xuICB2YXJcbiAgICByb290RWxzID0geyB0cjogJ3Rib2R5JywgdGg6ICd0cicsIHRkOiAndHInLCBjb2w6ICdjb2xncm91cCcgfSxcbiAgICB0YmxUYWdzID0gSUVfVkVSU0lPTiAmJiBJRV9WRVJTSU9OIDwgMTBcbiAgICAgID8gU1BFQ0lBTF9UQUdTX1JFR0VYIDogL14oPzp0KD86Ym9keXxoZWFkfGZvb3R8W3JoZF0pfGNhcHRpb258Y29sKD86Z3JvdXApPykkL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRE9NIGVsZW1lbnQgdG8gd3JhcCB0aGUgZ2l2ZW4gY29udGVudC4gTm9ybWFsbHkgYW4gYERJVmAsIGJ1dCBjYW4gYmVcbiAgICogYWxzbyBhIGBUQUJMRWAsIGBTRUxFQ1RgLCBgVEJPRFlgLCBgVFJgLCBvciBgQ09MR1JPVVBgIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdGVtcGwgIC0gVGhlIHRlbXBsYXRlIGNvbWluZyBmcm9tIHRoZSBjdXN0b20gdGFnIGRlZmluaXRpb25cbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBbaHRtbF0gLSBIVE1MIGNvbnRlbnQgdGhhdCBjb21lcyBmcm9tIHRoZSBET00gZWxlbWVudCB3aGVyZSB5b3VcbiAgICogICAgICAgICAgIHdpbGwgbW91bnQgdGhlIHRhZywgbW9zdGx5IHRoZSBvcmlnaW5hbCB0YWcgaW4gdGhlIHBhZ2VcbiAgICogQHBhcmFtICAgeyBCb29sZWFuIH0gY2hlY2tTdmcgLSBmbGFnIG5lZWRlZCB0byBrbm93IGlmIHdlIG5lZWQgdG8gZm9yY2UgdGhlIHN2ZyByZW5kZXJpbmcgaW4gY2FzZSBvZiBsb29wIG5vZGVzXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gRE9NIGVsZW1lbnQgd2l0aCBfdGVtcGxfIG1lcmdlZCB0aHJvdWdoIGBZSUVMRGAgd2l0aCB0aGUgX2h0bWxfLlxuICAgKi9cbiAgZnVuY3Rpb24gX21rZG9tKHRlbXBsLCBodG1sLCBjaGVja1N2Zykge1xuICAgIHZhclxuICAgICAgbWF0Y2ggICA9IHRlbXBsICYmIHRlbXBsLm1hdGNoKC9eXFxzKjwoWy1cXHddKykvKSxcbiAgICAgIHRhZ05hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgZWwgPSBta0VsKCdkaXYnLCBjaGVja1N2ZyAmJiBpc1NWR1RhZyh0YWdOYW1lKSlcblxuICAgIC8vIHJlcGxhY2UgYWxsIHRoZSB5aWVsZCB0YWdzIHdpdGggdGhlIHRhZyBpbm5lciBodG1sXG4gICAgdGVtcGwgPSByZXBsYWNlWWllbGQodGVtcGwsIGh0bWwpXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0YmxUYWdzLnRlc3QodGFnTmFtZSkpXG4gICAgICBlbCA9IHNwZWNpYWxUYWdzKGVsLCB0ZW1wbCwgdGFnTmFtZSlcbiAgICBlbHNlXG4gICAgICBzZXRJbm5lckhUTUwoZWwsIHRlbXBsKVxuXG4gICAgZWwuc3R1YiA9IHRydWVcblxuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLypcbiAgICBDcmVhdGVzIHRoZSByb290IGVsZW1lbnQgZm9yIHRhYmxlIG9yIHNlbGVjdCBjaGlsZCBlbGVtZW50czpcbiAgICB0ci90aC90ZC90aGVhZC90Zm9vdC90Ym9keS9jYXB0aW9uL2NvbC9jb2xncm91cC9vcHRpb24vb3B0Z3JvdXBcbiAgKi9cbiAgZnVuY3Rpb24gc3BlY2lhbFRhZ3MoZWwsIHRlbXBsLCB0YWdOYW1lKSB7XG4gICAgdmFyXG4gICAgICBzZWxlY3QgPSB0YWdOYW1lWzBdID09PSAnbycsXG4gICAgICBwYXJlbnQgPSBzZWxlY3QgPyAnc2VsZWN0PicgOiAndGFibGU+J1xuXG4gICAgLy8gdHJpbSgpIGlzIGltcG9ydGFudCBoZXJlLCB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgaGF2ZSBhcnRpZmFjdHMsXG4gICAgLy8gc28gd2UgY2FuIGNoZWNrIGlmIHdlIGhhdmUgb25seSBvbmUgZWxlbWVudCBpbnNpZGUgdGhlIHBhcmVudFxuICAgIGVsLmlubmVySFRNTCA9ICc8JyArIHBhcmVudCArIHRlbXBsLnRyaW0oKSArICc8LycgKyBwYXJlbnRcbiAgICBwYXJlbnQgPSBlbC5maXJzdENoaWxkXG5cbiAgICAvLyByZXR1cm5zIHRoZSBpbW1lZGlhdGUgcGFyZW50IGlmIHRyL3RoL3RkL2NvbCBpcyB0aGUgb25seSBlbGVtZW50LCBpZiBub3RcbiAgICAvLyByZXR1cm5zIHRoZSB3aG9sZSB0cmVlLCBhcyB0aGlzIGNhbiBpbmNsdWRlIGFkZGl0aW9uYWwgZWxlbWVudHNcbiAgICBpZiAoc2VsZWN0KSB7XG4gICAgICBwYXJlbnQuc2VsZWN0ZWRJbmRleCA9IC0xICAvLyBmb3IgSUU5LCBjb21wYXRpYmxlIHcvY3VycmVudCByaW90IGJlaGF2aW9yXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF2b2lkcyBpbnNlcnRpb24gb2YgY29pbnRhaW5lciBpbnNpZGUgY29udGFpbmVyIChleDogdGJvZHkgaW5zaWRlIHRib2R5KVxuICAgICAgdmFyIHRuYW1lID0gcm9vdEVsc1t0YWdOYW1lXVxuICAgICAgaWYgKHRuYW1lICYmIHBhcmVudC5jaGlsZEVsZW1lbnRDb3VudCA9PT0gMSkgcGFyZW50ID0gJCh0bmFtZSwgcGFyZW50KVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50XG4gIH1cblxuICAvKlxuICAgIFJlcGxhY2UgdGhlIHlpZWxkIHRhZyBmcm9tIGFueSB0YWcgdGVtcGxhdGUgd2l0aCB0aGUgaW5uZXJIVE1MIG9mIHRoZVxuICAgIG9yaWdpbmFsIHRhZyBpbiB0aGUgcGFnZVxuICAqL1xuICBmdW5jdGlvbiByZXBsYWNlWWllbGQodGVtcGwsIGh0bWwpIHtcbiAgICAvLyBkbyBub3RoaW5nIGlmIG5vIHlpZWxkXG4gICAgaWYgKCFyZUhhc1lpZWxkLnRlc3QodGVtcGwpKSByZXR1cm4gdGVtcGxcblxuICAgIC8vIGJlIGNhcmVmdWwgd2l0aCAjMTM0MyAtIHN0cmluZyBvbiB0aGUgc291cmNlIGhhdmluZyBgJDFgXG4gICAgdmFyIHNyYyA9IHt9XG5cbiAgICBodG1sID0gaHRtbCAmJiBodG1sLnJlcGxhY2UocmVZaWVsZFNyYywgZnVuY3Rpb24gKF8sIHJlZiwgdGV4dCkge1xuICAgICAgc3JjW3JlZl0gPSBzcmNbcmVmXSB8fCB0ZXh0ICAgLy8gcHJlc2VydmUgZmlyc3QgZGVmaW5pdGlvblxuICAgICAgcmV0dXJuICcnXG4gICAgfSkudHJpbSgpXG5cbiAgICByZXR1cm4gdGVtcGxcbiAgICAgIC5yZXBsYWNlKHJlWWllbGREZXN0LCBmdW5jdGlvbiAoXywgcmVmLCBkZWYpIHsgIC8vIHlpZWxkIHdpdGggZnJvbSAtIHRvIGF0dHJzXG4gICAgICAgIHJldHVybiBzcmNbcmVmXSB8fCBkZWYgfHwgJydcbiAgICAgIH0pXG4gICAgICAucmVwbGFjZShyZVlpZWxkQWxsLCBmdW5jdGlvbiAoXywgZGVmKSB7ICAgICAgICAvLyB5aWVsZCB3aXRob3V0IGFueSBcImZyb21cIlxuICAgICAgICByZXR1cm4gaHRtbCB8fCBkZWYgfHwgJydcbiAgICAgIH0pXG4gIH1cblxuICByZXR1cm4gX21rZG9tXG5cbn0pKClcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBpdGVtIGxvb3BlZCBpbnRvIGFuIG9iamVjdCB1c2VkIHRvIGV4dGVuZCB0aGUgY2hpbGQgdGFnIHByb3BlcnRpZXNcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZXhwciAtIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXlzIHVzZWQgdG8gZXh0ZW5kIHRoZSBjaGlsZHJlbiB0YWdzXG4gKiBAcGFyYW0gICB7ICogfSBrZXkgLSB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIG5ldyBvYmplY3QgcmV0dXJuZWRcbiAqIEBwYXJhbSAgIHsgKiB9IHZhbCAtIHZhbHVlIGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIGluIHRoZSBhcnJheVxuICogQHJldHVybnMgeyBPYmplY3QgfSAtIG5ldyBvYmplY3QgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbCBpdGVtXG4gKlxuICogVGhlIHZhcmlhYmxlcyAna2V5JyBhbmQgJ3ZhbCcgYXJlIGFyYml0cmFyeS5cbiAqIFRoZXkgZGVwZW5kIG9uIHRoZSBjb2xsZWN0aW9uIHR5cGUgbG9vcGVkIChBcnJheSwgT2JqZWN0KVxuICogYW5kIG9uIHRoZSBleHByZXNzaW9uIHVzZWQgb24gdGhlIGVhY2ggdGFnXG4gKlxuICovXG5mdW5jdGlvbiBta2l0ZW0oZXhwciwga2V5LCB2YWwpIHtcbiAgdmFyIGl0ZW0gPSB7fVxuICBpdGVtW2V4cHIua2V5XSA9IGtleVxuICBpZiAoZXhwci5wb3MpIGl0ZW1bZXhwci5wb3NdID0gdmFsXG4gIHJldHVybiBpdGVtXG59XG5cbi8qKlxuICogVW5tb3VudCB0aGUgcmVkdW5kYW50IHRhZ3NcbiAqIEBwYXJhbSAgIHsgQXJyYXkgfSBpdGVtcyAtIGFycmF5IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgaXRlbXMgdG8gbG9vcFxuICogQHBhcmFtICAgeyBBcnJheSB9IHRhZ3MgLSBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgY2hpbGRyZW4gdGFnc1xuICovXG5mdW5jdGlvbiB1bm1vdW50UmVkdW5kYW50KGl0ZW1zLCB0YWdzKSB7XG5cbiAgdmFyIGkgPSB0YWdzLmxlbmd0aCxcbiAgICBqID0gaXRlbXMubGVuZ3RoLFxuICAgIHRcblxuICB3aGlsZSAoaSA+IGopIHtcbiAgICB0ID0gdGFnc1stLWldXG4gICAgdGFncy5zcGxpY2UoaSwgMSlcbiAgICB0LnVubW91bnQoKVxuICB9XG59XG5cbi8qKlxuICogTW92ZSB0aGUgbmVzdGVkIGN1c3RvbSB0YWdzIGluIG5vbiBjdXN0b20gbG9vcCB0YWdzXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGNoaWxkIC0gbm9uIGN1c3RvbSBsb29wIHRhZ1xuICogQHBhcmFtICAgeyBOdW1iZXIgfSBpIC0gY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgbG9vcCB0YWdcbiAqL1xuZnVuY3Rpb24gbW92ZU5lc3RlZFRhZ3MoY2hpbGQsIGkpIHtcbiAgT2JqZWN0LmtleXMoY2hpbGQudGFncykuZm9yRWFjaChmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgdmFyIHRhZyA9IGNoaWxkLnRhZ3NbdGFnTmFtZV1cbiAgICBpZiAoaXNBcnJheSh0YWcpKVxuICAgICAgZWFjaCh0YWcsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIG1vdmVDaGlsZFRhZyh0LCB0YWdOYW1lLCBpKVxuICAgICAgfSlcbiAgICBlbHNlXG4gICAgICBtb3ZlQ2hpbGRUYWcodGFnLCB0YWdOYW1lLCBpKVxuICB9KVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIGVsZW1lbnRzIGZvciBhIHZpcnR1YWwgdGFnXG4gKiBAcGFyYW0geyBUYWcgfSB0YWcgLSB0aGUgdGFnIHdob3NlIHJvb3QncyBjaGlsZHJlbiB3aWxsIGJlIGluc2VydGVkIG9yIGFwcGVuZGVkXG4gKiBAcGFyYW0geyBOb2RlIH0gc3JjIC0gdGhlIG5vZGUgdGhhdCB3aWxsIGRvIHRoZSBpbnNlcnRpbmcgb3IgYXBwZW5kaW5nXG4gKiBAcGFyYW0geyBUYWcgfSB0YXJnZXQgLSBvbmx5IGlmIGluc2VydGluZywgaW5zZXJ0IGJlZm9yZSB0aGlzIHRhZydzIGZpcnN0IGNoaWxkXG4gKi9cbmZ1bmN0aW9uIGFkZFZpcnR1YWwodGFnLCBzcmMsIHRhcmdldCkge1xuICB2YXIgZWwgPSB0YWcuX3Jvb3QsIHNpYlxuICB0YWcuX3ZpcnRzID0gW11cbiAgd2hpbGUgKGVsKSB7XG4gICAgc2liID0gZWwubmV4dFNpYmxpbmdcbiAgICBpZiAodGFyZ2V0KVxuICAgICAgc3JjLmluc2VydEJlZm9yZShlbCwgdGFyZ2V0Ll9yb290KVxuICAgIGVsc2VcbiAgICAgIHNyYy5hcHBlbmRDaGlsZChlbClcblxuICAgIHRhZy5fdmlydHMucHVzaChlbCkgLy8gaG9sZCBmb3IgdW5tb3VudGluZ1xuICAgIGVsID0gc2liXG4gIH1cbn1cblxuLyoqXG4gKiBNb3ZlIHZpcnR1YWwgdGFnIGFuZCBhbGwgY2hpbGQgbm9kZXNcbiAqIEBwYXJhbSB7IFRhZyB9IHRhZyAtIGZpcnN0IGNoaWxkIHJlZmVyZW5jZSB1c2VkIHRvIHN0YXJ0IG1vdmVcbiAqIEBwYXJhbSB7IE5vZGUgfSBzcmMgIC0gdGhlIG5vZGUgdGhhdCB3aWxsIGRvIHRoZSBpbnNlcnRpbmdcbiAqIEBwYXJhbSB7IFRhZyB9IHRhcmdldCAtIGluc2VydCBiZWZvcmUgdGhpcyB0YWcncyBmaXJzdCBjaGlsZFxuICogQHBhcmFtIHsgTnVtYmVyIH0gbGVuIC0gaG93IG1hbnkgY2hpbGQgbm9kZXMgdG8gbW92ZVxuICovXG5mdW5jdGlvbiBtb3ZlVmlydHVhbCh0YWcsIHNyYywgdGFyZ2V0LCBsZW4pIHtcbiAgdmFyIGVsID0gdGFnLl9yb290LCBzaWIsIGkgPSAwXG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzaWIgPSBlbC5uZXh0U2libGluZ1xuICAgIHNyYy5pbnNlcnRCZWZvcmUoZWwsIHRhcmdldC5fcm9vdClcbiAgICBlbCA9IHNpYlxuICB9XG59XG5cbi8qKlxuICogSW5zZXJ0IGEgbmV3IHRhZyBhdm9pZGluZyB0aGUgaW5zZXJ0IGZvciB0aGUgY29uZGl0aW9uYWwgdGFnc1xuICogQHBhcmFtICAge0Jvb2xlYW59IGlzVmlydHVhbCBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gICB7IFRhZyB9ICBwcmV2VGFnIC0gdGFnIGluc3RhbmNlIHVzZWQgYXMgcmVmZXJlbmNlIHRvIHByZXBlbmQgb3VyIG5ldyB0YWdcbiAqIEBwYXJhbSAgIHsgVGFnIH0gIG5ld1RhZyAtIG5ldyB0YWcgdG8gYmUgaW5zZXJ0ZWRcbiAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSAgcm9vdCAtIGxvb3AgcGFyZW50IG5vZGVcbiAqIEBwYXJhbSAgIHsgQXJyYXkgfSAgdGFncyAtIGFycmF5IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgdGFncyBsaXN0XG4gKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gIHZpcnR1YWxGbiAtIGNhbGxiYWNrIG5lZWRlZCB0byBtb3ZlIG9yIGluc2VydCB2aXJ0dWFsIERPTVxuICogQHBhcmFtICAgeyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSBuZWVkIHRvIGxvb3BcbiAqL1xuZnVuY3Rpb24gaW5zZXJ0VGFnKGlzVmlydHVhbCwgcHJldlRhZywgbmV3VGFnLCByb290LCB0YWdzLCB2aXJ0dWFsRm4sIGRvbSkge1xuICBpZiAoaXNJblN0dWIocHJldlRhZy5yb290KSkgcmV0dXJuXG4gIGlmIChpc1ZpcnR1YWwpIHZpcnR1YWxGbihwcmV2VGFnLCByb290LCBuZXdUYWcsIGRvbS5jaGlsZE5vZGVzLmxlbmd0aClcbiAgZWxzZSByb290Lmluc2VydEJlZm9yZShwcmV2VGFnLnJvb3QsIG5ld1RhZy5yb290KSAvLyAjMTM3NCBzb21lIGJyb3dzZXJzIHJlc2V0IHNlbGVjdGVkIGhlcmVcbn1cblxuXG4vKipcbiAqIE1hbmFnZSB0YWdzIGhhdmluZyB0aGUgJ2VhY2gnXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIG5lZWQgdG8gbG9vcFxuICogQHBhcmFtICAgeyBUYWcgfSBwYXJlbnQgLSBwYXJlbnQgdGFnIGluc3RhbmNlIHdoZXJlIHRoZSBkb20gbm9kZSBpcyBjb250YWluZWRcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gZXhwciAtIHN0cmluZyBjb250YWluZWQgaW4gdGhlICdlYWNoJyBhdHRyaWJ1dGVcbiAqL1xuZnVuY3Rpb24gX2VhY2goZG9tLCBwYXJlbnQsIGV4cHIpIHtcblxuICAvLyByZW1vdmUgdGhlIGVhY2ggcHJvcGVydHkgZnJvbSB0aGUgb3JpZ2luYWwgdGFnXG4gIHJlbUF0dHIoZG9tLCAnZWFjaCcpXG5cbiAgdmFyIG11c3RSZW9yZGVyID0gdHlwZW9mIGdldEF0dHIoZG9tLCAnbm8tcmVvcmRlcicpICE9PSBUX1NUUklORyB8fCByZW1BdHRyKGRvbSwgJ25vLXJlb3JkZXInKSxcbiAgICB0YWdOYW1lID0gZ2V0VGFnTmFtZShkb20pLFxuICAgIGltcGwgPSBfX3RhZ0ltcGxbdGFnTmFtZV0gfHwgeyB0bXBsOiBnZXRPdXRlckhUTUwoZG9tKSB9LFxuICAgIHVzZVJvb3QgPSBTUEVDSUFMX1RBR1NfUkVHRVgudGVzdCh0YWdOYW1lKSxcbiAgICByb290ID0gZG9tLnBhcmVudE5vZGUsXG4gICAgcmVmID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpLFxuICAgIGNoaWxkID0gZ2V0VGFnKGRvbSksXG4gICAgaXNPcHRpb24gPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvcHRpb24nLCAvLyB0aGUgb3B0aW9uIHRhZ3MgbXVzdCBiZSB0cmVhdGVkIGRpZmZlcmVudGx5XG4gICAgdGFncyA9IFtdLFxuICAgIG9sZEl0ZW1zID0gW10sXG4gICAgaGFzS2V5cyxcbiAgICBpc1ZpcnR1YWwgPSBkb20udGFnTmFtZSA9PSAnVklSVFVBTCdcblxuICAvLyBwYXJzZSB0aGUgZWFjaCBleHByZXNzaW9uXG4gIGV4cHIgPSB0bXBsLmxvb3BLZXlzKGV4cHIpXG5cbiAgLy8gaW5zZXJ0IGEgbWFya2VkIHdoZXJlIHRoZSBsb29wIHRhZ3Mgd2lsbCBiZSBpbmplY3RlZFxuICByb290Lmluc2VydEJlZm9yZShyZWYsIGRvbSlcblxuICAvLyBjbGVhbiB0ZW1wbGF0ZSBjb2RlXG4gIHBhcmVudC5vbmUoJ2JlZm9yZS1tb3VudCcsIGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHJlbW92ZSB0aGUgb3JpZ2luYWwgRE9NIG5vZGVcbiAgICBkb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pXG4gICAgaWYgKHJvb3Quc3R1Yikgcm9vdCA9IHBhcmVudC5yb290XG5cbiAgfSkub24oJ3VwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBnZXQgdGhlIG5ldyBpdGVtcyBjb2xsZWN0aW9uXG4gICAgdmFyIGl0ZW1zID0gdG1wbChleHByLnZhbCwgcGFyZW50KSxcbiAgICAgIC8vIGNyZWF0ZSBhIGZyYWdtZW50IHRvIGhvbGQgdGhlIG5ldyBET00gbm9kZXMgdG8gaW5qZWN0IGluIHRoZSBwYXJlbnQgdGFnXG4gICAgICBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cbiAgICAvLyBvYmplY3QgbG9vcC4gYW55IGNoYW5nZXMgY2F1c2UgZnVsbCByZWRyYXdcbiAgICBpZiAoIWlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICBoYXNLZXlzID0gaXRlbXMgfHwgZmFsc2VcbiAgICAgIGl0ZW1zID0gaGFzS2V5cyA/XG4gICAgICAgIE9iamVjdC5rZXlzKGl0ZW1zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBta2l0ZW0oZXhwciwga2V5LCBpdGVtc1trZXldKVxuICAgICAgICB9KSA6IFtdXG4gICAgfVxuXG4gICAgLy8gbG9vcCBhbGwgdGhlIG5ldyBpdGVtc1xuICAgIHZhciBpID0gMCxcbiAgICAgIGl0ZW1zTGVuZ3RoID0gaXRlbXMubGVuZ3RoXG5cbiAgICBmb3IgKDsgaSA8IGl0ZW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHJlb3JkZXIgb25seSBpZiB0aGUgaXRlbXMgYXJlIG9iamVjdHNcbiAgICAgIHZhclxuICAgICAgICBpdGVtID0gaXRlbXNbaV0sXG4gICAgICAgIF9tdXN0UmVvcmRlciA9IG11c3RSZW9yZGVyICYmIHR5cGVvZiBpdGVtID09IFRfT0JKRUNUICYmICFoYXNLZXlzLFxuICAgICAgICBvbGRQb3MgPSBvbGRJdGVtcy5pbmRleE9mKGl0ZW0pLFxuICAgICAgICBwb3MgPSB+b2xkUG9zICYmIF9tdXN0UmVvcmRlciA/IG9sZFBvcyA6IGksXG4gICAgICAgIC8vIGRvZXMgYSB0YWcgZXhpc3QgaW4gdGhpcyBwb3NpdGlvbj9cbiAgICAgICAgdGFnID0gdGFnc1twb3NdXG5cbiAgICAgIGl0ZW0gPSAhaGFzS2V5cyAmJiBleHByLmtleSA/IG1raXRlbShleHByLCBpdGVtLCBpKSA6IGl0ZW1cblxuICAgICAgLy8gbmV3IHRhZ1xuICAgICAgaWYgKFxuICAgICAgICAhX211c3RSZW9yZGVyICYmICF0YWcgLy8gd2l0aCBuby1yZW9yZGVyIHdlIGp1c3QgdXBkYXRlIHRoZSBvbGQgdGFnc1xuICAgICAgICB8fFxuICAgICAgICBfbXVzdFJlb3JkZXIgJiYgIX5vbGRQb3MgfHwgIXRhZyAvLyBieSBkZWZhdWx0IHdlIGFsd2F5cyB0cnkgdG8gcmVvcmRlciB0aGUgRE9NIGVsZW1lbnRzXG4gICAgICApIHtcblxuICAgICAgICB0YWcgPSBuZXcgVGFnKGltcGwsIHtcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICBpc0xvb3A6IHRydWUsXG4gICAgICAgICAgaGFzSW1wbDogISFfX3RhZ0ltcGxbdGFnTmFtZV0sXG4gICAgICAgICAgcm9vdDogdXNlUm9vdCA/IHJvb3QgOiBkb20uY2xvbmVOb2RlKCksXG4gICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICB9LCBkb20uaW5uZXJIVE1MKVxuXG4gICAgICAgIHRhZy5tb3VudCgpXG5cbiAgICAgICAgaWYgKGlzVmlydHVhbCkgdGFnLl9yb290ID0gdGFnLnJvb3QuZmlyc3RDaGlsZCAvLyBzYXZlIHJlZmVyZW5jZSBmb3IgZnVydGhlciBtb3ZlcyBvciBpbnNlcnRzXG4gICAgICAgIC8vIHRoaXMgdGFnIG11c3QgYmUgYXBwZW5kZWRcbiAgICAgICAgaWYgKGkgPT0gdGFncy5sZW5ndGggfHwgIXRhZ3NbaV0pIHsgLy8gZml4IDE1ODFcbiAgICAgICAgICBpZiAoaXNWaXJ0dWFsKVxuICAgICAgICAgICAgYWRkVmlydHVhbCh0YWcsIGZyYWcpXG4gICAgICAgICAgZWxzZSBmcmFnLmFwcGVuZENoaWxkKHRhZy5yb290KVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgdGFnIG11c3QgYmUgaW5zZXJ0XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGluc2VydFRhZyhpc1ZpcnR1YWwsIHRhZywgdGFnc1tpXSwgcm9vdCwgdGFncywgYWRkVmlydHVhbCwgZG9tKVxuICAgICAgICAgIG9sZEl0ZW1zLnNwbGljZShpLCAwLCBpdGVtKVxuICAgICAgICB9XG5cbiAgICAgICAgdGFncy5zcGxpY2UoaSwgMCwgdGFnKVxuICAgICAgICBwb3MgPSBpIC8vIGhhbmRsZWQgaGVyZSBzbyBubyBtb3ZlXG4gICAgICB9IGVsc2UgdGFnLnVwZGF0ZShpdGVtLCB0cnVlKVxuXG4gICAgICAvLyByZW9yZGVyIHRoZSB0YWcgaWYgaXQncyBub3QgbG9jYXRlZCBpbiBpdHMgcHJldmlvdXMgcG9zaXRpb25cbiAgICAgIGlmIChcbiAgICAgICAgcG9zICE9PSBpICYmIF9tdXN0UmVvcmRlciAmJlxuICAgICAgICB0YWdzW2ldIC8vIGZpeCAxNTgxIHVuYWJsZSB0byByZXByb2R1Y2UgaXQgaW4gYSB0ZXN0IVxuICAgICAgKSB7XG4gICAgICAgIC8vICNjbG9zZXMgMjA0MCBQTEVBU0UgRE9OJ1QgUkVNT1ZFIElUIVxuICAgICAgICAvLyB0aGVyZSBhcmUgbm8gdGVzdHMgZm9yIHRoaXMgZmVhdHVyZVxuICAgICAgICBpZiAoY29udGFpbnMoaXRlbXMsIG9sZEl0ZW1zW2ldKSlcbiAgICAgICAgICBpbnNlcnRUYWcoaXNWaXJ0dWFsLCB0YWcsIHRhZ3NbaV0sIHJvb3QsIHRhZ3MsIG1vdmVWaXJ0dWFsLCBkb20pXG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwb3NpdGlvbiBhdHRyaWJ1dGUgaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmIChleHByLnBvcylcbiAgICAgICAgICB0YWdbZXhwci5wb3NdID0gaVxuICAgICAgICAvLyBtb3ZlIHRoZSBvbGQgdGFnIGluc3RhbmNlXG4gICAgICAgIHRhZ3Muc3BsaWNlKGksIDAsIHRhZ3Muc3BsaWNlKHBvcywgMSlbMF0pXG4gICAgICAgIC8vIG1vdmUgdGhlIG9sZCBpdGVtXG4gICAgICAgIG9sZEl0ZW1zLnNwbGljZShpLCAwLCBvbGRJdGVtcy5zcGxpY2UocG9zLCAxKVswXSlcbiAgICAgICAgLy8gaWYgdGhlIGxvb3AgdGFncyBhcmUgbm90IGN1c3RvbVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIG1vdmUgYWxsIHRoZWlyIGN1c3RvbSB0YWdzIGludG8gdGhlIHJpZ2h0IHBvc2l0aW9uXG4gICAgICAgIGlmICghY2hpbGQgJiYgdGFnLnRhZ3MpIG1vdmVOZXN0ZWRUYWdzKHRhZywgaSlcbiAgICAgIH1cblxuICAgICAgLy8gY2FjaGUgdGhlIG9yaWdpbmFsIGl0ZW0gdG8gdXNlIGl0IGluIHRoZSBldmVudHMgYm91bmQgdG8gdGhpcyBub2RlXG4gICAgICAvLyBhbmQgaXRzIGNoaWxkcmVuXG4gICAgICB0YWcuX2l0ZW0gPSBpdGVtXG4gICAgICAvLyBjYWNoZSB0aGUgcmVhbCBwYXJlbnQgdGFnIGludGVybmFsbHlcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhZywgJ19wYXJlbnQnLCBwYXJlbnQpXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHRoZSByZWR1bmRhbnQgdGFnc1xuICAgIHVubW91bnRSZWR1bmRhbnQoaXRlbXMsIHRhZ3MpXG5cbiAgICAvLyBpbnNlcnQgdGhlIG5ldyBub2Rlc1xuICAgIHJvb3QuaW5zZXJ0QmVmb3JlKGZyYWcsIHJlZilcbiAgICBpZiAoaXNPcHRpb24pIHtcblxuICAgICAgLy8gIzEzNzQgRmlyZUZveCBidWcgaW4gPG9wdGlvbiBzZWxlY3RlZD17ZXhwcmVzc2lvbn0+XG4gICAgICBpZiAoRklSRUZPWCAmJiAhcm9vdC5tdWx0aXBsZSkge1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHJvb3QubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICBpZiAocm9vdFtuXS5fX3Jpb3QxMzc0KSB7XG4gICAgICAgICAgICByb290LnNlbGVjdGVkSW5kZXggPSBuICAvLyBjbGVhciBvdGhlciBvcHRpb25zXG4gICAgICAgICAgICBkZWxldGUgcm9vdFtuXS5fX3Jpb3QxMzc0XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCB0aGUgJ3RhZ3MnIHByb3BlcnR5IG9mIHRoZSBwYXJlbnQgdGFnXG4gICAgLy8gaWYgY2hpbGQgaXMgJ3VuZGVmaW5lZCcgaXQgbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIHRvIHNldCB0aGlzIHByb3BlcnR5XG4gICAgLy8gZm9yIGV4YW1wbGU6XG4gICAgLy8gd2UgZG9uJ3QgbmVlZCBzdG9yZSB0aGUgYG15VGFnLnRhZ3NbJ2RpdiddYCBwcm9wZXJ0eSBpZiB3ZSBhcmUgbG9vcGluZyBhIGRpdiB0YWdcbiAgICAvLyBidXQgd2UgbmVlZCB0byB0cmFjayB0aGUgYG15VGFnLnRhZ3NbJ2NoaWxkJ11gIHByb3BlcnR5IGxvb3BpbmcgYSBjdXN0b20gY2hpbGQgbm9kZSBuYW1lZCBgY2hpbGRgXG4gICAgaWYgKGNoaWxkKSBwYXJlbnQudGFnc1t0YWdOYW1lXSA9IHRhZ3NcblxuICAgIC8vIGNsb25lIHRoZSBpdGVtcyBhcnJheVxuICAgIG9sZEl0ZW1zID0gaXRlbXMuc2xpY2UoKVxuXG4gIH0pXG5cbn1cbi8qKlxuICogT2JqZWN0IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGluamVjdCBhbmQgbWFuYWdlIHRoZSBjc3Mgb2YgZXZlcnkgdGFnIGluc3RhbmNlXG4gKi9cbnZhciBzdHlsZU1hbmFnZXIgPSAoZnVuY3Rpb24oX3Jpb3QpIHtcblxuICBpZiAoIXdpbmRvdykgcmV0dXJuIHsgLy8gc2tpcCBpbmplY3Rpb24gb24gdGhlIHNlcnZlclxuICAgIGFkZDogZnVuY3Rpb24gKCkge30sXG4gICAgaW5qZWN0OiBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgdmFyIHN0eWxlTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IHN0eWxlIGVsZW1lbnQgd2l0aCB0aGUgY29ycmVjdCB0eXBlXG4gICAgdmFyIG5ld05vZGUgPSBta0VsKCdzdHlsZScpXG4gICAgc2V0QXR0cihuZXdOb2RlLCAndHlwZScsICd0ZXh0L2NzcycpXG5cbiAgICAvLyByZXBsYWNlIGFueSB1c2VyIG5vZGUgb3IgaW5zZXJ0IHRoZSBuZXcgb25lIGludG8gdGhlIGhlYWRcbiAgICB2YXIgdXNlck5vZGUgPSAkKCdzdHlsZVt0eXBlPXJpb3RdJylcbiAgICBpZiAodXNlck5vZGUpIHtcbiAgICAgIGlmICh1c2VyTm9kZS5pZCkgbmV3Tm9kZS5pZCA9IHVzZXJOb2RlLmlkXG4gICAgICB1c2VyTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdOb2RlLCB1c2VyTm9kZSlcbiAgICB9XG4gICAgZWxzZSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKG5ld05vZGUpXG5cbiAgICByZXR1cm4gbmV3Tm9kZVxuICB9KSgpXG5cbiAgLy8gQ3JlYXRlIGNhY2hlIGFuZCBzaG9ydGN1dCB0byB0aGUgY29ycmVjdCBwcm9wZXJ0eVxuICB2YXIgY3NzVGV4dFByb3AgPSBzdHlsZU5vZGUuc3R5bGVTaGVldCxcbiAgICBzdHlsZXNUb0luamVjdCA9ICcnXG5cbiAgLy8gRXhwb3NlIHRoZSBzdHlsZSBub2RlIGluIGEgbm9uLW1vZGlmaWNhYmxlIHByb3BlcnR5XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfcmlvdCwgJ3N0eWxlTm9kZScsIHtcbiAgICB2YWx1ZTogc3R5bGVOb2RlLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pXG5cbiAgLyoqXG4gICAqIFB1YmxpYyBhcGlcbiAgICovXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogU2F2ZSBhIHRhZyBzdHlsZSB0byBiZSBsYXRlciBpbmplY3RlZCBpbnRvIERPTVxuICAgICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gY3NzIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKGNzcykge1xuICAgICAgc3R5bGVzVG9JbmplY3QgKz0gY3NzXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJbmplY3QgYWxsIHByZXZpb3VzbHkgc2F2ZWQgdGFnIHN0eWxlcyBpbnRvIERPTVxuICAgICAqIGlubmVySFRNTCBzZWVtcyBzbG93OiBodHRwOi8vanNwZXJmLmNvbS9yaW90LWluc2VydC1zdHlsZVxuICAgICAqL1xuICAgIGluamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc3R5bGVzVG9JbmplY3QpIHtcbiAgICAgICAgaWYgKGNzc1RleHRQcm9wKSBjc3NUZXh0UHJvcC5jc3NUZXh0ICs9IHN0eWxlc1RvSW5qZWN0XG4gICAgICAgIGVsc2Ugc3R5bGVOb2RlLmlubmVySFRNTCArPSBzdHlsZXNUb0luamVjdFxuICAgICAgICBzdHlsZXNUb0luamVjdCA9ICcnXG4gICAgICB9XG4gICAgfVxuICB9XG5cbn0pKHJpb3QpXG5cblxuZnVuY3Rpb24gcGFyc2VOYW1lZEVsZW1lbnRzKHJvb3QsIHRhZywgY2hpbGRUYWdzLCBmb3JjZVBhcnNpbmdOYW1lZCkge1xuXG4gIHdhbGsocm9vdCwgZnVuY3Rpb24oZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICBkb20uaXNMb29wID0gZG9tLmlzTG9vcCB8fFxuICAgICAgICAgICAgICAgICAgKGRvbS5wYXJlbnROb2RlICYmIGRvbS5wYXJlbnROb2RlLmlzTG9vcCB8fCBnZXRBdHRyKGRvbSwgJ2VhY2gnKSlcbiAgICAgICAgICAgICAgICAgICAgPyAxIDogMFxuXG4gICAgICAvLyBjdXN0b20gY2hpbGQgdGFnXG4gICAgICBpZiAoY2hpbGRUYWdzKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGdldFRhZyhkb20pXG5cbiAgICAgICAgaWYgKGNoaWxkICYmICFkb20uaXNMb29wKVxuICAgICAgICAgIGNoaWxkVGFncy5wdXNoKGluaXRDaGlsZFRhZyhjaGlsZCwge3Jvb3Q6IGRvbSwgcGFyZW50OiB0YWd9LCBkb20uaW5uZXJIVE1MLCB0YWcpKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRvbS5pc0xvb3AgfHwgZm9yY2VQYXJzaW5nTmFtZWQpXG4gICAgICAgIHNldE5hbWVkKGRvbSwgdGFnLCBbXSlcbiAgICB9XG5cbiAgfSlcblxufVxuXG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25zKHJvb3QsIHRhZywgZXhwcmVzc2lvbnMpIHtcblxuICBmdW5jdGlvbiBhZGRFeHByKGRvbSwgdmFsLCBleHRyYSkge1xuICAgIGlmICh0bXBsLmhhc0V4cHIodmFsKSkge1xuICAgICAgZXhwcmVzc2lvbnMucHVzaChleHRlbmQoeyBkb206IGRvbSwgZXhwcjogdmFsIH0sIGV4dHJhKSlcbiAgICB9XG4gIH1cblxuICB3YWxrKHJvb3QsIGZ1bmN0aW9uKGRvbSkge1xuICAgIHZhciB0eXBlID0gZG9tLm5vZGVUeXBlLFxuICAgICAgYXR0clxuXG4gICAgLy8gdGV4dCBub2RlXG4gICAgaWYgKHR5cGUgPT0gMyAmJiBkb20ucGFyZW50Tm9kZS50YWdOYW1lICE9ICdTVFlMRScpIGFkZEV4cHIoZG9tLCBkb20ubm9kZVZhbHVlKVxuICAgIGlmICh0eXBlICE9IDEpIHJldHVyblxuXG4gICAgLyogZWxlbWVudCAqL1xuXG4gICAgLy8gbG9vcFxuICAgIGF0dHIgPSBnZXRBdHRyKGRvbSwgJ2VhY2gnKVxuXG4gICAgaWYgKGF0dHIpIHsgX2VhY2goZG9tLCB0YWcsIGF0dHIpOyByZXR1cm4gZmFsc2UgfVxuXG4gICAgLy8gYXR0cmlidXRlIGV4cHJlc3Npb25zXG4gICAgZWFjaChkb20uYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyLm5hbWUsXG4gICAgICAgIGJvb2wgPSBuYW1lLnNwbGl0KCdfXycpWzFdXG5cbiAgICAgIGFkZEV4cHIoZG9tLCBhdHRyLnZhbHVlLCB7IGF0dHI6IGJvb2wgfHwgbmFtZSwgYm9vbDogYm9vbCB9KVxuICAgICAgaWYgKGJvb2wpIHsgcmVtQXR0cihkb20sIG5hbWUpOyByZXR1cm4gZmFsc2UgfVxuXG4gICAgfSlcblxuICAgIC8vIHNraXAgY3VzdG9tIHRhZ3NcbiAgICBpZiAoZ2V0VGFnKGRvbSkpIHJldHVybiBmYWxzZVxuXG4gIH0pXG5cbn1cbmZ1bmN0aW9uIFRhZyhpbXBsLCBjb25mLCBpbm5lckhUTUwpIHtcblxuICB2YXIgc2VsZiA9IHJpb3Qub2JzZXJ2YWJsZSh0aGlzKSxcbiAgICBvcHRzID0gaW5oZXJpdChjb25mLm9wdHMpIHx8IHt9LFxuICAgIHBhcmVudCA9IGNvbmYucGFyZW50LFxuICAgIGlzTG9vcCA9IGNvbmYuaXNMb29wLFxuICAgIGhhc0ltcGwgPSBjb25mLmhhc0ltcGwsXG4gICAgaXRlbSA9IGNsZWFuVXBEYXRhKGNvbmYuaXRlbSksXG4gICAgZXhwcmVzc2lvbnMgPSBbXSxcbiAgICBjaGlsZFRhZ3MgPSBbXSxcbiAgICByb290ID0gY29uZi5yb290LFxuICAgIHRhZ05hbWUgPSByb290LnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICBhdHRyID0ge30sXG4gICAgcHJvcHNJblN5bmNXaXRoUGFyZW50ID0gW10sXG4gICAgZG9tXG5cbiAgLy8gb25seSBjYWxsIHVubW91bnQgaWYgd2UgaGF2ZSBhIHZhbGlkIF9fdGFnSW1wbCAoaGFzIG5hbWUgcHJvcGVydHkpXG4gIGlmIChpbXBsLm5hbWUgJiYgcm9vdC5fdGFnKSByb290Ll90YWcudW5tb3VudCh0cnVlKVxuXG4gIC8vIG5vdCB5ZXQgbW91bnRlZFxuICB0aGlzLmlzTW91bnRlZCA9IGZhbHNlXG4gIHJvb3QuaXNMb29wID0gaXNMb29wXG5cbiAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgdGFnIGp1c3QgY3JlYXRlZFxuICAvLyBzbyB3ZSB3aWxsIGJlIGFibGUgdG8gbW91bnQgdGhpcyB0YWcgbXVsdGlwbGUgdGltZXNcbiAgcm9vdC5fdGFnID0gdGhpc1xuXG4gIC8vIGNyZWF0ZSBhIHVuaXF1ZSBpZCB0byB0aGlzIHRhZ1xuICAvLyBpdCBjb3VsZCBiZSBoYW5keSB0byB1c2UgaXQgYWxzbyB0byBpbXByb3ZlIHRoZSB2aXJ0dWFsIGRvbSByZW5kZXJpbmcgc3BlZWRcbiAgZGVmaW5lUHJvcGVydHkodGhpcywgJ19yaW90X2lkJywgKytfX3VpZCkgLy8gYmFzZSAxIGFsbG93cyB0ZXN0ICF0Ll9yaW90X2lkXG5cbiAgZXh0ZW5kKHRoaXMsIHsgcGFyZW50OiBwYXJlbnQsIHJvb3Q6IHJvb3QsIG9wdHM6IG9wdHN9LCBpdGVtKVxuICAvLyBwcm90ZWN0IHRoZSBcInRhZ3NcIiBwcm9wZXJ0eSBmcm9tIGJlaW5nIG92ZXJyaWRkZW5cbiAgZGVmaW5lUHJvcGVydHkodGhpcywgJ3RhZ3MnLCB7fSlcblxuICAvLyBncmFiIGF0dHJpYnV0ZXNcbiAgZWFjaChyb290LmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIHZhbCA9IGVsLnZhbHVlXG4gICAgLy8gcmVtZW1iZXIgYXR0cmlidXRlcyB3aXRoIGV4cHJlc3Npb25zIG9ubHlcbiAgICBpZiAodG1wbC5oYXNFeHByKHZhbCkpIGF0dHJbZWwubmFtZV0gPSB2YWxcbiAgfSlcblxuICBkb20gPSBta2RvbShpbXBsLnRtcGwsIGlubmVySFRNTCwgaXNMb29wKVxuXG4gIC8vIG9wdGlvbnNcbiAgZnVuY3Rpb24gdXBkYXRlT3B0cygpIHtcbiAgICB2YXIgY3R4ID0gaGFzSW1wbCAmJiBpc0xvb3AgPyBzZWxmIDogcGFyZW50IHx8IHNlbGZcblxuICAgIC8vIHVwZGF0ZSBvcHRzIGZyb20gY3VycmVudCBET00gYXR0cmlidXRlc1xuICAgIGVhY2gocm9vdC5hdHRyaWJ1dGVzLCBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIHZhbCA9IGVsLnZhbHVlXG4gICAgICBvcHRzW3RvQ2FtZWwoZWwubmFtZSldID0gdG1wbC5oYXNFeHByKHZhbCkgPyB0bXBsKHZhbCwgY3R4KSA6IHZhbFxuICAgIH0pXG4gICAgLy8gcmVjb3ZlciB0aG9zZSB3aXRoIGV4cHJlc3Npb25zXG4gICAgZWFjaChPYmplY3Qua2V5cyhhdHRyKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgb3B0c1t0b0NhbWVsKG5hbWUpXSA9IHRtcGwoYXR0cltuYW1lXSwgY3R4KVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVEYXRhKGRhdGEpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaXRlbSkge1xuICAgICAgaWYgKHR5cGVvZiBzZWxmW2tleV0gIT09IFRfVU5ERUYgJiYgaXNXcml0YWJsZShzZWxmLCBrZXkpKVxuICAgICAgICBzZWxmW2tleV0gPSBkYXRhW2tleV1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmhlcml0RnJvbSh0YXJnZXQpIHtcbiAgICBlYWNoKE9iamVjdC5rZXlzKHRhcmdldCksIGZ1bmN0aW9uKGspIHtcbiAgICAgIC8vIHNvbWUgcHJvcGVydGllcyBtdXN0IGJlIGFsd2F5cyBpbiBzeW5jIHdpdGggdGhlIHBhcmVudCB0YWdcbiAgICAgIHZhciBtdXN0U3luYyA9ICFSRVNFUlZFRF9XT1JEU19CTEFDS0xJU1QudGVzdChrKSAmJiBjb250YWlucyhwcm9wc0luU3luY1dpdGhQYXJlbnQsIGspXG5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZltrXSA9PT0gVF9VTkRFRiB8fCBtdXN0U3luYykge1xuICAgICAgICAvLyB0cmFjayB0aGUgcHJvcGVydHkgdG8ga2VlcCBpbiBzeW5jXG4gICAgICAgIC8vIHNvIHdlIGNhbiBrZWVwIGl0IHVwZGF0ZWRcbiAgICAgICAgaWYgKCFtdXN0U3luYykgcHJvcHNJblN5bmNXaXRoUGFyZW50LnB1c2goaylcbiAgICAgICAgc2VsZltrXSA9IHRhcmdldFtrXVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0YWcgZXhwcmVzc2lvbnMgYW5kIG9wdGlvbnNcbiAgICogQHBhcmFtICAgeyAqIH0gIGRhdGEgLSBkYXRhIHdlIHdhbnQgdG8gdXNlIHRvIGV4dGVuZCB0aGUgdGFnIHByb3BlcnRpZXNcbiAgICogQHBhcmFtICAgeyBCb29sZWFuIH0gaXNJbmhlcml0ZWQgLSBpcyB0aGlzIHVwZGF0ZSBjb21pbmcgZnJvbSBhIHBhcmVudCB0YWc/XG4gICAqIEByZXR1cm5zIHsgc2VsZiB9XG4gICAqL1xuICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAndXBkYXRlJywgZnVuY3Rpb24oZGF0YSwgaXNJbmhlcml0ZWQpIHtcblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgZGF0YSBwYXNzZWQgd2lsbCBub3Qgb3ZlcnJpZGVcbiAgICAvLyB0aGUgY29tcG9uZW50IGNvcmUgbWV0aG9kc1xuICAgIGRhdGEgPSBjbGVhblVwRGF0YShkYXRhKVxuICAgIC8vIGluaGVyaXQgcHJvcGVydGllcyBmcm9tIHRoZSBwYXJlbnQgaW4gbG9vcFxuICAgIGlmIChpc0xvb3ApIHtcbiAgICAgIGluaGVyaXRGcm9tKHNlbGYucGFyZW50KVxuICAgIH1cbiAgICAvLyBub3JtYWxpemUgdGhlIHRhZyBwcm9wZXJ0aWVzIGluIGNhc2UgYW4gaXRlbSBvYmplY3Qgd2FzIGluaXRpYWxseSBwYXNzZWRcbiAgICBpZiAoZGF0YSAmJiBpc09iamVjdChpdGVtKSkge1xuICAgICAgbm9ybWFsaXplRGF0YShkYXRhKVxuICAgICAgaXRlbSA9IGRhdGFcbiAgICB9XG4gICAgZXh0ZW5kKHNlbGYsIGRhdGEpXG4gICAgdXBkYXRlT3B0cygpXG4gICAgc2VsZi50cmlnZ2VyKCd1cGRhdGUnLCBkYXRhKVxuICAgIHVwZGF0ZShleHByZXNzaW9ucywgc2VsZilcblxuICAgIC8vIHRoZSB1cGRhdGVkIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkXG4gICAgLy8gb25jZSB0aGUgRE9NIHdpbGwgYmUgcmVhZHkgYW5kIGFsbCB0aGUgcmUtZmxvd3MgYXJlIGNvbXBsZXRlZFxuICAgIC8vIHRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGdldCB0aGUgXCJyZWFsXCIgcm9vdCBwcm9wZXJ0aWVzXG4gICAgLy8gNCBleDogcm9vdC5vZmZzZXRXaWR0aCAuLi5cbiAgICBpZiAoaXNJbmhlcml0ZWQgJiYgc2VsZi5wYXJlbnQpXG4gICAgICAvLyBjbG9zZXMgIzE1OTlcbiAgICAgIHNlbGYucGFyZW50Lm9uZSgndXBkYXRlZCcsIGZ1bmN0aW9uKCkgeyBzZWxmLnRyaWdnZXIoJ3VwZGF0ZWQnKSB9KVxuICAgIGVsc2UgckFGKGZ1bmN0aW9uKCkgeyBzZWxmLnRyaWdnZXIoJ3VwZGF0ZWQnKSB9KVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfSlcblxuICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWl4aW4nLCBmdW5jdGlvbigpIHtcbiAgICBlYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24obWl4KSB7XG4gICAgICB2YXIgaW5zdGFuY2UsXG4gICAgICAgIHByb3BzID0gW10sXG4gICAgICAgIG9ialxuXG4gICAgICBtaXggPSB0eXBlb2YgbWl4ID09PSBUX1NUUklORyA/IHJpb3QubWl4aW4obWl4KSA6IG1peFxuXG4gICAgICAvLyBjaGVjayBpZiB0aGUgbWl4aW4gaXMgYSBmdW5jdGlvblxuICAgICAgaWYgKGlzRnVuY3Rpb24obWl4KSkge1xuICAgICAgICAvLyBjcmVhdGUgdGhlIG5ldyBtaXhpbiBpbnN0YW5jZVxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBtaXgoKVxuICAgICAgfSBlbHNlIGluc3RhbmNlID0gbWl4XG5cbiAgICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0YW5jZSlcblxuICAgICAgLy8gYnVpbGQgbXVsdGlsZXZlbCBwcm90b3R5cGUgaW5oZXJpdGFuY2UgY2hhaW4gcHJvcGVydHkgbGlzdFxuICAgICAgZG8gcHJvcHMgPSBwcm9wcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqIHx8IGluc3RhbmNlKSlcbiAgICAgIHdoaWxlIChvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqIHx8IGluc3RhbmNlKSlcblxuICAgICAgLy8gbG9vcCB0aGUga2V5cyBpbiB0aGUgZnVuY3Rpb24gcHJvdG90eXBlIG9yIHRoZSBhbGwgb2JqZWN0IGtleXNcbiAgICAgIGVhY2gocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAvLyBiaW5kIG1ldGhvZHMgdG8gc2VsZlxuICAgICAgICAvLyBhbGxvdyBtaXhpbnMgdG8gb3ZlcnJpZGUgb3RoZXIgcHJvcGVydGllcy9wYXJlbnQgbWl4aW5zXG4gICAgICAgIGlmIChrZXkgIT0gJ2luaXQnKSB7XG4gICAgICAgICAgLy8gY2hlY2sgZm9yIGdldHRlcnMvc2V0dGVyc1xuICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbnN0YW5jZSwga2V5KSB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBrZXkpXG4gICAgICAgICAgdmFyIGhhc0dldHRlclNldHRlciA9IGRlc2NyaXB0b3IgJiYgKGRlc2NyaXB0b3IuZ2V0IHx8IGRlc2NyaXB0b3Iuc2V0KVxuXG4gICAgICAgICAgLy8gYXBwbHkgbWV0aG9kIG9ubHkgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdCBvbiB0aGUgaW5zdGFuY2VcbiAgICAgICAgICBpZiAoIXNlbGYuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBoYXNHZXR0ZXJTZXR0ZXIpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIGRlc2NyaXB0b3IpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGZba2V5XSA9IGlzRnVuY3Rpb24oaW5zdGFuY2Vba2V5XSkgP1xuICAgICAgICAgICAgICBpbnN0YW5jZVtrZXldLmJpbmQoc2VsZikgOlxuICAgICAgICAgICAgICBpbnN0YW5jZVtrZXldXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBpbml0IG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5XG4gICAgICBpZiAoaW5zdGFuY2UuaW5pdCkgaW5zdGFuY2UuaW5pdC5iaW5kKHNlbGYpKClcbiAgICB9KVxuICAgIHJldHVybiB0aGlzXG4gIH0pXG5cbiAgZGVmaW5lUHJvcGVydHkodGhpcywgJ21vdW50JywgZnVuY3Rpb24oKSB7XG5cbiAgICB1cGRhdGVPcHRzKClcblxuICAgIC8vIGFkZCBnbG9iYWwgbWl4aW5zXG4gICAgdmFyIGdsb2JhbE1peGluID0gcmlvdC5taXhpbihHTE9CQUxfTUlYSU4pXG5cbiAgICBpZiAoZ2xvYmFsTWl4aW4pXG4gICAgICBmb3IgKHZhciBpIGluIGdsb2JhbE1peGluKVxuICAgICAgICBpZiAoZ2xvYmFsTWl4aW4uaGFzT3duUHJvcGVydHkoaSkpXG4gICAgICAgICAgc2VsZi5taXhpbihnbG9iYWxNaXhpbltpXSlcblxuICAgIC8vIGNoaWxkcmVuIGluIGxvb3Agc2hvdWxkIGluaGVyaXQgZnJvbSB0cnVlIHBhcmVudFxuICAgIGlmIChzZWxmLl9wYXJlbnQgJiYgc2VsZi5fcGFyZW50LnJvb3QuaXNMb29wKSB7XG4gICAgICBpbmhlcml0RnJvbShzZWxmLl9wYXJlbnQpXG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGlhdGlvblxuICAgIGlmIChpbXBsLmZuKSBpbXBsLmZuLmNhbGwoc2VsZiwgb3B0cylcblxuICAgIC8vIHBhcnNlIGxheW91dCBhZnRlciBpbml0LiBmbiBtYXkgY2FsY3VsYXRlIGFyZ3MgZm9yIG5lc3RlZCBjdXN0b20gdGFnc1xuICAgIHBhcnNlRXhwcmVzc2lvbnMoZG9tLCBzZWxmLCBleHByZXNzaW9ucylcblxuICAgIC8vIG1vdW50IHRoZSBjaGlsZCB0YWdzXG4gICAgdG9nZ2xlKHRydWUpXG5cbiAgICAvLyB1cGRhdGUgdGhlIHJvb3QgYWRkaW5nIGN1c3RvbSBhdHRyaWJ1dGVzIGNvbWluZyBmcm9tIHRoZSBjb21waWxlclxuICAgIC8vIGl0IGZpeGVzIGFsc28gIzEwODdcbiAgICBpZiAoaW1wbC5hdHRycylcbiAgICAgIHdhbGtBdHRyaWJ1dGVzKGltcGwuYXR0cnMsIGZ1bmN0aW9uIChrLCB2KSB7IHNldEF0dHIocm9vdCwgaywgdikgfSlcbiAgICBpZiAoaW1wbC5hdHRycyB8fCBoYXNJbXBsKVxuICAgICAgcGFyc2VFeHByZXNzaW9ucyhzZWxmLnJvb3QsIHNlbGYsIGV4cHJlc3Npb25zKVxuXG4gICAgaWYgKCFzZWxmLnBhcmVudCB8fCBpc0xvb3ApIHNlbGYudXBkYXRlKGl0ZW0pXG5cbiAgICAvLyBpbnRlcm5hbCB1c2Ugb25seSwgZml4ZXMgIzQwM1xuICAgIHNlbGYudHJpZ2dlcignYmVmb3JlLW1vdW50JylcblxuICAgIGlmIChpc0xvb3AgJiYgIWhhc0ltcGwpIHtcbiAgICAgIC8vIHVwZGF0ZSB0aGUgcm9vdCBhdHRyaWJ1dGUgZm9yIHRoZSBsb29wZWQgZWxlbWVudHNcbiAgICAgIHJvb3QgPSBkb20uZmlyc3RDaGlsZFxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoZG9tLmZpcnN0Q2hpbGQpIHJvb3QuYXBwZW5kQ2hpbGQoZG9tLmZpcnN0Q2hpbGQpXG4gICAgICBpZiAocm9vdC5zdHViKSByb290ID0gcGFyZW50LnJvb3RcbiAgICB9XG5cbiAgICBkZWZpbmVQcm9wZXJ0eShzZWxmLCAncm9vdCcsIHJvb3QpXG5cbiAgICAvLyBwYXJzZSB0aGUgbmFtZWQgZG9tIG5vZGVzIGluIHRoZSBsb29wZWQgY2hpbGRcbiAgICAvLyBhZGRpbmcgdGhlbSB0byB0aGUgcGFyZW50IGFzIHdlbGxcbiAgICBpZiAoaXNMb29wKVxuICAgICAgcGFyc2VOYW1lZEVsZW1lbnRzKHNlbGYucm9vdCwgc2VsZi5wYXJlbnQsIG51bGwsIHRydWUpXG5cbiAgICAvLyBpZiBpdCdzIG5vdCBhIGNoaWxkIHRhZyB3ZSBjYW4gdHJpZ2dlciBpdHMgbW91bnQgZXZlbnRcbiAgICBpZiAoIXNlbGYucGFyZW50IHx8IHNlbGYucGFyZW50LmlzTW91bnRlZCkge1xuICAgICAgc2VsZi5pc01vdW50ZWQgPSB0cnVlXG4gICAgICBzZWxmLnRyaWdnZXIoJ21vdW50JylcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIHdlIG5lZWQgdG8gd2FpdCB0aGF0IHRoZSBwYXJlbnQgZXZlbnQgZ2V0cyB0cmlnZ2VyZWRcbiAgICBlbHNlIHNlbGYucGFyZW50Lm9uZSgnbW91bnQnLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHRvIHRyaWdnZXIgdGhlIGBtb3VudGAgZXZlbnQgZm9yIHRoZSB0YWdzXG4gICAgICAvLyBub3QgdmlzaWJsZSBpbmNsdWRlZCBpbiBhbiBpZiBzdGF0ZW1lbnRcbiAgICAgIGlmICghaXNJblN0dWIoc2VsZi5yb290KSkge1xuICAgICAgICBzZWxmLnBhcmVudC5pc01vdW50ZWQgPSBzZWxmLmlzTW91bnRlZCA9IHRydWVcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdtb3VudCcpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuXG4gIGRlZmluZVByb3BlcnR5KHRoaXMsICd1bm1vdW50JywgZnVuY3Rpb24oa2VlcFJvb3RUYWcpIHtcbiAgICB2YXIgZWwgPSByb290LFxuICAgICAgcCA9IGVsLnBhcmVudE5vZGUsXG4gICAgICBwdGFnLFxuICAgICAgdGFnSW5kZXggPSBfX3ZpcnR1YWxEb20uaW5kZXhPZihzZWxmKVxuXG4gICAgc2VsZi50cmlnZ2VyKCdiZWZvcmUtdW5tb3VudCcpXG5cbiAgICAvLyByZW1vdmUgdGhpcyB0YWcgaW5zdGFuY2UgZnJvbSB0aGUgZ2xvYmFsIHZpcnR1YWxEb20gdmFyaWFibGVcbiAgICBpZiAofnRhZ0luZGV4KVxuICAgICAgX192aXJ0dWFsRG9tLnNwbGljZSh0YWdJbmRleCwgMSlcblxuICAgIGlmIChwKSB7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcHRhZyA9IGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudFRhZyhwYXJlbnQpXG4gICAgICAgIC8vIHJlbW92ZSB0aGlzIHRhZyBmcm9tIHRoZSBwYXJlbnQgdGFncyBvYmplY3RcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG11bHRpcGxlIG5lc3RlZCB0YWdzIHdpdGggc2FtZSBuYW1lLi5cbiAgICAgICAgLy8gcmVtb3ZlIHRoaXMgZWxlbWVudCBmb3JtIHRoZSBhcnJheVxuICAgICAgICBpZiAoaXNBcnJheShwdGFnLnRhZ3NbdGFnTmFtZV0pKVxuICAgICAgICAgIGVhY2gocHRhZy50YWdzW3RhZ05hbWVdLCBmdW5jdGlvbih0YWcsIGkpIHtcbiAgICAgICAgICAgIGlmICh0YWcuX3Jpb3RfaWQgPT0gc2VsZi5fcmlvdF9pZClcbiAgICAgICAgICAgICAgcHRhZy50YWdzW3RhZ05hbWVdLnNwbGljZShpLCAxKVxuICAgICAgICAgIH0pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAvLyBvdGhlcndpc2UganVzdCBkZWxldGUgdGhlIHRhZyBpbnN0YW5jZVxuICAgICAgICAgIHB0YWcudGFnc1t0YWdOYW1lXSA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBlbHNlXG4gICAgICAgIHdoaWxlIChlbC5maXJzdENoaWxkKSBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKVxuXG4gICAgICBpZiAoIWtlZXBSb290VGFnKVxuICAgICAgICBwLnJlbW92ZUNoaWxkKGVsKVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHRoZSByaW90LXRhZyBhbmQgdGhlIGRhdGEtaXMgYXR0cmlidXRlcyBhcmVuJ3QgbmVlZGVkIGFueW1vcmUsIHJlbW92ZSB0aGVtXG4gICAgICAgIHJlbUF0dHIocCwgUklPVF9UQUdfSVMpXG4gICAgICAgIHJlbUF0dHIocCwgUklPVF9UQUcpIC8vIHRoaXMgd2lsbCBiZSByZW1vdmVkIGluIHJpb3QgMy4wLjBcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICh0aGlzLl92aXJ0cykge1xuICAgICAgZWFjaCh0aGlzLl92aXJ0cywgZnVuY3Rpb24odikge1xuICAgICAgICBpZiAodi5wYXJlbnROb2RlKSB2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgc2VsZi50cmlnZ2VyKCd1bm1vdW50JylcbiAgICB0b2dnbGUoKVxuICAgIHNlbGYub2ZmKCcqJylcbiAgICBzZWxmLmlzTW91bnRlZCA9IGZhbHNlXG4gICAgZGVsZXRlIHJvb3QuX3RhZ1xuXG4gIH0pXG5cbiAgLy8gcHJveHkgZnVuY3Rpb24gdG8gYmluZCB1cGRhdGVzXG4gIC8vIGRpc3BhdGNoZWQgZnJvbSBhIHBhcmVudCB0YWdcbiAgZnVuY3Rpb24gb25DaGlsZFVwZGF0ZShkYXRhKSB7IHNlbGYudXBkYXRlKGRhdGEsIHRydWUpIH1cblxuICBmdW5jdGlvbiB0b2dnbGUoaXNNb3VudCkge1xuXG4gICAgLy8gbW91bnQvdW5tb3VudCBjaGlsZHJlblxuICAgIGVhY2goY2hpbGRUYWdzLCBmdW5jdGlvbihjaGlsZCkgeyBjaGlsZFtpc01vdW50ID8gJ21vdW50JyA6ICd1bm1vdW50J10oKSB9KVxuXG4gICAgLy8gbGlzdGVuL3VubGlzdGVuIHBhcmVudCAoZXZlbnRzIGZsb3cgb25lIHdheSBmcm9tIHBhcmVudCB0byBjaGlsZHJlbilcbiAgICBpZiAoIXBhcmVudCkgcmV0dXJuXG4gICAgdmFyIGV2dCA9IGlzTW91bnQgPyAnb24nIDogJ29mZidcblxuICAgIC8vIHRoZSBsb29wIHRhZ3Mgd2lsbCBiZSBhbHdheXMgaW4gc3luYyB3aXRoIHRoZSBwYXJlbnQgYXV0b21hdGljYWxseVxuICAgIGlmIChpc0xvb3ApXG4gICAgICBwYXJlbnRbZXZ0XSgndW5tb3VudCcsIHNlbGYudW5tb3VudClcbiAgICBlbHNlIHtcbiAgICAgIHBhcmVudFtldnRdKCd1cGRhdGUnLCBvbkNoaWxkVXBkYXRlKVtldnRdKCd1bm1vdW50Jywgc2VsZi51bm1vdW50KVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gbmFtZWQgZWxlbWVudHMgYXZhaWxhYmxlIGZvciBmblxuICBwYXJzZU5hbWVkRWxlbWVudHMoZG9tLCB0aGlzLCBjaGlsZFRhZ3MpXG5cbn1cbi8qKlxuICogQXR0YWNoIGFuIGV2ZW50IHRvIGEgRE9NIG5vZGVcbiAqIEBwYXJhbSB7IFN0cmluZyB9IG5hbWUgLSBldmVudCBuYW1lXG4gKiBAcGFyYW0geyBGdW5jdGlvbiB9IGhhbmRsZXIgLSBldmVudCBjYWxsYmFja1xuICogQHBhcmFtIHsgT2JqZWN0IH0gZG9tIC0gZG9tIG5vZGVcbiAqIEBwYXJhbSB7IFRhZyB9IHRhZyAtIHRhZyBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBzZXRFdmVudEhhbmRsZXIobmFtZSwgaGFuZGxlciwgZG9tLCB0YWcpIHtcblxuICBkb21bbmFtZV0gPSBmdW5jdGlvbihlKSB7XG5cbiAgICB2YXIgcHRhZyA9IHRhZy5fcGFyZW50LFxuICAgICAgaXRlbSA9IHRhZy5faXRlbSxcbiAgICAgIGVsXG5cbiAgICBpZiAoIWl0ZW0pXG4gICAgICB3aGlsZSAocHRhZyAmJiAhaXRlbSkge1xuICAgICAgICBpdGVtID0gcHRhZy5faXRlbVxuICAgICAgICBwdGFnID0gcHRhZy5fcGFyZW50XG4gICAgICB9XG5cbiAgICAvLyBjcm9zcyBicm93c2VyIGV2ZW50IGZpeFxuICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudFxuXG4gICAgLy8gb3ZlcnJpZGUgdGhlIGV2ZW50IHByb3BlcnRpZXNcbiAgICBpZiAoaXNXcml0YWJsZShlLCAnY3VycmVudFRhcmdldCcpKSBlLmN1cnJlbnRUYXJnZXQgPSBkb21cbiAgICBpZiAoaXNXcml0YWJsZShlLCAndGFyZ2V0JykpIGUudGFyZ2V0ID0gZS5zcmNFbGVtZW50XG4gICAgaWYgKGlzV3JpdGFibGUoZSwgJ3doaWNoJykpIGUud2hpY2ggPSBlLmNoYXJDb2RlIHx8IGUua2V5Q29kZVxuXG4gICAgZS5pdGVtID0gaXRlbVxuXG4gICAgLy8gcHJldmVudCBkZWZhdWx0IGJlaGF2aW91ciAoYnkgZGVmYXVsdClcbiAgICBpZiAoaGFuZGxlci5jYWxsKHRhZywgZSkgIT09IHRydWUgJiYgIS9yYWRpb3xjaGVjay8udGVzdChkb20udHlwZSkpIHtcbiAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICghZS5wcmV2ZW50VXBkYXRlKSB7XG4gICAgICBlbCA9IGl0ZW0gPyBnZXRJbW1lZGlhdGVDdXN0b21QYXJlbnRUYWcocHRhZykgOiB0YWdcbiAgICAgIGVsLnVwZGF0ZSgpXG4gICAgfVxuXG4gIH1cblxufVxuXG5cbi8qKlxuICogSW5zZXJ0IGEgRE9NIG5vZGUgcmVwbGFjaW5nIGFub3RoZXIgb25lICh1c2VkIGJ5IGlmLSBhdHRyaWJ1dGUpXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IHJvb3QgLSBwYXJlbnQgbm9kZVxuICogQHBhcmFtICAgeyBPYmplY3QgfSBub2RlIC0gbm9kZSByZXBsYWNlZFxuICogQHBhcmFtICAgeyBPYmplY3QgfSBiZWZvcmUgLSBub2RlIGFkZGVkXG4gKi9cbmZ1bmN0aW9uIGluc2VydFRvKHJvb3QsIG5vZGUsIGJlZm9yZSkge1xuICBpZiAoIXJvb3QpIHJldHVyblxuICByb290Lmluc2VydEJlZm9yZShiZWZvcmUsIG5vZGUpXG4gIHJvb3QucmVtb3ZlQ2hpbGQobm9kZSlcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGV4cHJlc3Npb25zIGluIGEgVGFnIGluc3RhbmNlXG4gKiBAcGFyYW0gICB7IEFycmF5IH0gZXhwcmVzc2lvbnMgLSBleHByZXNzaW9uIHRoYXQgbXVzdCBiZSByZSBldmFsdWF0ZWRcbiAqIEBwYXJhbSAgIHsgVGFnIH0gdGFnIC0gdGFnIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZShleHByZXNzaW9ucywgdGFnKSB7XG5cbiAgZWFjaChleHByZXNzaW9ucywgZnVuY3Rpb24oZXhwciwgaSkge1xuXG4gICAgdmFyIGRvbSA9IGV4cHIuZG9tLFxuICAgICAgYXR0ck5hbWUgPSBleHByLmF0dHIsXG4gICAgICB2YWx1ZSA9IHRtcGwoZXhwci5leHByLCB0YWcpLFxuICAgICAgcGFyZW50ID0gZXhwci5wYXJlbnQgfHwgZXhwci5kb20ucGFyZW50Tm9kZVxuXG4gICAgaWYgKGV4cHIuYm9vbCkge1xuICAgICAgdmFsdWUgPSAhIXZhbHVlXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9ICcnXG4gICAgfVxuXG4gICAgLy8gIzE2Mzg6IHJlZ3Jlc3Npb24gb2YgIzE2MTIsIHVwZGF0ZSB0aGUgZG9tIG9ubHkgaWYgdGhlIHZhbHVlIG9mIHRoZVxuICAgIC8vIGV4cHJlc3Npb24gd2FzIGNoYW5nZWRcbiAgICBpZiAoZXhwci52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBleHByLnZhbHVlID0gdmFsdWVcblxuICAgIC8vIHRleHRhcmVhIGFuZCB0ZXh0IG5vZGVzIGhhcyBubyBhdHRyaWJ1dGUgbmFtZVxuICAgIGlmICghYXR0ck5hbWUpIHtcbiAgICAgIC8vIGFib3V0ICM4MTUgdy9vIHJlcGxhY2U6IHRoZSBicm93c2VyIGNvbnZlcnRzIHRoZSB2YWx1ZSB0byBhIHN0cmluZyxcbiAgICAgIC8vIHRoZSBjb21wYXJpc29uIGJ5IFwiPT1cIiBkb2VzIHRvbywgYnV0IG5vdCBpbiB0aGUgc2VydmVyXG4gICAgICB2YWx1ZSArPSAnJ1xuICAgICAgLy8gdGVzdCBmb3IgcGFyZW50IGF2b2lkcyBlcnJvciB3aXRoIGludmFsaWQgYXNzaWdubWVudCB0byBub2RlVmFsdWVcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgLy8gY2FjaGUgdGhlIHBhcmVudCBub2RlIGJlY2F1c2Ugc29tZWhvdyBpdCB3aWxsIGJlY29tZSBudWxsIG9uIElFXG4gICAgICAgIC8vIG9uIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICBleHByLnBhcmVudCA9IHBhcmVudFxuICAgICAgICBpZiAocGFyZW50LnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgICBwYXJlbnQudmFsdWUgPSB2YWx1ZSAgICAgICAgICAgICAgICAgICAgLy8gIzExMTNcbiAgICAgICAgICBpZiAoIUlFX1ZFUlNJT04pIGRvbS5ub2RlVmFsdWUgPSB2YWx1ZSAgLy8gIzE2MjUgSUUgdGhyb3dzIGhlcmUsIG5vZGVWYWx1ZVxuICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIGF2YWlsYWJsZSBvbiAndXBkYXRlZCdcbiAgICAgICAgZWxzZSBkb20ubm9kZVZhbHVlID0gdmFsdWVcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIH5+IzE2MTI6IGxvb2sgZm9yIGNoYW5nZXMgaW4gZG9tLnZhbHVlIHdoZW4gdXBkYXRpbmcgdGhlIHZhbHVlfn5cbiAgICBpZiAoYXR0ck5hbWUgPT09ICd2YWx1ZScpIHtcbiAgICAgIGlmIChkb20udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIGRvbS52YWx1ZSA9IHZhbHVlXG4gICAgICAgIHNldEF0dHIoZG9tLCBhdHRyTmFtZSwgdmFsdWUpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIG9yaWdpbmFsIGF0dHJpYnV0ZVxuICAgICAgcmVtQXR0cihkb20sIGF0dHJOYW1lKVxuICAgIH1cblxuICAgIC8vIGV2ZW50IGhhbmRsZXJcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHNldEV2ZW50SGFuZGxlcihhdHRyTmFtZSwgdmFsdWUsIGRvbSwgdGFnKVxuXG4gICAgLy8gaWYtIGNvbmRpdGlvbmFsXG4gICAgfSBlbHNlIGlmIChhdHRyTmFtZSA9PSAnaWYnKSB7XG4gICAgICB2YXIgc3R1YiA9IGV4cHIuc3R1YixcbiAgICAgICAgYWRkID0gZnVuY3Rpb24oKSB7IGluc2VydFRvKHN0dWIucGFyZW50Tm9kZSwgc3R1YiwgZG9tKSB9LFxuICAgICAgICByZW1vdmUgPSBmdW5jdGlvbigpIHsgaW5zZXJ0VG8oZG9tLnBhcmVudE5vZGUsIGRvbSwgc3R1YikgfVxuXG4gICAgICAvLyBhZGQgdG8gRE9NXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHN0dWIpIHtcbiAgICAgICAgICBhZGQoKVxuICAgICAgICAgIGRvbS5pblN0dWIgPSBmYWxzZVxuICAgICAgICAgIC8vIGF2b2lkIHRvIHRyaWdnZXIgdGhlIG1vdW50IGV2ZW50IGlmIHRoZSB0YWdzIGlzIG5vdCB2aXNpYmxlIHlldFxuICAgICAgICAgIC8vIG1heWJlIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIGF2b2lkaW5nIHRvIG1vdW50IHRoZSB0YWcgYXQgYWxsXG4gICAgICAgICAgaWYgKCFpc0luU3R1Yihkb20pKSB7XG4gICAgICAgICAgICB3YWxrKGRvbSwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgaWYgKGVsLl90YWcgJiYgIWVsLl90YWcuaXNNb3VudGVkKVxuICAgICAgICAgICAgICAgIGVsLl90YWcuaXNNb3VudGVkID0gISFlbC5fdGFnLnRyaWdnZXIoJ21vdW50JylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAvLyByZW1vdmUgZnJvbSBET01cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0dWIgPSBleHByLnN0dWIgPSBzdHViIHx8IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKVxuICAgICAgICAvLyBpZiB0aGUgcGFyZW50Tm9kZSBpcyBkZWZpbmVkIHdlIGNhbiBlYXNpbHkgcmVwbGFjZSB0aGUgdGFnXG4gICAgICAgIGlmIChkb20ucGFyZW50Tm9kZSlcbiAgICAgICAgICByZW1vdmUoKVxuICAgICAgICAvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byB3YWl0IHRoZSB1cGRhdGVkIGV2ZW50XG4gICAgICAgIGVsc2UgKHRhZy5wYXJlbnQgfHwgdGFnKS5vbmUoJ3VwZGF0ZWQnLCByZW1vdmUpXG5cbiAgICAgICAgZG9tLmluU3R1YiA9IHRydWVcbiAgICAgIH1cbiAgICAvLyBzaG93IC8gaGlkZVxuICAgIH0gZWxzZSBpZiAoYXR0ck5hbWUgPT09ICdzaG93Jykge1xuICAgICAgZG9tLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/ICcnIDogJ25vbmUnXG5cbiAgICB9IGVsc2UgaWYgKGF0dHJOYW1lID09PSAnaGlkZScpIHtcbiAgICAgIGRvbS5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyAnbm9uZScgOiAnJ1xuXG4gICAgfSBlbHNlIGlmIChleHByLmJvb2wpIHtcbiAgICAgIGRvbVthdHRyTmFtZV0gPSB2YWx1ZVxuICAgICAgaWYgKHZhbHVlKSBzZXRBdHRyKGRvbSwgYXR0ck5hbWUsIGF0dHJOYW1lKVxuICAgICAgaWYgKEZJUkVGT1ggJiYgYXR0ck5hbWUgPT09ICdzZWxlY3RlZCcgJiYgZG9tLnRhZ05hbWUgPT09ICdPUFRJT04nKSB7XG4gICAgICAgIGRvbS5fX3Jpb3QxMzc0ID0gdmFsdWUgICAvLyAjMTM3NFxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMCB8fCB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgIT09IFRfT0JKRUNUKSB7XG4gICAgICAvLyA8aW1nIHNyYz1cInsgZXhwciB9XCI+XG4gICAgICBpZiAoc3RhcnRzV2l0aChhdHRyTmFtZSwgUklPVF9QUkVGSVgpICYmIGF0dHJOYW1lICE9IFJJT1RfVEFHKSB7XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ck5hbWUuc2xpY2UoUklPVF9QUkVGSVgubGVuZ3RoKVxuICAgICAgfVxuICAgICAgc2V0QXR0cihkb20sIGF0dHJOYW1lLCB2YWx1ZSlcbiAgICB9XG5cbiAgfSlcblxufVxuLyoqXG4gKiBTcGVjaWFsaXplZCBmdW5jdGlvbiBmb3IgbG9vcGluZyBhbiBhcnJheS1saWtlIGNvbGxlY3Rpb24gd2l0aCBgZWFjaD17fWBcbiAqIEBwYXJhbSAgIHsgQXJyYXkgfSBlbHMgLSBjb2xsZWN0aW9uIG9mIGl0ZW1zXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHsgQXJyYXkgfSB0aGUgYXJyYXkgbG9vcGVkXG4gKi9cbmZ1bmN0aW9uIGVhY2goZWxzLCBmbikge1xuICB2YXIgbGVuID0gZWxzID8gZWxzLmxlbmd0aCA6IDBcblxuICBmb3IgKHZhciBpID0gMCwgZWw7IGkgPCBsZW47IGkrKykge1xuICAgIGVsID0gZWxzW2ldXG4gICAgLy8gcmV0dXJuIGZhbHNlIC0+IGN1cnJlbnQgaXRlbSB3YXMgcmVtb3ZlZCBieSBmbiBkdXJpbmcgdGhlIGxvb3BcbiAgICBpZiAoZWwgIT0gbnVsbCAmJiBmbihlbCwgaSkgPT09IGZhbHNlKSBpLS1cbiAgfVxuICByZXR1cm4gZWxzXG59XG5cbi8qKlxuICogRGV0ZWN0IGlmIHRoZSBhcmd1bWVudCBwYXNzZWQgaXMgYSBmdW5jdGlvblxuICogQHBhcmFtICAgeyAqIH0gdiAtIHdoYXRldmVyIHlvdSB3YW50IHRvIHBhc3MgdG8gdGhpcyBmdW5jdGlvblxuICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBUX0ZVTkNUSU9OIHx8IGZhbHNlICAgLy8gYXZvaWQgSUUgcHJvYmxlbXNcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG91dGVyIGh0bWwgb2YgYW55IERPTSBub2RlIFNWR3MgaW5jbHVkZWRcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZWwgLSBET00gbm9kZSB0byBwYXJzZVxuICogQHJldHVybnMgeyBTdHJpbmcgfSBlbC5vdXRlckhUTUxcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHJldHVybiBlbC5vdXRlckhUTUxcbiAgLy8gc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBvdXRlckhUTUwgb24gdGhlIFNWR3MgdGFnc1xuICBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gbWtFbCgnZGl2JylcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKVxuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgdGhlIGlubmVyIGh0bWwgb2YgYW55IERPTSBub2RlIFNWR3MgaW5jbHVkZWRcbiAqIEBwYXJhbSB7IE9iamVjdCB9IGNvbnRhaW5lciAtIERPTSBub2RlIHdoZXJlIHdlIHdpbGwgaW5qZWN0IHRoZSBuZXcgaHRtbFxuICogQHBhcmFtIHsgU3RyaW5nIH0gaHRtbCAtIGh0bWwgdG8gaW5qZWN0XG4gKi9cbmZ1bmN0aW9uIHNldElubmVySFRNTChjb250YWluZXIsIGh0bWwpIHtcbiAgaWYgKHR5cGVvZiBjb250YWluZXIuaW5uZXJIVE1MICE9IFRfVU5ERUYpIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sXG4gIC8vIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgaW5uZXJIVE1MIG9uIHRoZSBTVkdzIHRhZ3NcbiAgZWxzZSB7XG4gICAgdmFyIGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoaHRtbCwgJ2FwcGxpY2F0aW9uL3htbCcpXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKFxuICAgICAgY29udGFpbmVyLm93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShkb2MuZG9jdW1lbnRFbGVtZW50LCB0cnVlKVxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyB3ZXRoZXIgYSBET00gbm9kZSBtdXN0IGJlIGNvbnNpZGVyZWQgcGFydCBvZiBhbiBzdmcgZG9jdW1lbnRcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gIG5hbWUgLSB0YWcgbmFtZVxuICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICovXG5mdW5jdGlvbiBpc1NWR1RhZyhuYW1lKSB7XG4gIHJldHVybiB+U1ZHX1RBR1NfTElTVC5pbmRleE9mKG5hbWUpXG59XG5cbi8qKlxuICogRGV0ZWN0IGlmIHRoZSBhcmd1bWVudCBwYXNzZWQgaXMgYW4gb2JqZWN0LCBleGNsdWRlIG51bGwuXG4gKiBOT1RFOiBVc2UgaXNPYmplY3QoeCkgJiYgIWlzQXJyYXkoeCkgdG8gZXhjbHVkZXMgYXJyYXlzLlxuICogQHBhcmFtICAgeyAqIH0gdiAtIHdoYXRldmVyIHlvdSB3YW50IHRvIHBhc3MgdG8gdGhpcyBmdW5jdGlvblxuICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2KSB7XG4gIHJldHVybiB2ICYmIHR5cGVvZiB2ID09PSBUX09CSkVDVCAgICAgICAgIC8vIHR5cGVvZiBudWxsIGlzICdvYmplY3QnXG59XG5cbi8qKlxuICogUmVtb3ZlIGFueSBET00gYXR0cmlidXRlIGZyb20gYSBub2RlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIHdhbnQgdG8gdXBkYXRlXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IG5hbWUgLSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSB3YW50IHRvIHJlbW92ZVxuICovXG5mdW5jdGlvbiByZW1BdHRyKGRvbSwgbmFtZSkge1xuICBkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpXG59XG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyBjb250YWluaW5nIGRhc2hlcyB0byBjYW1lbCBjYXNlXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IHN0cmluZyAtIGlucHV0IHN0cmluZ1xuICogQHJldHVybnMgeyBTdHJpbmcgfSBteS1zdHJpbmcgLT4gbXlTdHJpbmdcbiAqL1xuZnVuY3Rpb24gdG9DYW1lbChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8tKFxcdykvZywgZnVuY3Rpb24oXywgYykge1xuICAgIHJldHVybiBjLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGFueSBET00gYXR0cmlidXRlIG9uIGEgbm9kZVxuICogQHBhcmFtICAgeyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSB3YW50IHRvIHBhcnNlXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IG5hbWUgLSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgd2Ugd2FudCB0byBnZXRcbiAqIEByZXR1cm5zIHsgU3RyaW5nIHwgdW5kZWZpbmVkIH0gbmFtZSBvZiB0aGUgbm9kZSBhdHRyaWJ1dGUgd2hldGhlciBpdCBleGlzdHNcbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cihkb20sIG5hbWUpIHtcbiAgcmV0dXJuIGRvbS5nZXRBdHRyaWJ1dGUobmFtZSlcbn1cblxuLyoqXG4gKiBTZXQgYW55IERPTS9TVkcgYXR0cmlidXRlXG4gKiBAcGFyYW0geyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSB3YW50IHRvIHVwZGF0ZVxuICogQHBhcmFtIHsgU3RyaW5nIH0gbmFtZSAtIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIHdhbnQgdG8gc2V0XG4gKiBAcGFyYW0geyBTdHJpbmcgfSB2YWwgLSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgd2Ugd2FudCB0byBzZXRcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cihkb20sIG5hbWUsIHZhbCkge1xuICB2YXIgeGxpbmsgPSBYTElOS19SRUdFWC5leGVjKG5hbWUpXG4gIGlmICh4bGluayAmJiB4bGlua1sxXSlcbiAgICBkb20uc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIHhsaW5rWzFdLCB2YWwpXG4gIGVsc2VcbiAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIHZhbClcbn1cblxuLyoqXG4gKiBEZXRlY3QgdGhlIHRhZyBpbXBsZW1lbnRhdGlvbiBieSBhIERPTSBub2RlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIG5lZWQgdG8gcGFyc2UgdG8gZ2V0IGl0cyB0YWcgaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm5zIHsgT2JqZWN0IH0gaXQgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgaW1wbGVtZW50YXRpb24gb2YgYSBjdXN0b20gdGFnICh0ZW1wbGF0ZSBhbmQgYm9vdCBmdW5jdGlvbilcbiAqL1xuZnVuY3Rpb24gZ2V0VGFnKGRvbSkge1xuICByZXR1cm4gZG9tLnRhZ05hbWUgJiYgX190YWdJbXBsW2dldEF0dHIoZG9tLCBSSU9UX1RBR19JUykgfHxcbiAgICBnZXRBdHRyKGRvbSwgUklPVF9UQUcpIHx8IGRvbS50YWdOYW1lLnRvTG93ZXJDYXNlKCldXG59XG4vKipcbiAqIEFkZCBhIGNoaWxkIHRhZyB0byBpdHMgcGFyZW50IGludG8gdGhlIGB0YWdzYCBvYmplY3RcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gdGFnIC0gY2hpbGQgdGFnIGluc3RhbmNlXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IHRhZ05hbWUgLSBrZXkgd2hlcmUgdGhlIG5ldyB0YWcgd2lsbCBiZSBzdG9yZWRcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gcGFyZW50IC0gdGFnIGluc3RhbmNlIHdoZXJlIHRoZSBuZXcgY2hpbGQgdGFnIHdpbGwgYmUgaW5jbHVkZWRcbiAqL1xuZnVuY3Rpb24gYWRkQ2hpbGRUYWcodGFnLCB0YWdOYW1lLCBwYXJlbnQpIHtcbiAgdmFyIGNhY2hlZFRhZyA9IHBhcmVudC50YWdzW3RhZ05hbWVdXG5cbiAgLy8gaWYgdGhlcmUgYXJlIG11bHRpcGxlIGNoaWxkcmVuIHRhZ3MgaGF2aW5nIHRoZSBzYW1lIG5hbWVcbiAgaWYgKGNhY2hlZFRhZykge1xuICAgIC8vIGlmIHRoZSBwYXJlbnQgdGFncyBwcm9wZXJ0eSBpcyBub3QgeWV0IGFuIGFycmF5XG4gICAgLy8gY3JlYXRlIGl0IGFkZGluZyB0aGUgZmlyc3QgY2FjaGVkIHRhZ1xuICAgIGlmICghaXNBcnJheShjYWNoZWRUYWcpKVxuICAgICAgLy8gZG9uJ3QgYWRkIHRoZSBzYW1lIHRhZyB0d2ljZVxuICAgICAgaWYgKGNhY2hlZFRhZyAhPT0gdGFnKVxuICAgICAgICBwYXJlbnQudGFnc1t0YWdOYW1lXSA9IFtjYWNoZWRUYWddXG4gICAgLy8gYWRkIHRoZSBuZXcgbmVzdGVkIHRhZyB0byB0aGUgYXJyYXlcbiAgICBpZiAoIWNvbnRhaW5zKHBhcmVudC50YWdzW3RhZ05hbWVdLCB0YWcpKVxuICAgICAgcGFyZW50LnRhZ3NbdGFnTmFtZV0ucHVzaCh0YWcpXG4gIH0gZWxzZSB7XG4gICAgcGFyZW50LnRhZ3NbdGFnTmFtZV0gPSB0YWdcbiAgfVxufVxuXG4vKipcbiAqIE1vdmUgdGhlIHBvc2l0aW9uIG9mIGEgY3VzdG9tIHRhZyBpbiBpdHMgcGFyZW50IHRhZ1xuICogQHBhcmFtICAgeyBPYmplY3QgfSB0YWcgLSBjaGlsZCB0YWcgaW5zdGFuY2VcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdGFnTmFtZSAtIGtleSB3aGVyZSB0aGUgdGFnIHdhcyBzdG9yZWRcbiAqIEBwYXJhbSAgIHsgTnVtYmVyIH0gbmV3UG9zIC0gaW5kZXggd2hlcmUgdGhlIG5ldyB0YWcgd2lsbCBiZSBzdG9yZWRcbiAqL1xuZnVuY3Rpb24gbW92ZUNoaWxkVGFnKHRhZywgdGFnTmFtZSwgbmV3UG9zKSB7XG4gIHZhciBwYXJlbnQgPSB0YWcucGFyZW50LFxuICAgIHRhZ3NcbiAgLy8gbm8gcGFyZW50IG5vIG1vdmVcbiAgaWYgKCFwYXJlbnQpIHJldHVyblxuXG4gIHRhZ3MgPSBwYXJlbnQudGFnc1t0YWdOYW1lXVxuXG4gIGlmIChpc0FycmF5KHRhZ3MpKVxuICAgIHRhZ3Muc3BsaWNlKG5ld1BvcywgMCwgdGFncy5zcGxpY2UodGFncy5pbmRleE9mKHRhZyksIDEpWzBdKVxuICBlbHNlIGFkZENoaWxkVGFnKHRhZywgdGFnTmFtZSwgcGFyZW50KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjaGlsZCB0YWcgaW5jbHVkaW5nIGl0IGNvcnJlY3RseSBpbnRvIGl0cyBwYXJlbnRcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gY2hpbGQgLSBjaGlsZCB0YWcgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gb3B0cyAtIHRhZyBvcHRpb25zIGNvbnRhaW5pbmcgdGhlIERPTSBub2RlIHdoZXJlIHRoZSB0YWcgd2lsbCBiZSBtb3VudGVkXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IGlubmVySFRNTCAtIGlubmVyIGh0bWwgb2YgdGhlIGNoaWxkIG5vZGVcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gcGFyZW50IC0gaW5zdGFuY2Ugb2YgdGhlIHBhcmVudCB0YWcgaW5jbHVkaW5nIHRoZSBjaGlsZCBjdXN0b20gdGFnXG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IGluc3RhbmNlIG9mIHRoZSBuZXcgY2hpbGQgdGFnIGp1c3QgY3JlYXRlZFxuICovXG5mdW5jdGlvbiBpbml0Q2hpbGRUYWcoY2hpbGQsIG9wdHMsIGlubmVySFRNTCwgcGFyZW50KSB7XG4gIHZhciB0YWcgPSBuZXcgVGFnKGNoaWxkLCBvcHRzLCBpbm5lckhUTUwpLFxuICAgIHRhZ05hbWUgPSBnZXRUYWdOYW1lKG9wdHMucm9vdCksXG4gICAgcHRhZyA9IGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudFRhZyhwYXJlbnQpXG4gIC8vIGZpeCBmb3IgdGhlIHBhcmVudCBhdHRyaWJ1dGUgaW4gdGhlIGxvb3BlZCBlbGVtZW50c1xuICB0YWcucGFyZW50ID0gcHRhZ1xuICAvLyBzdG9yZSB0aGUgcmVhbCBwYXJlbnQgdGFnXG4gIC8vIGluIHNvbWUgY2FzZXMgdGhpcyBjb3VsZCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgY3VzdG9tIHBhcmVudCB0YWdcbiAgLy8gZm9yIGV4YW1wbGUgaW4gbmVzdGVkIGxvb3BzXG4gIHRhZy5fcGFyZW50ID0gcGFyZW50XG5cbiAgLy8gYWRkIHRoaXMgdGFnIHRvIHRoZSBjdXN0b20gcGFyZW50IHRhZ1xuICBhZGRDaGlsZFRhZyh0YWcsIHRhZ05hbWUsIHB0YWcpXG4gIC8vIGFuZCBhbHNvIHRvIHRoZSByZWFsIHBhcmVudCB0YWdcbiAgaWYgKHB0YWcgIT09IHBhcmVudClcbiAgICBhZGRDaGlsZFRhZyh0YWcsIHRhZ05hbWUsIHBhcmVudClcbiAgLy8gZW1wdHkgdGhlIGNoaWxkIG5vZGUgb25jZSB3ZSBnb3QgaXRzIHRlbXBsYXRlXG4gIC8vIHRvIGF2b2lkIHRoYXQgaXRzIGNoaWxkcmVuIGdldCBjb21waWxlZCBtdWx0aXBsZSB0aW1lc1xuICBvcHRzLnJvb3QuaW5uZXJIVE1MID0gJydcblxuICByZXR1cm4gdGFnXG59XG5cbi8qKlxuICogTG9vcCBiYWNrd2FyZCBhbGwgdGhlIHBhcmVudHMgdHJlZSB0byBkZXRlY3QgdGhlIGZpcnN0IGN1c3RvbSBwYXJlbnQgdGFnXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IHRhZyAtIGEgVGFnIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IHRoZSBpbnN0YW5jZSBvZiB0aGUgZmlyc3QgY3VzdG9tIHBhcmVudCB0YWcgZm91bmRcbiAqL1xuZnVuY3Rpb24gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50VGFnKHRhZykge1xuICB2YXIgcHRhZyA9IHRhZ1xuICB3aGlsZSAoIWdldFRhZyhwdGFnLnJvb3QpKSB7XG4gICAgaWYgKCFwdGFnLnBhcmVudCkgYnJlYWtcbiAgICBwdGFnID0gcHRhZy5wYXJlbnRcbiAgfVxuICByZXR1cm4gcHRhZ1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBzZXQgYW4gaW1tdXRhYmxlIHByb3BlcnR5XG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGVsIC0gb2JqZWN0IHdoZXJlIHRoZSBuZXcgcHJvcGVydHkgd2lsbCBiZSBzZXRcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0ga2V5IC0gb2JqZWN0IGtleSB3aGVyZSB0aGUgbmV3IHByb3BlcnR5IHdpbGwgYmUgc3RvcmVkXG4gKiBAcGFyYW0gICB7ICogfSB2YWx1ZSAtIHZhbHVlIG9mIHRoZSBuZXcgcHJvcGVydHlcbiogQHBhcmFtICAgeyBPYmplY3QgfSBvcHRpb25zIC0gc2V0IHRoZSBwcm9wZXJ5IG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICogQHJldHVybnMgeyBPYmplY3QgfSAtIHRoZSBpbml0aWFsIG9iamVjdFxuICovXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShlbCwga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsIGtleSwgZXh0ZW5kKHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LCBvcHRpb25zKSlcbiAgcmV0dXJuIGVsXG59XG5cbi8qKlxuICogR2V0IHRoZSB0YWcgbmFtZSBvZiBhbnkgRE9NIG5vZGVcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZG9tIC0gRE9NIG5vZGUgd2Ugd2FudCB0byBwYXJzZVxuICogQHJldHVybnMgeyBTdHJpbmcgfSBuYW1lIHRvIGlkZW50aWZ5IHRoaXMgZG9tIG5vZGUgaW4gcmlvdFxuICovXG5mdW5jdGlvbiBnZXRUYWdOYW1lKGRvbSkge1xuICB2YXIgY2hpbGQgPSBnZXRUYWcoZG9tKSxcbiAgICBuYW1lZFRhZyA9IGdldEF0dHIoZG9tLCAnbmFtZScpLFxuICAgIHRhZ05hbWUgPSBuYW1lZFRhZyAmJiAhdG1wbC5oYXNFeHByKG5hbWVkVGFnKSA/XG4gICAgICAgICAgICAgICAgbmFtZWRUYWcgOlxuICAgICAgICAgICAgICBjaGlsZCA/IGNoaWxkLm5hbWUgOiBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgcmV0dXJuIHRhZ05hbWVcbn1cblxuLyoqXG4gKiBFeHRlbmQgYW55IG9iamVjdCB3aXRoIG90aGVyIHByb3BlcnRpZXNcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gc3JjIC0gc291cmNlIG9iamVjdFxuICogQHJldHVybnMgeyBPYmplY3QgfSB0aGUgcmVzdWx0aW5nIGV4dGVuZGVkIG9iamVjdFxuICpcbiAqIHZhciBvYmogPSB7IGZvbzogJ2JheicgfVxuICogZXh0ZW5kKG9iaiwge2JhcjogJ2JhcicsIGZvbzogJ2Jhcid9KVxuICogY29uc29sZS5sb2cob2JqKSA9PiB7YmFyOiAnYmFyJywgZm9vOiAnYmFyJ31cbiAqXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChzcmMpIHtcbiAgdmFyIG9iaiwgYXJncyA9IGFyZ3VtZW50c1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAob2JqID0gYXJnc1tpXSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIHByb3BlcnR5IG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGNvdWxkIGJlIG92ZXJyaWRkZW5cbiAgICAgICAgaWYgKGlzV3JpdGFibGUoc3JjLCBrZXkpKVxuICAgICAgICAgIHNyY1trZXldID0gb2JqW2tleV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNyY1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gYXJyYXkgY29udGFpbnMgYW4gaXRlbVxuICogQHBhcmFtICAgeyBBcnJheSB9IGFyciAtIHRhcmdldCBhcnJheVxuICogQHBhcmFtICAgeyAqIH0gaXRlbSAtIGl0ZW0gdG8gdGVzdFxuICogQHJldHVybnMgeyBCb29sZWFuIH0gRG9lcyAnYXJyJyBjb250YWluICdpdGVtJz9cbiAqL1xuZnVuY3Rpb24gY29udGFpbnMoYXJyLCBpdGVtKSB7XG4gIHJldHVybiB+YXJyLmluZGV4T2YoaXRlbSlcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBpcyBhIGtpbmQgb2YgYXJyYXlcbiAqIEBwYXJhbSAgIHsgKiB9IGEgLSBhbnl0aGluZ1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzICdhJyBhbiBhcnJheT9cbiAqL1xuZnVuY3Rpb24gaXNBcnJheShhKSB7IHJldHVybiBBcnJheS5pc0FycmF5KGEpIHx8IGEgaW5zdGFuY2VvZiBBcnJheSB9XG5cbi8qKlxuICogRGV0ZWN0IHdoZXRoZXIgYSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgY291bGQgYmUgb3ZlcnJpZGRlblxuICogQHBhcmFtICAgeyBPYmplY3QgfSAgb2JqIC0gc291cmNlIG9iamVjdFxuICogQHBhcmFtICAgeyBTdHJpbmcgfSAga2V5IC0gb2JqZWN0IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7IEJvb2xlYW4gfSBpcyB0aGlzIHByb3BlcnR5IHdyaXRhYmxlP1xuICovXG5mdW5jdGlvbiBpc1dyaXRhYmxlKG9iaiwga2V5KSB7XG4gIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpXG4gIHJldHVybiB0eXBlb2Ygb2JqW2tleV0gPT09IFRfVU5ERUYgfHwgcHJvcHMgJiYgcHJvcHMud3JpdGFibGVcbn1cblxuXG4vKipcbiAqIFdpdGggdGhpcyBmdW5jdGlvbiB3ZSBhdm9pZCB0aGF0IHRoZSBpbnRlcm5hbCBUYWcgbWV0aG9kcyBnZXQgb3ZlcnJpZGRlblxuICogQHBhcmFtICAgeyBPYmplY3QgfSBkYXRhIC0gb3B0aW9ucyB3ZSB3YW50IHRvIHVzZSB0byBleHRlbmQgdGhlIHRhZyBpbnN0YW5jZVxuICogQHJldHVybnMgeyBPYmplY3QgfSBjbGVhbiBvYmplY3Qgd2l0aG91dCBjb250YWluaW5nIHRoZSByaW90IGludGVybmFsIHJlc2VydmVkIHdvcmRzXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXBEYXRhKGRhdGEpIHtcbiAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFRhZykgJiYgIShkYXRhICYmIHR5cGVvZiBkYXRhLnRyaWdnZXIgPT0gVF9GVU5DVElPTikpXG4gICAgcmV0dXJuIGRhdGFcblxuICB2YXIgbyA9IHt9XG4gIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgaWYgKCFSRVNFUlZFRF9XT1JEU19CTEFDS0xJU1QudGVzdChrZXkpKSBvW2tleV0gPSBkYXRhW2tleV1cbiAgfVxuICByZXR1cm4gb1xufVxuXG4vKipcbiAqIFdhbGsgZG93biByZWN1cnNpdmVseSBhbGwgdGhlIGNoaWxkcmVuIHRhZ3Mgc3RhcnRpbmcgZG9tIG5vZGVcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gICBkb20gLSBzdGFydGluZyBub2RlIHdoZXJlIHdlIHdpbGwgc3RhcnQgdGhlIHJlY3Vyc2lvblxuICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgdG8gdHJhbnNmb3JtIHRoZSBjaGlsZCBub2RlIGp1c3QgZm91bmRcbiAqL1xuZnVuY3Rpb24gd2Fsayhkb20sIGZuKSB7XG4gIGlmIChkb20pIHtcbiAgICAvLyBzdG9wIHRoZSByZWN1cnNpb25cbiAgICBpZiAoZm4oZG9tKSA9PT0gZmFsc2UpIHJldHVyblxuICAgIGVsc2Uge1xuICAgICAgZG9tID0gZG9tLmZpcnN0Q2hpbGRcblxuICAgICAgd2hpbGUgKGRvbSkge1xuICAgICAgICB3YWxrKGRvbSwgZm4pXG4gICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZ1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1pbmltaXplIHJpc2s6IG9ubHkgemVybyBvciBvbmUgX3NwYWNlXyBiZXR3ZWVuIGF0dHIgJiB2YWx1ZVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGh0bWwgLSBodG1sIHN0cmluZyB3ZSB3YW50IHRvIHBhcnNlXG4gKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSBjYWxsYmFjayBmdW5jdGlvbiB0byBhcHBseSBvbiBhbnkgYXR0cmlidXRlIGZvdW5kXG4gKi9cbmZ1bmN0aW9uIHdhbGtBdHRyaWJ1dGVzKGh0bWwsIGZuKSB7XG4gIHZhciBtLFxuICAgIHJlID0gLyhbLVxcd10rKSA/PSA/KD86XCIoW15cIl0qKXwnKFteJ10qKXwoe1tefV0qfSkpL2dcblxuICB3aGlsZSAobSA9IHJlLmV4ZWMoaHRtbCkpIHtcbiAgICBmbihtWzFdLnRvTG93ZXJDYXNlKCksIG1bMl0gfHwgbVszXSB8fCBtWzRdKVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIERPTSBub2RlIGlzIGluIHN0dWIgbW9kZSwgdXNlZnVsIGZvciB0aGUgcmlvdCAnaWYnIGRpcmVjdGl2ZVxuICogQHBhcmFtICAgeyBPYmplY3QgfSAgZG9tIC0gRE9NIG5vZGUgd2Ugd2FudCB0byBwYXJzZVxuICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICovXG5mdW5jdGlvbiBpc0luU3R1Yihkb20pIHtcbiAgd2hpbGUgKGRvbSkge1xuICAgIGlmIChkb20uaW5TdHViKSByZXR1cm4gdHJ1ZVxuICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZ2VuZXJpYyBET00gbm9kZVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSBuYW1lIC0gbmFtZSBvZiB0aGUgRE9NIG5vZGUgd2Ugd2FudCB0byBjcmVhdGVcbiAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IGlzU3ZnIC0gc2hvdWxkIHdlIHVzZSBhIFNWRyBhcyBwYXJlbnQgbm9kZT9cbiAqIEByZXR1cm5zIHsgT2JqZWN0IH0gRE9NIG5vZGUganVzdCBjcmVhdGVkXG4gKi9cbmZ1bmN0aW9uIG1rRWwobmFtZSwgaXNTdmcpIHtcbiAgcmV0dXJuIGlzU3ZnID9cbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpIDpcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpXG59XG5cbi8qKlxuICogU2hvcnRlciBhbmQgZmFzdCB3YXkgdG8gc2VsZWN0IG11bHRpcGxlIG5vZGVzIGluIHRoZSBET01cbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gc2VsZWN0b3IgLSBET00gc2VsZWN0b3JcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gY3R4IC0gRE9NIG5vZGUgd2hlcmUgdGhlIHRhcmdldHMgb2Ygb3VyIHNlYXJjaCB3aWxsIGlzIGxvY2F0ZWRcbiAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZG9tIG5vZGVzIGZvdW5kXG4gKi9cbmZ1bmN0aW9uICQkKHNlbGVjdG9yLCBjdHgpIHtcbiAgcmV0dXJuIChjdHggfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXG59XG5cbi8qKlxuICogU2hvcnRlciBhbmQgZmFzdCB3YXkgdG8gc2VsZWN0IGEgc2luZ2xlIG5vZGUgaW4gdGhlIERPTVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSBzZWxlY3RvciAtIHVuaXF1ZSBkb20gc2VsZWN0b3JcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gY3R4IC0gRE9NIG5vZGUgd2hlcmUgdGhlIHRhcmdldCBvZiBvdXIgc2VhcmNoIHdpbGwgaXMgbG9jYXRlZFxuICogQHJldHVybnMgeyBPYmplY3QgfSBkb20gbm9kZSBmb3VuZFxuICovXG5mdW5jdGlvbiAkKHNlbGVjdG9yLCBjdHgpIHtcbiAgcmV0dXJuIChjdHggfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG59XG5cbi8qKlxuICogU2ltcGxlIG9iamVjdCBwcm90b3R5cGFsIGluaGVyaXRhbmNlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IHBhcmVudCAtIHBhcmVudCBvYmplY3RcbiAqIEByZXR1cm5zIHsgT2JqZWN0IH0gY2hpbGQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gaW5oZXJpdChwYXJlbnQpIHtcbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50IHx8IG51bGwpXG59XG5cbi8qKlxuICogR2V0IHRoZSBuYW1lIHByb3BlcnR5IG5lZWRlZCB0byBpZGVudGlmeSBhIERPTSBub2RlIGluIHJpb3RcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZG9tIC0gRE9NIG5vZGUgd2UgbmVlZCB0byBwYXJzZVxuICogQHJldHVybnMgeyBTdHJpbmcgfCB1bmRlZmluZWQgfSBnaXZlIHVzIGJhY2sgYSBzdHJpbmcgdG8gaWRlbnRpZnkgdGhpcyBkb20gbm9kZVxuICovXG5mdW5jdGlvbiBnZXROYW1lZEtleShkb20pIHtcbiAgcmV0dXJuIGdldEF0dHIoZG9tLCAnaWQnKSB8fCBnZXRBdHRyKGRvbSwgJ25hbWUnKVxufVxuXG4vKipcbiAqIFNldCB0aGUgbmFtZWQgcHJvcGVydGllcyBvZiBhIHRhZyBlbGVtZW50XG4gKiBAcGFyYW0geyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSBuZWVkIHRvIHBhcnNlXG4gKiBAcGFyYW0geyBPYmplY3QgfSBwYXJlbnQgLSB0YWcgaW5zdGFuY2Ugd2hlcmUgdGhlIG5hbWVkIGRvbSBlbGVtZW50IHdpbGwgYmUgZXZlbnR1YWxseSBhZGRlZFxuICogQHBhcmFtIHsgQXJyYXkgfSBrZXlzIC0gbGlzdCBvZiBhbGwgdGhlIHRhZyBpbnN0YW5jZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIHNldE5hbWVkKGRvbSwgcGFyZW50LCBrZXlzKSB7XG4gIC8vIGdldCB0aGUga2V5IHZhbHVlIHdlIHdhbnQgdG8gYWRkIHRvIHRoZSB0YWcgaW5zdGFuY2VcbiAgdmFyIGtleSA9IGdldE5hbWVkS2V5KGRvbSksXG4gICAgaXNBcnIsXG4gICAgLy8gYWRkIHRoZSBub2RlIGRldGVjdGVkIHRvIGEgdGFnIGluc3RhbmNlIHVzaW5nIHRoZSBuYW1lZCBwcm9wZXJ0eVxuICAgIGFkZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAvLyBhdm9pZCB0byBvdmVycmlkZSB0aGUgdGFnIHByb3BlcnRpZXMgYWxyZWFkeSBzZXRcbiAgICAgIGlmIChjb250YWlucyhrZXlzLCBrZXkpKSByZXR1cm5cbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhpcyB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAgaXNBcnIgPSBpc0FycmF5KHZhbHVlKVxuICAgICAgLy8gaWYgdGhlIGtleSB3YXMgbmV2ZXIgc2V0XG4gICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAvLyBzZXQgaXQgb25jZSBvbiB0aGUgdGFnIGluc3RhbmNlXG4gICAgICAgIHBhcmVudFtrZXldID0gZG9tXG4gICAgICAvLyBpZiBpdCB3YXMgYW4gYXJyYXkgYW5kIG5vdCB5ZXQgc2V0XG4gICAgICBlbHNlIGlmICghaXNBcnIgfHwgaXNBcnIgJiYgIWNvbnRhaW5zKHZhbHVlLCBkb20pKSB7XG4gICAgICAgIC8vIGFkZCB0aGUgZG9tIG5vZGUgaW50byB0aGUgYXJyYXlcbiAgICAgICAgaWYgKGlzQXJyKVxuICAgICAgICAgIHZhbHVlLnB1c2goZG9tKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcGFyZW50W2tleV0gPSBbdmFsdWUsIGRvbV1cbiAgICAgIH1cbiAgICB9XG5cbiAgLy8gc2tpcCB0aGUgZWxlbWVudHMgd2l0aCBubyBuYW1lZCBwcm9wZXJ0aWVzXG4gIGlmICgha2V5KSByZXR1cm5cblxuICAvLyBjaGVjayB3aGV0aGVyIHRoaXMga2V5IGhhcyBiZWVuIGFscmVhZHkgZXZhbHVhdGVkXG4gIGlmICh0bXBsLmhhc0V4cHIoa2V5KSlcbiAgICAvLyB3YWl0IHRoZSBmaXJzdCB1cGRhdGVkIGV2ZW50IG9ubHkgb25jZVxuICAgIHBhcmVudC5vbmUoJ21vdW50JywgZnVuY3Rpb24oKSB7XG4gICAgICBrZXkgPSBnZXROYW1lZEtleShkb20pXG4gICAgICBhZGQocGFyZW50W2tleV0pXG4gICAgfSlcbiAgZWxzZVxuICAgIGFkZChwYXJlbnRba2V5XSlcblxufVxuXG4vKipcbiAqIEZhc3RlciBTdHJpbmcgc3RhcnRzV2l0aCBhbHRlcm5hdGl2ZVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSBzcmMgLSBzb3VyY2Ugc3RyaW5nXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IHN0ciAtIHRlc3Qgc3RyaW5nXG4gKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3JjLCBzdHIpIHtcbiAgcmV0dXJuIHNyYy5zbGljZSgwLCBzdHIubGVuZ3RoKSA9PT0gc3RyXG59XG5cbi8qKlxuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZ1bmN0aW9uXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzE1Nzk2NzEsIGxpY2Vuc2UgTUlUXG4gKi9cbnZhciByQUYgPSAoZnVuY3Rpb24gKHcpIHtcbiAgdmFyIHJhZiA9IHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICAgICB3Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuXG4gIGlmICghcmFmIHx8IC9pUChhZHxob25lfG9kKS4qT1MgNi8udGVzdCh3Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7ICAvLyBidWdneSBpT1M2XG4gICAgdmFyIGxhc3RUaW1lID0gMFxuXG4gICAgcmFmID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICB2YXIgbm93dGltZSA9IERhdGUubm93KCksIHRpbWVvdXQgPSBNYXRoLm1heCgxNiAtIChub3d0aW1lIC0gbGFzdFRpbWUpLCAwKVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGNiKGxhc3RUaW1lID0gbm93dGltZSArIHRpbWVvdXQpIH0sIHRpbWVvdXQpXG4gICAgfVxuICB9XG4gIHJldHVybiByYWZcblxufSkod2luZG93IHx8IHt9KVxuXG4vKipcbiAqIE1vdW50IGEgdGFnIGNyZWF0aW5nIG5ldyBUYWcgaW5zdGFuY2VcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gcm9vdCAtIGRvbSBub2RlIHdoZXJlIHRoZSB0YWcgd2lsbCBiZSBtb3VudGVkXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IHRhZ05hbWUgLSBuYW1lIG9mIHRoZSByaW90IHRhZyB3ZSB3YW50IHRvIG1vdW50XG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IG9wdHMgLSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIFRhZyBpbnN0YW5jZVxuICogQHJldHVybnMgeyBUYWcgfSBhIG5ldyBUYWcgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gbW91bnRUbyhyb290LCB0YWdOYW1lLCBvcHRzKSB7XG4gIHZhciB0YWcgPSBfX3RhZ0ltcGxbdGFnTmFtZV0sXG4gICAgLy8gY2FjaGUgdGhlIGlubmVyIEhUTUwgdG8gZml4ICM4NTVcbiAgICBpbm5lckhUTUwgPSByb290Ll9pbm5lckhUTUwgPSByb290Ll9pbm5lckhUTUwgfHwgcm9vdC5pbm5lckhUTUxcblxuICAvLyBjbGVhciB0aGUgaW5uZXIgaHRtbFxuICByb290LmlubmVySFRNTCA9ICcnXG5cbiAgaWYgKHRhZyAmJiByb290KSB0YWcgPSBuZXcgVGFnKHRhZywgeyByb290OiByb290LCBvcHRzOiBvcHRzIH0sIGlubmVySFRNTClcblxuICBpZiAodGFnICYmIHRhZy5tb3VudCkge1xuICAgIHRhZy5tb3VudCgpXG4gICAgLy8gYWRkIHRoaXMgdGFnIHRvIHRoZSB2aXJ0dWFsRG9tIHZhcmlhYmxlXG4gICAgaWYgKCFjb250YWlucyhfX3ZpcnR1YWxEb20sIHRhZykpIF9fdmlydHVhbERvbS5wdXNoKHRhZylcbiAgfVxuXG4gIHJldHVybiB0YWdcbn1cbi8qKlxuICogUmlvdCBwdWJsaWMgYXBpXG4gKi9cblxuLy8gc2hhcmUgbWV0aG9kcyBmb3Igb3RoZXIgcmlvdCBwYXJ0cywgZS5nLiBjb21waWxlclxucmlvdC51dGlsID0geyBicmFja2V0czogYnJhY2tldHMsIHRtcGw6IHRtcGwgfVxuXG4vKipcbiAqIENyZWF0ZSBhIG1peGluIHRoYXQgY291bGQgYmUgZ2xvYmFsbHkgc2hhcmVkIGFjcm9zcyBhbGwgdGhlIHRhZ3NcbiAqL1xucmlvdC5taXhpbiA9IChmdW5jdGlvbigpIHtcbiAgdmFyIG1peGlucyA9IHt9LFxuICAgIGdsb2JhbHMgPSBtaXhpbnNbR0xPQkFMX01JWElOXSA9IHt9LFxuICAgIF9pZCA9IDBcblxuICAvKipcbiAgICogQ3JlYXRlL1JldHVybiBhIG1peGluIGJ5IGl0cyBuYW1lXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gIG5hbWUgLSBtaXhpbiBuYW1lIChnbG9iYWwgbWl4aW4gaWYgb2JqZWN0KVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9ICBtaXhpbiAtIG1peGluIGxvZ2ljXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IGcgLSBpcyBnbG9iYWw/XG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gIHRoZSBtaXhpbiBsb2dpY1xuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIG1peGluLCBnKSB7XG4gICAgLy8gVW5uYW1lZCBnbG9iYWxcbiAgICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICAgIHJpb3QubWl4aW4oJ19fdW5uYW1lZF8nK19pZCsrLCBuYW1lLCB0cnVlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIHN0b3JlID0gZyA/IGdsb2JhbHMgOiBtaXhpbnNcblxuICAgIC8vIEdldHRlclxuICAgIGlmICghbWl4aW4pIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RvcmVbbmFtZV0gPT09IFRfVU5ERUYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlZ2lzdGVyZWQgbWl4aW46ICcgKyBuYW1lKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0b3JlW25hbWVdXG4gICAgfVxuICAgIC8vIFNldHRlclxuICAgIGlmIChpc0Z1bmN0aW9uKG1peGluKSkge1xuICAgICAgZXh0ZW5kKG1peGluLnByb3RvdHlwZSwgc3RvcmVbbmFtZV0gfHwge30pXG4gICAgICBzdG9yZVtuYW1lXSA9IG1peGluXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RvcmVbbmFtZV0gPSBleHRlbmQoc3RvcmVbbmFtZV0gfHwge30sIG1peGluKVxuICAgIH1cbiAgfVxuXG59KSgpXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHJpb3QgdGFnIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgbmFtZSAtIG5hbWUvaWQgb2YgdGhlIG5ldyByaW90IHRhZ1xuICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGh0bWwgLSB0YWcgdGVtcGxhdGVcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gICBjc3MgLSBjdXN0b20gdGFnIGNzc1xuICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGF0dHJzIC0gcm9vdCB0YWcgYXR0cmlidXRlc1xuICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gdXNlciBmdW5jdGlvblxuICogQHJldHVybnMgeyBTdHJpbmcgfSBuYW1lL2lkIG9mIHRoZSB0YWcganVzdCBjcmVhdGVkXG4gKi9cbnJpb3QudGFnID0gZnVuY3Rpb24obmFtZSwgaHRtbCwgY3NzLCBhdHRycywgZm4pIHtcbiAgaWYgKGlzRnVuY3Rpb24oYXR0cnMpKSB7XG4gICAgZm4gPSBhdHRyc1xuICAgIGlmICgvXltcXHdcXC1dK1xccz89Ly50ZXN0KGNzcykpIHtcbiAgICAgIGF0dHJzID0gY3NzXG4gICAgICBjc3MgPSAnJ1xuICAgIH0gZWxzZSBhdHRycyA9ICcnXG4gIH1cbiAgaWYgKGNzcykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNzcykpIGZuID0gY3NzXG4gICAgZWxzZSBzdHlsZU1hbmFnZXIuYWRkKGNzcylcbiAgfVxuICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIF9fdGFnSW1wbFtuYW1lXSA9IHsgbmFtZTogbmFtZSwgdG1wbDogaHRtbCwgYXR0cnM6IGF0dHJzLCBmbjogZm4gfVxuICByZXR1cm4gbmFtZVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyByaW90IHRhZyBpbXBsZW1lbnRhdGlvbiAoZm9yIHVzZSBieSB0aGUgY29tcGlsZXIpXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgbmFtZSAtIG5hbWUvaWQgb2YgdGhlIG5ldyByaW90IHRhZ1xuICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGh0bWwgLSB0YWcgdGVtcGxhdGVcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gICBjc3MgLSBjdXN0b20gdGFnIGNzc1xuICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGF0dHJzIC0gcm9vdCB0YWcgYXR0cmlidXRlc1xuICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gdXNlciBmdW5jdGlvblxuICogQHJldHVybnMgeyBTdHJpbmcgfSBuYW1lL2lkIG9mIHRoZSB0YWcganVzdCBjcmVhdGVkXG4gKi9cbnJpb3QudGFnMiA9IGZ1bmN0aW9uKG5hbWUsIGh0bWwsIGNzcywgYXR0cnMsIGZuKSB7XG4gIGlmIChjc3MpIHN0eWxlTWFuYWdlci5hZGQoY3NzKVxuICAvL2lmIChicGFpcikgcmlvdC5zZXR0aW5ncy5icmFja2V0cyA9IGJwYWlyXG4gIF9fdGFnSW1wbFtuYW1lXSA9IHsgbmFtZTogbmFtZSwgdG1wbDogaHRtbCwgYXR0cnM6IGF0dHJzLCBmbjogZm4gfVxuICByZXR1cm4gbmFtZVxufVxuXG4vKipcbiAqIE1vdW50IGEgdGFnIHVzaW5nIGEgc3BlY2lmaWMgdGFnIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IHNlbGVjdG9yIC0gdGFnIERPTSBzZWxlY3RvclxuICogQHBhcmFtICAgeyBTdHJpbmcgfSB0YWdOYW1lIC0gdGFnIGltcGxlbWVudGF0aW9uIG5hbWVcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gb3B0cyAtIHRhZyBsb2dpY1xuICogQHJldHVybnMgeyBBcnJheSB9IG5ldyB0YWdzIGluc3RhbmNlc1xuICovXG5yaW90Lm1vdW50ID0gZnVuY3Rpb24oc2VsZWN0b3IsIHRhZ05hbWUsIG9wdHMpIHtcblxuICB2YXIgZWxzLFxuICAgIGFsbFRhZ3MsXG4gICAgdGFncyA9IFtdXG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIGFkZFJpb3RUYWdzKGFycikge1xuICAgIHZhciBsaXN0ID0gJydcbiAgICBlYWNoKGFyciwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghL1teLVxcd10vLnRlc3QoZSkpIHtcbiAgICAgICAgZSA9IGUudHJpbSgpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbGlzdCArPSAnLFsnICsgUklPVF9UQUdfSVMgKyAnPVwiJyArIGUgKyAnXCJdLFsnICsgUklPVF9UQUcgKyAnPVwiJyArIGUgKyAnXCJdJ1xuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEFsbFRhZ3MoKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfX3RhZ0ltcGwpXG4gICAgcmV0dXJuIGtleXMgKyBhZGRSaW90VGFncyhrZXlzKVxuICB9XG5cbiAgZnVuY3Rpb24gcHVzaFRhZ3Mocm9vdCkge1xuICAgIGlmIChyb290LnRhZ05hbWUpIHtcbiAgICAgIHZhciByaW90VGFnID0gZ2V0QXR0cihyb290LCBSSU9UX1RBR19JUykgfHwgZ2V0QXR0cihyb290LCBSSU9UX1RBRylcblxuICAgICAgLy8gaGF2ZSB0YWdOYW1lPyBmb3JjZSByaW90LXRhZyB0byBiZSB0aGUgc2FtZVxuICAgICAgaWYgKHRhZ05hbWUgJiYgcmlvdFRhZyAhPT0gdGFnTmFtZSkge1xuICAgICAgICByaW90VGFnID0gdGFnTmFtZVxuICAgICAgICBzZXRBdHRyKHJvb3QsIFJJT1RfVEFHX0lTLCB0YWdOYW1lKVxuICAgICAgICBzZXRBdHRyKHJvb3QsIFJJT1RfVEFHLCB0YWdOYW1lKSAvLyB0aGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiByaW90IDMuMC4wXG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gbW91bnRUbyhyb290LCByaW90VGFnIHx8IHJvb3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBvcHRzKVxuXG4gICAgICBpZiAodGFnKSB0YWdzLnB1c2godGFnKVxuICAgIH0gZWxzZSBpZiAocm9vdC5sZW5ndGgpIHtcbiAgICAgIGVhY2gocm9vdCwgcHVzaFRhZ3MpICAgLy8gYXNzdW1lIG5vZGVMaXN0XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0gbW91bnQgY29kZSAtLS0tLVxuXG4gIC8vIGluamVjdCBzdHlsZXMgaW50byBET01cbiAgc3R5bGVNYW5hZ2VyLmluamVjdCgpXG5cbiAgaWYgKGlzT2JqZWN0KHRhZ05hbWUpKSB7XG4gICAgb3B0cyA9IHRhZ05hbWVcbiAgICB0YWdOYW1lID0gMFxuICB9XG5cbiAgLy8gY3Jhd2wgdGhlIERPTSB0byBmaW5kIHRoZSB0YWdcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gVF9TVFJJTkcpIHtcbiAgICBpZiAoc2VsZWN0b3IgPT09ICcqJylcbiAgICAgIC8vIHNlbGVjdCBhbGwgdGhlIHRhZ3MgcmVnaXN0ZXJlZFxuICAgICAgLy8gYW5kIGFsc28gdGhlIHRhZ3MgZm91bmQgd2l0aCB0aGUgcmlvdC10YWcgYXR0cmlidXRlIHNldFxuICAgICAgc2VsZWN0b3IgPSBhbGxUYWdzID0gc2VsZWN0QWxsVGFncygpXG4gICAgZWxzZVxuICAgICAgLy8gb3IganVzdCB0aGUgb25lcyBuYW1lZCBsaWtlIHRoZSBzZWxlY3RvclxuICAgICAgc2VsZWN0b3IgKz0gYWRkUmlvdFRhZ3Moc2VsZWN0b3Iuc3BsaXQoLywgKi8pKVxuXG4gICAgLy8gbWFrZSBzdXJlIHRvIHBhc3MgYWx3YXlzIGEgc2VsZWN0b3JcbiAgICAvLyB0byB0aGUgcXVlcnlTZWxlY3RvckFsbCBmdW5jdGlvblxuICAgIGVscyA9IHNlbGVjdG9yID8gJCQoc2VsZWN0b3IpIDogW11cbiAgfVxuICBlbHNlXG4gICAgLy8gcHJvYmFibHkgeW91IGhhdmUgcGFzc2VkIGFscmVhZHkgYSB0YWcgb3IgYSBOb2RlTGlzdFxuICAgIGVscyA9IHNlbGVjdG9yXG5cbiAgLy8gc2VsZWN0IGFsbCB0aGUgcmVnaXN0ZXJlZCBhbmQgbW91bnQgdGhlbSBpbnNpZGUgdGhlaXIgcm9vdCBlbGVtZW50c1xuICBpZiAodGFnTmFtZSA9PT0gJyonKSB7XG4gICAgLy8gZ2V0IGFsbCBjdXN0b20gdGFnc1xuICAgIHRhZ05hbWUgPSBhbGxUYWdzIHx8IHNlbGVjdEFsbFRhZ3MoKVxuICAgIC8vIGlmIHRoZSByb290IGVscyBpdCdzIGp1c3QgYSBzaW5nbGUgdGFnXG4gICAgaWYgKGVscy50YWdOYW1lKVxuICAgICAgZWxzID0gJCQodGFnTmFtZSwgZWxzKVxuICAgIGVsc2Uge1xuICAgICAgLy8gc2VsZWN0IGFsbCB0aGUgY2hpbGRyZW4gZm9yIGFsbCB0aGUgZGlmZmVyZW50IHJvb3QgZWxlbWVudHNcbiAgICAgIHZhciBub2RlTGlzdCA9IFtdXG4gICAgICBlYWNoKGVscywgZnVuY3Rpb24gKF9lbCkge1xuICAgICAgICBub2RlTGlzdC5wdXNoKCQkKHRhZ05hbWUsIF9lbCkpXG4gICAgICB9KVxuICAgICAgZWxzID0gbm9kZUxpc3RcbiAgICB9XG4gICAgLy8gZ2V0IHJpZCBvZiB0aGUgdGFnTmFtZVxuICAgIHRhZ05hbWUgPSAwXG4gIH1cblxuICBwdXNoVGFncyhlbHMpXG5cbiAgcmV0dXJuIHRhZ3Ncbn1cblxuLyoqXG4gKiBVcGRhdGUgYWxsIHRoZSB0YWdzIGluc3RhbmNlcyBjcmVhdGVkXG4gKiBAcmV0dXJucyB7IEFycmF5IH0gYWxsIHRoZSB0YWdzIGluc3RhbmNlc1xuICovXG5yaW90LnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZWFjaChfX3ZpcnR1YWxEb20sIGZ1bmN0aW9uKHRhZykge1xuICAgIHRhZy51cGRhdGUoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9ydCB0aGUgVmlydHVhbCBET01cbiAqL1xucmlvdC52ZG9tID0gX192aXJ0dWFsRG9tXG5cbi8qKlxuICogRXhwb3J0IHRoZSBUYWcgY29uc3RydWN0b3JcbiAqL1xucmlvdC5UYWcgPSBUYWdcbiAgLy8gc3VwcG9ydCBDb21tb25KUywgQU1EICYgYnJvd3NlclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFRfT0JKRUNUKVxuICAgIG1vZHVsZS5leHBvcnRzID0gcmlvdFxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBUX0ZVTkNUSU9OICYmIHR5cGVvZiBkZWZpbmUuYW1kICE9PSBUX1VOREVGKVxuICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHJpb3QgfSlcbiAgZWxzZVxuICAgIHdpbmRvdy5yaW90ID0gcmlvdFxuXG59KSh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93IDogdm9pZCAwKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yaW90L3Jpb3QuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  IN: 'IN',\n  OUT: 'OUT',\n  END: 'END',\n  PREV: 'PREV',\n  NEXT: 'NEXT'\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9qb3JnZS9kZXYvZ2FsbC9zcmMvY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICBJTjogJ0lOJyxcbiAgT1VUOiAnT1VUJyxcbiAgRU5EOiAnRU5EJyxcbiAgUFJFVjogJ1BSRVYnLFxuICBORVhUOiAnTkVYVCdcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb25zdGFudHMuanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Super simple throttle, leading only, not greedy.\n * Based on @jonathansampson post Simple Throttle Function.\n * http://sampsonblog.com/749/simple-throttle-function\n *\n * @param      {Function}  targetFunc  The target function.\n * @param      {Number}    lapse       The time that the target function will be blocked in ms.\n * @return     {Function}              A throttled function.\n */\n\n\nmodule.exports = function throttle(targetFunc, lapse) {\n  // Using the Throttle analogy:\n  var isOpen = true; // Valve's state.\n\n  return function throttled() {\n    // Returns a function that\n    if (isOpen) {\n      // when the valve is 'open' allows one call to the target function\n      isOpen = false; // and 'closes', prevents future calls of being executed,\n      setTimeout(function () {\n        return isOpen = true;\n      }, lapse); // and later after a lapse 'opens' the valve back.\n      return targetFunc.apply(this, arguments); // Returning the result of the target applying the throttled scope and args.\n    }\n  };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9qb3JnZS9kZXYvZ2FsbC9zcmMvbGliL3Rocm90dGxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU3VwZXIgc2ltcGxlIHRocm90dGxlLCBsZWFkaW5nIG9ubHksIG5vdCBncmVlZHkuXG4gKiBCYXNlZCBvbiBAam9uYXRoYW5zYW1wc29uIHBvc3QgU2ltcGxlIFRocm90dGxlIEZ1bmN0aW9uLlxuICogaHR0cDovL3NhbXBzb25ibG9nLmNvbS83NDkvc2ltcGxlLXRocm90dGxlLWZ1bmN0aW9uXG4gKlxuICogQHBhcmFtICAgICAge0Z1bmN0aW9ufSAgdGFyZ2V0RnVuYyAgVGhlIHRhcmdldCBmdW5jdGlvbi5cbiAqIEBwYXJhbSAgICAgIHtOdW1iZXJ9ICAgIGxhcHNlICAgICAgIFRoZSB0aW1lIHRoYXQgdGhlIHRhcmdldCBmdW5jdGlvbiB3aWxsIGJlIGJsb2NrZWQgaW4gbXMuXG4gKiBAcmV0dXJuICAgICB7RnVuY3Rpb259ICAgICAgICAgICAgICBBIHRocm90dGxlZCBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0aHJvdHRsZSAodGFyZ2V0RnVuYywgbGFwc2UpIHsgICAvLyBVc2luZyB0aGUgVGhyb3R0bGUgYW5hbG9neTpcbiAgbGV0IGlzT3BlbiA9IHRydWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsdmUncyBzdGF0ZS5cblxuICByZXR1cm4gZnVuY3Rpb24gdGhyb3R0bGVkICgpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdFxuICAgIGlmIChpc09wZW4pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSB2YWx2ZSBpcyAnb3BlbicgYWxsb3dzIG9uZSBjYWxsIHRvIHRoZSB0YXJnZXQgZnVuY3Rpb25cbiAgICAgIGlzT3BlbiA9IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kICdjbG9zZXMnLCBwcmV2ZW50cyBmdXR1cmUgY2FsbHMgb2YgYmVpbmcgZXhlY3V0ZWQsXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IChpc09wZW4gPSB0cnVlKSwgbGFwc2UpICAgICAgICAgICAgIC8vIGFuZCBsYXRlciBhZnRlciBhIGxhcHNlICdvcGVucycgdGhlIHZhbHZlIGJhY2suXG4gICAgICByZXR1cm4gdGFyZ2V0RnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICAgICAgICAgICAgIC8vIFJldHVybmluZyB0aGUgcmVzdWx0IG9mIHRoZSB0YXJnZXQgYXBwbHlpbmcgdGhlIHRocm90dGxlZCBzY29wZSBhbmQgYXJncy5cbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9saWIvdGhyb3R0bGUuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBU0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {/*!\r\n * @name JavaScript/NodeJS Merge v1.2.0\r\n * @author yeikos\r\n * @repository https://github.com/yeikos/js.merge\r\n\r\n * Copyright 2014 yeikos - MIT license\r\n * https://raw.github.com/yeikos/js.merge/master/LICENSE\r\n */\r\n\r\n;(function(isNode) {\r\n\r\n\t/**\r\n\t * Merge one or more objects \r\n\t * @param bool? clone\r\n\t * @param mixed,... arguments\r\n\t * @return object\r\n\t */\r\n\r\n\tvar Public = function(clone) {\r\n\r\n\t\treturn merge(clone === true, false, arguments);\r\n\r\n\t}, publicName = 'merge';\r\n\r\n\t/**\r\n\t * Merge two or more objects recursively \r\n\t * @param bool? clone\r\n\t * @param mixed,... arguments\r\n\t * @return object\r\n\t */\r\n\r\n\tPublic.recursive = function(clone) {\r\n\r\n\t\treturn merge(clone === true, true, arguments);\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Clone the input removing any reference\r\n\t * @param mixed input\r\n\t * @return mixed\r\n\t */\r\n\r\n\tPublic.clone = function(input) {\r\n\r\n\t\tvar output = input,\r\n\t\t\ttype = typeOf(input),\r\n\t\t\tindex, size;\r\n\r\n\t\tif (type === 'array') {\r\n\r\n\t\t\toutput = [];\r\n\t\t\tsize = input.length;\r\n\r\n\t\t\tfor (index=0;index<size;++index)\r\n\r\n\t\t\t\toutput[index] = Public.clone(input[index]);\r\n\r\n\t\t} else if (type === 'object') {\r\n\r\n\t\t\toutput = {};\r\n\r\n\t\t\tfor (index in input)\r\n\r\n\t\t\t\toutput[index] = Public.clone(input[index]);\r\n\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Merge two objects recursively\r\n\t * @param mixed input\r\n\t * @param mixed extend\r\n\t * @return mixed\r\n\t */\r\n\r\n\tfunction merge_recursive(base, extend) {\r\n\r\n\t\tif (typeOf(base) !== 'object')\r\n\r\n\t\t\treturn extend;\r\n\r\n\t\tfor (var key in extend) {\r\n\r\n\t\t\tif (typeOf(base[key]) === 'object' && typeOf(extend[key]) === 'object') {\r\n\r\n\t\t\t\tbase[key] = merge_recursive(base[key], extend[key]);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbase[key] = extend[key];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn base;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Merge two or more objects\r\n\t * @param bool clone\r\n\t * @param bool recursive\r\n\t * @param array argv\r\n\t * @return object\r\n\t */\r\n\r\n\tfunction merge(clone, recursive, argv) {\r\n\r\n\t\tvar result = argv[0],\r\n\t\t\tsize = argv.length;\r\n\r\n\t\tif (clone || typeOf(result) !== 'object')\r\n\r\n\t\t\tresult = {};\r\n\r\n\t\tfor (var index=0;index<size;++index) {\r\n\r\n\t\t\tvar item = argv[index],\r\n\r\n\t\t\t\ttype = typeOf(item);\r\n\r\n\t\t\tif (type !== 'object') continue;\r\n\r\n\t\t\tfor (var key in item) {\r\n\r\n\t\t\t\tvar sitem = clone ? Public.clone(item[key]) : item[key];\r\n\r\n\t\t\t\tif (recursive) {\r\n\r\n\t\t\t\t\tresult[key] = merge_recursive(result[key], sitem);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tresult[key] = sitem;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Get type of variable\r\n\t * @param mixed input\r\n\t * @return string\r\n\t *\r\n\t * @see http://jsperf.com/typeofvar\r\n\t */\r\n\r\n\tfunction typeOf(input) {\r\n\r\n\t\treturn ({}).toString.call(input).slice(8, -1).toLowerCase();\r\n\r\n\t}\r\n\r\n\tif (isNode) {\r\n\r\n\t\tmodule.exports = Public;\r\n\r\n\t} else {\r\n\r\n\t\twindow[publicName] = Public;\r\n\r\n\t}\r\n\r\n})(typeof module === 'object' && module && typeof module.exports === 'object' && module.exports);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(38)(module)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9qb3JnZS9kZXYvZ2FsbC9ub2RlX21vZHVsZXMvbWVyZ2UvbWVyZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiAqIEBuYW1lIEphdmFTY3JpcHQvTm9kZUpTIE1lcmdlIHYxLjIuMFxyXG4gKiBAYXV0aG9yIHllaWtvc1xyXG4gKiBAcmVwb3NpdG9yeSBodHRwczovL2dpdGh1Yi5jb20veWVpa29zL2pzLm1lcmdlXHJcblxyXG4gKiBDb3B5cmlnaHQgMjAxNCB5ZWlrb3MgLSBNSVQgbGljZW5zZVxyXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL3llaWtvcy9qcy5tZXJnZS9tYXN0ZXIvTElDRU5TRVxyXG4gKi9cclxuXHJcbjsoZnVuY3Rpb24oaXNOb2RlKSB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIE1lcmdlIG9uZSBvciBtb3JlIG9iamVjdHMgXHJcblx0ICogQHBhcmFtIGJvb2w/IGNsb25lXHJcblx0ICogQHBhcmFtIG1peGVkLC4uLiBhcmd1bWVudHNcclxuXHQgKiBAcmV0dXJuIG9iamVjdFxyXG5cdCAqL1xyXG5cclxuXHR2YXIgUHVibGljID0gZnVuY3Rpb24oY2xvbmUpIHtcclxuXHJcblx0XHRyZXR1cm4gbWVyZ2UoY2xvbmUgPT09IHRydWUsIGZhbHNlLCBhcmd1bWVudHMpO1xyXG5cclxuXHR9LCBwdWJsaWNOYW1lID0gJ21lcmdlJztcclxuXHJcblx0LyoqXHJcblx0ICogTWVyZ2UgdHdvIG9yIG1vcmUgb2JqZWN0cyByZWN1cnNpdmVseSBcclxuXHQgKiBAcGFyYW0gYm9vbD8gY2xvbmVcclxuXHQgKiBAcGFyYW0gbWl4ZWQsLi4uIGFyZ3VtZW50c1xyXG5cdCAqIEByZXR1cm4gb2JqZWN0XHJcblx0ICovXHJcblxyXG5cdFB1YmxpYy5yZWN1cnNpdmUgPSBmdW5jdGlvbihjbG9uZSkge1xyXG5cclxuXHRcdHJldHVybiBtZXJnZShjbG9uZSA9PT0gdHJ1ZSwgdHJ1ZSwgYXJndW1lbnRzKTtcclxuXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQ2xvbmUgdGhlIGlucHV0IHJlbW92aW5nIGFueSByZWZlcmVuY2VcclxuXHQgKiBAcGFyYW0gbWl4ZWQgaW5wdXRcclxuXHQgKiBAcmV0dXJuIG1peGVkXHJcblx0ICovXHJcblxyXG5cdFB1YmxpYy5jbG9uZSA9IGZ1bmN0aW9uKGlucHV0KSB7XHJcblxyXG5cdFx0dmFyIG91dHB1dCA9IGlucHV0LFxyXG5cdFx0XHR0eXBlID0gdHlwZU9mKGlucHV0KSxcclxuXHRcdFx0aW5kZXgsIHNpemU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdhcnJheScpIHtcclxuXHJcblx0XHRcdG91dHB1dCA9IFtdO1xyXG5cdFx0XHRzaXplID0gaW5wdXQubGVuZ3RoO1xyXG5cclxuXHRcdFx0Zm9yIChpbmRleD0wO2luZGV4PHNpemU7KytpbmRleClcclxuXHJcblx0XHRcdFx0b3V0cHV0W2luZGV4XSA9IFB1YmxpYy5jbG9uZShpbnB1dFtpbmRleF0pO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcclxuXHJcblx0XHRcdG91dHB1dCA9IHt9O1xyXG5cclxuXHRcdFx0Zm9yIChpbmRleCBpbiBpbnB1dClcclxuXHJcblx0XHRcdFx0b3V0cHV0W2luZGV4XSA9IFB1YmxpYy5jbG9uZShpbnB1dFtpbmRleF0pO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBNZXJnZSB0d28gb2JqZWN0cyByZWN1cnNpdmVseVxyXG5cdCAqIEBwYXJhbSBtaXhlZCBpbnB1dFxyXG5cdCAqIEBwYXJhbSBtaXhlZCBleHRlbmRcclxuXHQgKiBAcmV0dXJuIG1peGVkXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIG1lcmdlX3JlY3Vyc2l2ZShiYXNlLCBleHRlbmQpIHtcclxuXHJcblx0XHRpZiAodHlwZU9mKGJhc2UpICE9PSAnb2JqZWN0JylcclxuXHJcblx0XHRcdHJldHVybiBleHRlbmQ7XHJcblxyXG5cdFx0Zm9yICh2YXIga2V5IGluIGV4dGVuZCkge1xyXG5cclxuXHRcdFx0aWYgKHR5cGVPZihiYXNlW2tleV0pID09PSAnb2JqZWN0JyAmJiB0eXBlT2YoZXh0ZW5kW2tleV0pID09PSAnb2JqZWN0Jykge1xyXG5cclxuXHRcdFx0XHRiYXNlW2tleV0gPSBtZXJnZV9yZWN1cnNpdmUoYmFzZVtrZXldLCBleHRlbmRba2V5XSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRiYXNlW2tleV0gPSBleHRlbmRba2V5XTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJhc2U7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTWVyZ2UgdHdvIG9yIG1vcmUgb2JqZWN0c1xyXG5cdCAqIEBwYXJhbSBib29sIGNsb25lXHJcblx0ICogQHBhcmFtIGJvb2wgcmVjdXJzaXZlXHJcblx0ICogQHBhcmFtIGFycmF5IGFyZ3ZcclxuXHQgKiBAcmV0dXJuIG9iamVjdFxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBtZXJnZShjbG9uZSwgcmVjdXJzaXZlLCBhcmd2KSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IGFyZ3ZbMF0sXHJcblx0XHRcdHNpemUgPSBhcmd2Lmxlbmd0aDtcclxuXHJcblx0XHRpZiAoY2xvbmUgfHwgdHlwZU9mKHJlc3VsdCkgIT09ICdvYmplY3QnKVxyXG5cclxuXHRcdFx0cmVzdWx0ID0ge307XHJcblxyXG5cdFx0Zm9yICh2YXIgaW5kZXg9MDtpbmRleDxzaXplOysraW5kZXgpIHtcclxuXHJcblx0XHRcdHZhciBpdGVtID0gYXJndltpbmRleF0sXHJcblxyXG5cdFx0XHRcdHR5cGUgPSB0eXBlT2YoaXRlbSk7XHJcblxyXG5cdFx0XHRpZiAodHlwZSAhPT0gJ29iamVjdCcpIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGl0ZW0pIHtcclxuXHJcblx0XHRcdFx0dmFyIHNpdGVtID0gY2xvbmUgPyBQdWJsaWMuY2xvbmUoaXRlbVtrZXldKSA6IGl0ZW1ba2V5XTtcclxuXHJcblx0XHRcdFx0aWYgKHJlY3Vyc2l2ZSkge1xyXG5cclxuXHRcdFx0XHRcdHJlc3VsdFtrZXldID0gbWVyZ2VfcmVjdXJzaXZlKHJlc3VsdFtrZXldLCBzaXRlbSk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmVzdWx0W2tleV0gPSBzaXRlbTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0eXBlIG9mIHZhcmlhYmxlXHJcblx0ICogQHBhcmFtIG1peGVkIGlucHV0XHJcblx0ICogQHJldHVybiBzdHJpbmdcclxuXHQgKlxyXG5cdCAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vdHlwZW9mdmFyXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIHR5cGVPZihpbnB1dCkge1xyXG5cclxuXHRcdHJldHVybiAoe30pLnRvU3RyaW5nLmNhbGwoaW5wdXQpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmIChpc05vZGUpIHtcclxuXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IFB1YmxpYztcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR3aW5kb3dbcHVibGljTmFtZV0gPSBQdWJsaWM7XHJcblxyXG5cdH1cclxuXHJcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWVyZ2UvbWVyZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n Image gallery auto justified using Flickr's justified-layout,\n Riot app, dispatcher added inspired by Flux.\n */\n\n\n__webpack_require__(20); // css next no me esta gustando por el momento\n\nvar loadPolyfills = __webpack_require__(8);\n\nvar riot = __webpack_require__(0);\nvar GalleryStore = __webpack_require__(19);\nvar dispatcher = __webpack_require__(5);\n// tags\n__webpack_require__(17);\n__webpack_require__(14);\n__webpack_require__(11);\n__webpack_require__(12);\n__webpack_require__(16);\n__webpack_require__(13);\n__webpack_require__(15);\n\nfunction main(err) {\n  if (err) throw err;\n\n  var galleryStore = new GalleryStore(dispatcher);\n  dispatcher.addStore(galleryStore);\n\n  riot.mount('justified-gallery', { store: galleryStore });\n}\n\nloadPolyfills(['Array.prototype.find', 'Object.assign', 'Promise'], main);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9qb3JnZS9kZXYvZ2FsbC9zcmMvYXBwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gSW1hZ2UgZ2FsbGVyeSBhdXRvIGp1c3RpZmllZCB1c2luZyBGbGlja3IncyBqdXN0aWZpZWQtbGF5b3V0LFxuIFJpb3QgYXBwLCBkaXNwYXRjaGVyIGFkZGVkIGluc3BpcmVkIGJ5IEZsdXguXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5yZXF1aXJlKCcuL2Nzcy9tYWluLmNzcycpIC8vIGNzcyBuZXh0IG5vIG1lIGVzdGEgZ3VzdGFuZG8gcG9yIGVsIG1vbWVudG9cblxuY29uc3QgbG9hZFBvbHlmaWxscyA9IHJlcXVpcmUoJy4vbGliL2xvYWRQb2x5ZmlsbHMnKVxuXG5jb25zdCByaW90ID0gcmVxdWlyZSgncmlvdCcpXG5jb25zdCBHYWxsZXJ5U3RvcmUgPSByZXF1aXJlKCcuL3N0b3Jlcy9wb3J0Zm9saW8tc3RvcmUnKVxuY29uc3QgZGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlcicpXG4vLyB0YWdzXG5yZXF1aXJlKCdyYXcnKVxucmVxdWlyZSgnaW1nLWNvbXAnKVxucmVxdWlyZSgnYm94JylcbnJlcXVpcmUoJ2NvbnRhaW5lcicpXG5yZXF1aXJlKCdtb2RhbCcpXG5yZXF1aXJlKCdnYWxsZXJpZXMtbWVudScpXG5yZXF1aXJlKCdqdXN0aWZpZWQtZ2FsbGVyeScpXG5cbmZ1bmN0aW9uIG1haW4gKGVycikge1xuICBpZiAoZXJyKSB0aHJvdyBlcnJcblxuICBsZXQgZ2FsbGVyeVN0b3JlID0gbmV3IEdhbGxlcnlTdG9yZShkaXNwYXRjaGVyKVxuICBkaXNwYXRjaGVyLmFkZFN0b3JlKGdhbGxlcnlTdG9yZSlcblxuICByaW90Lm1vdW50KCdqdXN0aWZpZWQtZ2FsbGVyeScsIHtzdG9yZTogZ2FsbGVyeVN0b3JlfSlcbn1cblxubG9hZFBvbHlmaWxscyhbJ0FycmF5LnByb3RvdHlwZS5maW5kJywgJ09iamVjdC5hc3NpZ24nLCAnUHJvbWlzZSddLCBtYWluKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwcC5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// RiotControl dispatcher.\n// https://github.com/jimsparkman/RiotControl\n\n\n\nmodule.exports = {\n\n  // Dispatcher actions.\n  GALLERY_INIT: 'GALLERY_INIT',\n  GALLERY_LOAD: 'GALLERY_LOAD',\n  GALLERY_LOADED: 'GALLERY_LOADED',\n  IMAGE_CLICK: 'IMAGE_CLICK',\n  IMG_ZOOM_IN: 'IMG_ZOOM_IN',\n  IMG_ZOOM_OUT: 'IMG_ZOOM_OUT',\n  WINDOW_RESIZE: 'WINDOW_RESIZE',\n  TRANSITION_END: 'TRANSITION_END',\n  SWITCH_IMAGE: 'SWITCH_IMAGE',\n\n  _stores: [],\n\n  addStore: function addStore(store) {\n    this._stores.push(store);\n  },\n\n  trigger: function trigger() {\n    var args = [].slice.call(arguments);\n    // console.log('dispatcher: trigger: ' + args);\n    this._stores.forEach(function (el) {\n      el.trigger.apply(null, args);\n    });\n  },\n\n  on: function on(ev, cb) {\n    this._stores.forEach(function (el) {\n      el.on(ev, cb);\n    });\n  },\n\n  off: function off(ev, cb) {\n    this._stores.forEach(function (el) {\n      if (cb) el.off(ev, cb);else el.off(ev);\n    });\n  },\n\n  one: function one(ev, cb) {\n    this._stores.forEach(function (el) {\n      el.one(ev, cb);\n    });\n  }\n\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9qb3JnZS9kZXYvZ2FsbC9zcmMvZGlzcGF0Y2hlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSaW90Q29udHJvbCBkaXNwYXRjaGVyLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ppbXNwYXJrbWFuL1Jpb3RDb250cm9sXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8vIERpc3BhdGNoZXIgYWN0aW9ucy5cbiAgR0FMTEVSWV9JTklUOiAnR0FMTEVSWV9JTklUJyxcbiAgR0FMTEVSWV9MT0FEOiAnR0FMTEVSWV9MT0FEJyxcbiAgR0FMTEVSWV9MT0FERUQ6ICdHQUxMRVJZX0xPQURFRCcsXG4gIElNQUdFX0NMSUNLOiAnSU1BR0VfQ0xJQ0snLFxuICBJTUdfWk9PTV9JTjogJ0lNR19aT09NX0lOJyxcbiAgSU1HX1pPT01fT1VUOiAnSU1HX1pPT01fT1VUJyxcbiAgV0lORE9XX1JFU0laRTogJ1dJTkRPV19SRVNJWkUnLFxuICBUUkFOU0lUSU9OX0VORDogJ1RSQU5TSVRJT05fRU5EJyxcbiAgU1dJVENIX0lNQUdFOiAnU1dJVENIX0lNQUdFJyxcblxuICBfc3RvcmVzOiBbXSxcblxuICBhZGRTdG9yZSAoc3RvcmUpIHtcbiAgICB0aGlzLl9zdG9yZXMucHVzaChzdG9yZSlcbiAgfSxcblxuICB0cmlnZ2VyICgpIHtcbiAgICBsZXQgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIC8vIGNvbnNvbGUubG9nKCdkaXNwYXRjaGVyOiB0cmlnZ2VyOiAnICsgYXJncyk7XG4gICAgdGhpcy5fc3RvcmVzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC50cmlnZ2VyLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgfSlcbiAgfSxcblxuICBvbiAoZXYsIGNiKSB7XG4gICAgdGhpcy5fc3RvcmVzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5vbihldiwgY2IpXG4gICAgfSlcbiAgfSxcblxuICBvZmYgKGV2LCBjYikge1xuICAgIHRoaXMuX3N0b3Jlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgaWYgKGNiKSBlbC5vZmYoZXYsIGNiKVxuICAgICAgZWxzZSBlbC5vZmYoZXYpXG4gICAgfSlcbiAgfSxcblxuICBvbmUgKGV2LCBjYikge1xuICAgIHRoaXMuX3N0b3Jlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwub25lKGV2LCBjYilcbiAgICB9KVxuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kaXNwYXRjaGVyLmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isFileProtocol = function isFileProtocol(u) {\n  return (/^file:\\/\\//i.test(u)\n  );\n};\nvar isValidStatus = function isValidStatus(s) {\n  return s >= 200 && s < 300 || s === 304;\n};\nvar getErrObj = function getErrObj(err, xhr) {\n  return Object.assign(new Error(err), xhr);\n};\n\n/**\n * Super simple ajax get request of a json resource.\n *\n * @param      {String}    url     The url.\n * @param      {Function}  cb      The callback.\n */\nmodule.exports = function getJSON(url, callback) {\n  var xhr = new window.XMLHttpRequest();\n\n  var aborted = undefined;\n  var xhrAbort = xhr.abort;\n  xhr.abort = function () {\n    return (aborted = true) && xhrAbort.call(xhr);\n  };\n\n  xhr.open('GET', url, true);\n\n  xhr.onreadystatechange = function () {\n    if (!aborted && xhr.readyState === 4) {\n      return isValidStatus(xhr.status) || isFileProtocol(url) ? callback(false, JSON.parse(xhr.responseText)) : callback(getErrObj('Server response: ' + xhr.statusText, xhr));\n    }\n  };\n\n  xhr.onerror = function (e) {\n    return callback(getErrObj('Request failed.', xhr));\n  };\n\n  xhr.send(null);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9qb3JnZS9kZXYvZ2FsbC9zcmMvbGliL2dldEpTT04uanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaXNGaWxlUHJvdG9jb2wgPSAodSkgPT4gL15maWxlOlxcL1xcLy9pLnRlc3QodSlcbmNvbnN0IGlzVmFsaWRTdGF0dXMgPSAocykgPT4gKHMgPj0gMjAwICYmIHMgPCAzMDApIHx8IHMgPT09IDMwNFxuY29uc3QgZ2V0RXJyT2JqID0gKGVyciwgeGhyKSA9PiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihlcnIpLCB4aHIpXG5cbi8qKlxuICogU3VwZXIgc2ltcGxlIGFqYXggZ2V0IHJlcXVlc3Qgb2YgYSBqc29uIHJlc291cmNlLlxuICpcbiAqIEBwYXJhbSAgICAgIHtTdHJpbmd9ICAgIHVybCAgICAgVGhlIHVybC5cbiAqIEBwYXJhbSAgICAgIHtGdW5jdGlvbn0gIGNiICAgICAgVGhlIGNhbGxiYWNrLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEpTT04gKHVybCwgY2FsbGJhY2spIHtcbiAgbGV0IHhociA9IG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKVxuXG4gIGxldCBhYm9ydGVkXG4gIGxldCB4aHJBYm9ydCA9IHhoci5hYm9ydFxuICB4aHIuYWJvcnQgPSAoKSA9PiAoYWJvcnRlZCA9IHRydWUpICYmIHhockFib3J0LmNhbGwoeGhyKVxuXG4gIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpXG5cbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICBpZiAoIWFib3J0ZWQgJiYgeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgIHJldHVybiBpc1ZhbGlkU3RhdHVzKHhoci5zdGF0dXMpIHx8IGlzRmlsZVByb3RvY29sKHVybClcbiAgICAgICAgPyBjYWxsYmFjayhmYWxzZSwgSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KSlcbiAgICAgICAgOiBjYWxsYmFjayhnZXRFcnJPYmooJ1NlcnZlciByZXNwb25zZTogJyArIHhoci5zdGF0dXNUZXh0LCB4aHIpKVxuICAgIH1cbiAgfVxuXG4gIHhoci5vbmVycm9yID0gKGUpID0+IGNhbGxiYWNrKGdldEVyck9iaignUmVxdWVzdCBmYWlsZWQuJywgeGhyKSlcblxuICB4aHIuc2VuZChudWxsKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xpYi9nZXRKU09OLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// implementation from standard node.js 'util' module\n\n\nmodule.exports = function inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9qb3JnZS9kZXYvZ2FsbC9zcmMvbGliL2luaGVyaXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xpYi9pbmhlcml0cy5qcyJdLCJtYXBwaW5ncyI6Ijs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Loads polyfills.\n *\n * @param      {Array}     expectedFeatures  The expected features\n * @param      {Function}  loadHandler       The callback\n */\n\n\nmodule.exports = function loadPolyfills(expectedFeatures, loadHandler) {\n  // If any features need to be polyfilled.\n  if (expectedFeatures.some(isNotFunction)) {\n    // List the features that need to be polyfilled.\n    var missingFeatures = expectedFeatures.filter(isNotFunction);\n    // Create the url with 'ua' set to a supported browser and 'always'\n    var src = 'https://polyfill.io/v2/polyfill.min.js?features=' + missingFeatures.join(',') + '&flags=gated,always&ua=chrome/50';\n    // Create a script tag, load the polyfills in it and add it to head.\n    loadScript(src, loadHandler);\n  } else {\n    // If no polyfills are required, invoke the app.\n    loadHandler();\n  }\n};\n\n// For now just cheking if the feature is not a function.\n// TODO A list to diferenciate exeptions and create filters to handle them.\n\n/**\n * Determines if the requested feature is not a function.\n *\n * @param      {global property}   feature  The browser feature\n * @return     {boolean}           True if not function, False otherwise.\n */\nvar isNotFunction = function isNotFunction(feature) {\n  return typeof feature.split('.').reduce(function (global, prop) {\n    return global[prop];\n  }, window) !== 'function';\n};\n\n/**\n * Loads a script in the head element, and calls back when loaded.\n *\n * @param      {string}    url     The source url\n * @param      {Function}  cb    The callback\n */\nfunction loadScript(url, cb) {\n  var script = document.createElement('script');\n  script.src = url;\n  script.onload = function () {\n    return cb();\n  };\n  script.onerror = function () {\n    return cb(new URIError('Failed to load script ' + url));\n  };\n  document.head.appendChild(script);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9qb3JnZS9kZXYvZ2FsbC9zcmMvbGliL2xvYWRQb2x5ZmlsbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2FkcyBwb2x5ZmlsbHMuXG4gKlxuICogQHBhcmFtICAgICAge0FycmF5fSAgICAgZXhwZWN0ZWRGZWF0dXJlcyAgVGhlIGV4cGVjdGVkIGZlYXR1cmVzXG4gKiBAcGFyYW0gICAgICB7RnVuY3Rpb259ICBsb2FkSGFuZGxlciAgICAgICBUaGUgY2FsbGJhY2tcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2FkUG9seWZpbGxzIChleHBlY3RlZEZlYXR1cmVzLCBsb2FkSGFuZGxlcikge1xuICAvLyBJZiBhbnkgZmVhdHVyZXMgbmVlZCB0byBiZSBwb2x5ZmlsbGVkLlxuICBpZiAoZXhwZWN0ZWRGZWF0dXJlcy5zb21lKGlzTm90RnVuY3Rpb24pKSB7XG4gICAgLy8gTGlzdCB0aGUgZmVhdHVyZXMgdGhhdCBuZWVkIHRvIGJlIHBvbHlmaWxsZWQuXG4gICAgbGV0IG1pc3NpbmdGZWF0dXJlcyA9IGV4cGVjdGVkRmVhdHVyZXMuZmlsdGVyKGlzTm90RnVuY3Rpb24pXG4gICAgLy8gQ3JlYXRlIHRoZSB1cmwgd2l0aCAndWEnIHNldCB0byBhIHN1cHBvcnRlZCBicm93c2VyIGFuZCAnYWx3YXlzJ1xuICAgIGxldCBzcmMgPSAnaHR0cHM6Ly9wb2x5ZmlsbC5pby92Mi9wb2x5ZmlsbC5taW4uanM/ZmVhdHVyZXM9JyArIG1pc3NpbmdGZWF0dXJlcy5qb2luKCcsJykgKyAnJmZsYWdzPWdhdGVkLGFsd2F5cyZ1YT1jaHJvbWUvNTAnXG4gICAgLy8gQ3JlYXRlIGEgc2NyaXB0IHRhZywgbG9hZCB0aGUgcG9seWZpbGxzIGluIGl0IGFuZCBhZGQgaXQgdG8gaGVhZC5cbiAgICBsb2FkU2NyaXB0KHNyYywgbG9hZEhhbmRsZXIpXG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgbm8gcG9seWZpbGxzIGFyZSByZXF1aXJlZCwgaW52b2tlIHRoZSBhcHAuXG4gICAgbG9hZEhhbmRsZXIoKVxuICB9XG59XG5cbi8vIEZvciBub3cganVzdCBjaGVraW5nIGlmIHRoZSBmZWF0dXJlIGlzIG5vdCBhIGZ1bmN0aW9uLlxuLy8gVE9ETyBBIGxpc3QgdG8gZGlmZXJlbmNpYXRlIGV4ZXB0aW9ucyBhbmQgY3JlYXRlIGZpbHRlcnMgdG8gaGFuZGxlIHRoZW0uXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcmVxdWVzdGVkIGZlYXR1cmUgaXMgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICAgICAge2dsb2JhbCBwcm9wZXJ0eX0gICBmZWF0dXJlICBUaGUgYnJvd3NlciBmZWF0dXJlXG4gKiBAcmV0dXJuICAgICB7Ym9vbGVhbn0gICAgICAgICAgIFRydWUgaWYgbm90IGZ1bmN0aW9uLCBGYWxzZSBvdGhlcndpc2UuXG4gKi9cbmNvbnN0IGlzTm90RnVuY3Rpb24gPSBmZWF0dXJlID0+IHR5cGVvZiBmZWF0dXJlLnNwbGl0KCcuJykucmVkdWNlKChnbG9iYWwsIHByb3ApID0+IGdsb2JhbFtwcm9wXSwgd2luZG93KSAhPT0gJ2Z1bmN0aW9uJ1xuXG4vKipcbiAqIExvYWRzIGEgc2NyaXB0IGluIHRoZSBoZWFkIGVsZW1lbnQsIGFuZCBjYWxscyBiYWNrIHdoZW4gbG9hZGVkLlxuICpcbiAqIEBwYXJhbSAgICAgIHtzdHJpbmd9ICAgIHVybCAgICAgVGhlIHNvdXJjZSB1cmxcbiAqIEBwYXJhbSAgICAgIHtGdW5jdGlvbn0gIGNiICAgIFRoZSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBsb2FkU2NyaXB0ICh1cmwsIGNiKSB7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICBzY3JpcHQuc3JjID0gdXJsXG4gIHNjcmlwdC5vbmxvYWQgPSAoKSA9PiBjYigpXG4gIHNjcmlwdC5vbmVycm9yID0gKCkgPT4gY2IobmV3IFVSSUVycm9yKCdGYWlsZWQgdG8gbG9hZCBzY3JpcHQgJyArIHVybCkpXG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xpYi9sb2FkUG9seWZpbGxzLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQU1BOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _find = function _find(list, fn) {\n  return Array.prototype.find.call(list, fn);\n};\n\nvar getRuleIndex = function getRuleIndex(selector, styleSheet) {\n  var index = -1;\n  _find(styleSheet.cssRules, function (rule, idx) {\n    return rule.selectorText && rule.selectorText.toLowerCase() === selector.toLowerCase() ? index = idx : false;\n  });\n  return index;\n};\n\nvar findCSSRule = function findCSSRule(selector) {\n  var result = undefined;\n  var index = -1;\n  _find(document.styleSheets, function (styleSheet) {\n    index = getRuleIndex(selector, styleSheet);\n    return index !== -1 ? result = { sheet: styleSheet, index: index } : false;\n  });\n  return result || null;\n};\n\nmodule.exports = {\n  createStyleSheet: function createStyleSheet(id) {\n    var el = document.createElement('style');\n    el.appendChild(document.createTextNode(''));\n    el.media = 'screen';\n    if (id) el.id = id;\n    document.head.appendChild(el);\n    return el.sheet;\n  },\n  getCSSRule: function getCSSRule(selector, sheet) {\n    if (sheet) {\n      return sheet.cssRules[getRuleIndex(selector, sheet)];\n    }\n    var style = findCSSRule(selector);\n    return style.sheet.cssRules[style.index];\n  },\n  deleteCSSRule: function deleteCSSRule(selector, sheet) {\n    if (sheet) sheet.deleteRule(getRuleIndex(selector, sheet));else {\n      var style = findCSSRule(selector);\n      style.sheet.deleteRule(style.index);\n    }\n  },\n  addCSSRule: function addCSSRule(rule, sheet) {\n    sheet = sheet || document.styleSheets[0];\n    return sheet.cssRules[sheet.insertRule(rule, sheet.cssRules.length)];\n  },\n  updateCSSRule: function updateCSSRule(rule, sheet) {\n    var selectorRegex = /(.*?)(?= ?\\{)/;\n    var selector = rule.match(selectorRegex)[0];\n    this.deleteCSSRule(selector, sheet);\n    return this.addCSSRule(rule, sheet);\n  }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9qb3JnZS9kZXYvZ2FsbC9zcmMvbGliL3N0eWxlU2hlZXRUb29sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBfZmluZCA9IChsaXN0LCBmbikgPT4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChsaXN0LCBmbilcblxuY29uc3QgZ2V0UnVsZUluZGV4ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzdHlsZVNoZWV0KSB7XG4gIHZhciBpbmRleCA9IC0xXG4gIF9maW5kKHN0eWxlU2hlZXQuY3NzUnVsZXMsIChydWxlLCBpZHgpID0+IHtcbiAgICByZXR1cm4gcnVsZS5zZWxlY3RvclRleHQgJiZcbiAgICAgIHJ1bGUuc2VsZWN0b3JUZXh0LnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdG9yLnRvTG93ZXJDYXNlKClcbiAgICAgID8gKGluZGV4ID0gaWR4KVxuICAgICAgOiBmYWxzZVxuICB9KVxuICByZXR1cm4gaW5kZXhcbn1cblxuY29uc3QgZmluZENTU1J1bGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgbGV0IHJlc3VsdFxuICBsZXQgaW5kZXggPSAtMVxuICBfZmluZChkb2N1bWVudC5zdHlsZVNoZWV0cywgc3R5bGVTaGVldCA9PiB7XG4gICAgaW5kZXggPSBnZXRSdWxlSW5kZXgoc2VsZWN0b3IsIHN0eWxlU2hlZXQpXG4gICAgcmV0dXJuIGluZGV4ICE9PSAtMSA/IChyZXN1bHQgPSB7c2hlZXQ6IHN0eWxlU2hlZXQsIGluZGV4OiBpbmRleH0pIDogZmFsc2VcbiAgfSlcbiAgcmV0dXJuIHJlc3VsdCB8fCBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVTdHlsZVNoZWV0IChpZCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgICBlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJykpXG4gICAgZWwubWVkaWEgPSAnc2NyZWVuJ1xuICAgIGlmIChpZCkgZWwuaWQgPSBpZFxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWwpXG4gICAgcmV0dXJuIGVsLnNoZWV0XG4gIH0sXG4gIGdldENTU1J1bGUgKHNlbGVjdG9yLCBzaGVldCkge1xuICAgIGlmIChzaGVldCkge1xuICAgICAgcmV0dXJuIHNoZWV0LmNzc1J1bGVzW2dldFJ1bGVJbmRleChzZWxlY3Rvciwgc2hlZXQpXVxuICAgIH1cbiAgICB2YXIgc3R5bGUgPSBmaW5kQ1NTUnVsZShzZWxlY3RvcilcbiAgICByZXR1cm4gc3R5bGUuc2hlZXQuY3NzUnVsZXNbc3R5bGUuaW5kZXhdXG4gIH0sXG4gIGRlbGV0ZUNTU1J1bGUgKHNlbGVjdG9yLCBzaGVldCkge1xuICAgIGlmIChzaGVldCkgc2hlZXQuZGVsZXRlUnVsZShnZXRSdWxlSW5kZXgoc2VsZWN0b3IsIHNoZWV0KSlcbiAgICBlbHNlIHtcbiAgICAgIGxldCBzdHlsZSA9IGZpbmRDU1NSdWxlKHNlbGVjdG9yKVxuICAgICAgc3R5bGUuc2hlZXQuZGVsZXRlUnVsZShzdHlsZS5pbmRleClcbiAgICB9XG4gIH0sXG4gIGFkZENTU1J1bGUgKHJ1bGUsIHNoZWV0KSB7XG4gICAgc2hlZXQgPSBzaGVldCB8fCBkb2N1bWVudC5zdHlsZVNoZWV0c1swXVxuICAgIHJldHVybiBzaGVldC5jc3NSdWxlc1tzaGVldC5pbnNlcnRSdWxlKHJ1bGUsIHNoZWV0LmNzc1J1bGVzLmxlbmd0aCldXG4gIH0sXG4gIHVwZGF0ZUNTU1J1bGUgKHJ1bGUsIHNoZWV0KSB7XG4gICAgdmFyIHNlbGVjdG9yUmVnZXggPSAvKC4qPykoPz0gP1xceykvXG4gICAgdmFyIHNlbGVjdG9yID0gcnVsZS5tYXRjaChzZWxlY3RvclJlZ2V4KVswXVxuICAgIHRoaXMuZGVsZXRlQ1NTUnVsZShzZWxlY3Rvciwgc2hlZXQpXG4gICAgcmV0dXJuIHRoaXMuYWRkQ1NTUnVsZShydWxlLCBzaGVldClcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xpYi9zdHlsZVNoZWV0VG9vbC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// borrowed from: gascrolldepth.js | v0.9 Licensed under the MIT and GPL licenses.\n// Copyright (c) 2015 Rob Flaherty (@robflaherty), Leigh McCulloch (@___leigh___)\n\n\nmodule.exports = {\n  getDocumentHeight: function getDocumentHeight() {\n    return Math.max(document.documentElement.scrollHeight, document.body.scrollHeight, document.documentElement.offsetHeight, document.body.offsetHeight, document.documentElement.clientHeight);\n  },\n  getWindowWidth: function getWindowWidth() {\n    return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n  },\n  getWindowHeight: function getWindowHeight() {\n    return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n  },\n  getPageYOffset: function getPageYOffset() {\n    return window.pageYOffset || (document.compatMode === 'CSS1Compat' ? document.documentElement.scrollTop : document.body.scrollTop);\n  },\n  getElementYOffsetToDocumentTop: function getElementYOffsetToDocumentTop(element) {\n    return element.getBoundingClientRect().top + this.getPageYOffset();\n  }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL2xpYi93aW5kb3dTaXplLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGJvcnJvd2VkIGZyb206IGdhc2Nyb2xsZGVwdGguanMgfCB2MC45IExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlcy5cbi8vIENvcHlyaWdodCAoYykgMjAxNSBSb2IgRmxhaGVydHkgKEByb2JmbGFoZXJ0eSksIExlaWdoIE1jQ3VsbG9jaCAoQF9fX2xlaWdoX19fKVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldERvY3VtZW50SGVpZ2h0ICgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LCBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCxcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQsIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0LFxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgIClcbiAgfSxcbiAgZ2V0V2luZG93V2lkdGggKCkge1xuICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aFxuICB9LFxuICBnZXRXaW5kb3dIZWlnaHQgKCkge1xuICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodFxuICB9LFxuICBnZXRQYWdlWU9mZnNldCAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldCB8fCAoZG9jdW1lbnQuY29tcGF0TW9kZSA9PT0gJ0NTUzFDb21wYXQnID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA6IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKVxuICB9LFxuICBnZXRFbGVtZW50WU9mZnNldFRvRG9jdW1lbnRUb3AgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLmdldFBhZ2VZT2Zmc2V0KClcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xpYi93aW5kb3dTaXplLmpzIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(30);\n__webpack_require__(21);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvYm94L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vYm94LnRhZy5wdWcnKVxucmVxdWlyZSgnLi9ib3guY3NzJylcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL2JveC9pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(31);\n__webpack_require__(22);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvY29udGFpbmVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vY29udGFpbmVyLnRhZy5wdWcnKVxucmVxdWlyZSgnLi9jb250YWluZXIuY3NzJylcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL2NvbnRhaW5lci9pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(32);\n__webpack_require__(23);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvZ2FsbGVyaWVzLW1lbnUvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9nYWxsZXJpZXMtbWVudS50YWcucHVnJylcbnJlcXVpcmUoJy4vZ2FsbGVyaWVzLW1lbnUuY3NzJylcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL2dhbGxlcmllcy1tZW51L2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(24);\n__webpack_require__(33);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvaW1nLWNvbXAvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9pbWctY29tcC5jc3MnKVxucmVxdWlyZSgnLi9pbWctY29tcC50YWcucHVnJylcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL2ltZy1jb21wL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(34);\n__webpack_require__(25);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvanVzdGlmaWVkLWdhbGxlcnkvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9qdXN0aWZpZWQtZ2FsbGVyeS50YWcucHVnJylcbnJlcXVpcmUoJy4vanVzdGlmaWVkLWdhbGxlcnkuY3NzJylcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL2p1c3RpZmllZC1nYWxsZXJ5L2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(35);\n__webpack_require__(26);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvbW9kYWwvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9tb2RhbC50YWcucHVnJylcbnJlcXVpcmUoJy4vbW9kYWwuY3NzJylcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL21vZGFsL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(36);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvcmF3L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vcmF3LnRhZy5wdWcnKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZHVsZXMvcmF3L2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Store definition.\n// Stores application logic and state that relate to a specific domain.\n// Responds to relevant events emitted by the dispatcher and emmits\n// change events to any listening views, so that they may react/redraw themselves.\n\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports['default'] = GalleryStore;\nvar Riot = __webpack_require__(0);\nvar config = __webpack_require__(27);\nvar justifiedLayout = __webpack_require__(28);\nvar getJSON = __webpack_require__(6);\nvar view = __webpack_require__(10);\n\nvar _require = __webpack_require__(9);\n\nvar createStyleSheet = _require.createStyleSheet;\nvar addCSSRule = _require.addCSSRule;\n\nvar _require2 = __webpack_require__(1);\n\nvar IN = _require2.IN;\nvar OUT = _require2.OUT;\nvar END = _require2.END;\nvar NEXT = _require2.NEXT;\nvar PREV = _require2.PREV;\n\nfunction GalleryStore(event) {\n  var _this = this;\n\n  Riot.observable(this); // Riot provides our event emitter.\n\n  this.CHANGED_EVENT = 'CHANGED_EVENT';\n  this.dispatcher = event;\n  this.config = config;\n\n  var triggerChanged = function triggerChanged() {\n    // Brute force update all.\n    _this.trigger(_this.CHANGED_EVENT);\n  };\n\n  // Event handlers.\n  this.one(event.GALLERY_INIT, function () {\n    init();\n    setRoutes();\n  });\n\n  this.on(event.GALLERY_LOAD, function (id) {\n    loadGalleryData(id);\n  });\n\n  this.on(event.GALLERY_LOADED, function () {\n    computeLayout();\n    triggerChanged();\n  });\n\n  this.on(event.WINDOW_RESIZE, function () {\n    computeLayout();\n    if (_this.isZoomIn) event.trigger(event.IMG_ZOOM_OUT);\n    triggerChanged();\n  });\n\n  this.on(event.IMAGE_CLICK, function (id) {\n    if (_this.isZoomEnabled) {\n      return _this.isZoomIn ? event.trigger(event.IMG_ZOOM_OUT, id) : event.trigger(event.IMG_ZOOM_IN, id);\n    }\n  });\n\n  this.on(event.IMG_ZOOM_IN, function (id) {\n    updateZoomYOffset();\n    updateZoomStyle();\n    handleZoom(IN, id);\n    triggerChanged();\n  });\n\n  this.on(event.IMG_ZOOM_OUT, function (id) {\n    handleZoom(OUT, id);\n    triggerChanged();\n  });\n\n  this.on(event.TRANSITION_END, function (id) {\n    handleZoom(END, id);\n    triggerChanged();\n  });\n\n  this.on(event.SWITCH_IMAGE, function (img) {\n    zoomNext(img);\n  });\n\n  var init = function init() {\n    _this.width = config.width;\n    createZoomStyle();\n  };\n\n  // ------------------------------------------------------------\n\n  var setRoutes = function setRoutes() {\n    _this.routes = config.galleries.map(function (gall) {\n      return gall.dir;\n    });\n    Riot.route('/' + _this.config.route + '/*', selectGallery);\n    Riot.route.start(true);\n  };\n\n  var selectGallery = function selectGallery(gallery) {\n    if (_this.routes.indexOf(gallery) !== -1) {\n      event.trigger(event.GALLERY_LOAD, gallery);\n    }\n  };\n\n  // Load -- data\n  var loadGalleryData = function loadGalleryData(id) {\n    getJSON('/assets/galleries/' + id + '.json', loadGallery);\n  };\n\n  var loadGallery = function loadGallery(err, galleryData) {\n    if (err) throw err;\n    Object.assign(_this, galleryData);\n    _this.path = config.path + _this.dir;\n    _this.zoomWidth = _this.zoomWidth || config.zoomWidth;\n    _this.zoomHeight = _this.zoomHeight || config.zoomHeight;\n    event.trigger(event.GALLERY_LOADED);\n  };\n\n  // ------------------------------------------------------------\n  // Esto puede ir en un componente zoom-box\n\n  var computeLayout = function computeLayout() {\n    updateSizes();\n    _this.computeBoxesLayout();\n    if (ableToZoom()) computeZoomBox();\n  };\n\n  // Window size calculations helper\n  var updateSizes = function updateSizes() {\n    var winWidth = view.getWindowWidth();\n    _this.width = config.width < winWidth ? config.width : winWidth - 30;\n    _this.clientHeight = view.getWindowHeight();\n  };\n  // Zoom -- calculations\n  var computeZoomBox = function computeZoomBox() {\n    var zoomBox = _this.zoomBox = {};\n    zoomBox.width = _this.zoomWidth < _this.width ? _this.zoomWidth : _this.width - 20;\n    zoomBox.height = _this.zoomHeight < _this.clientHeight ? _this.zoomHeight : _this.clientHeight - 40;\n    zoomBox.top = (_this.height - zoomBox.height) / 2;\n    zoomBox.left = (_this.width - zoomBox.width) / 2;\n  };\n  // Zoom -- calculations\n  var updateZoomYOffset = function updateZoomYOffset() {\n    var room = view.getWindowHeight() < _this.height ? view.getWindowHeight() : _this.height;\n    _this.zoomBox.top = (room - _this.zoomBox.height) / 2 + view.getPageYOffset() - 10;\n  };\n  // Zoom -- zooms out the current image if any an zooms in the nex or previous\n  var zoomNext = function zoomNext(direction) {\n    var zoomByIndex = function zoomByIndex(idx) {\n      return event.trigger(event.IMG_ZOOM_IN, _this.entries[idx].id);\n    };\n    var index = 0;\n    if (_this.isZoomIn) {\n      // Get index of current image.\n      index = _this.entries.findIndex(function (entry) {\n        return entry.id === _this.zoomId;\n      });\n      // Zoom outs current.\n      event.trigger(event.IMG_ZOOM_OUT, _this.zoomId);\n      // get the index to be zoomed\n      index = direction === NEXT ? ++index : direction === PREV ? --index : 0;\n\n      if (index >= 0 && index < _this.entries.length) {\n        // zoomin the next image when the zoomouttransition finishes.\n        _this.one(event.TRANSITION_END, function () {\n          zoomByIndex(index);\n        });\n      }\n      // If no image is zoomed, zooms the first one.\n    } else if (direction === NEXT) zoomByIndex(index);\n  };\n  // Zoom -- toggling css and keeping state\n  var handleZoom = function handleZoom(type, id) {\n    id = id || _this.zoomId;\n    if (!id) return false;\n\n    var box = _this.entries.find(function (entry) {\n      return entry.id === id;\n    });\n\n    switch (type) {\n      case IN:\n        _this.zoomId = id;\n        _this.isZoomIn = true;\n        _this.showModal = true;\n        box.toFront = true;\n        box.zoomIn = true;\n        return true;\n      case OUT:\n        // this.zoomId = null\n        _this.isZoomIn = false;\n        _this.showModal = false;\n        box.zoomIn = false;\n        return true;\n      case END:\n        if (!_this.isZoomIn) {\n          box.toFront = false;\n          _this.zoomId = null;\n        }\n        return true;\n      default:\n        return console.error('Zoom types are: \"IN\", \"OUT\", \"END\".');\n    }\n  };\n\n  // Zoom -- dynamic style\n  var createZoomStyle = function createZoomStyle() {\n    // A styleSheet for the dynamic styles.\n    _this.styleSheet = createStyleSheet({ id: 'this-styles' });\n    // Dynamic css rule for the zoom box.\n    _this.zoomCSSRule = addCSSRule('.zoomin {}', _this.styleSheet);\n  };\n\n  // Zoom -- Manual update zoom style box props: top, left, width, height.\n  var updateZoomStyle = function updateZoomStyle() {\n    for (var prop in _this.zoomBox) {\n      _this.zoomCSSRule.style.setProperty(prop, _this.zoomBox[prop] + 'px', 'important');\n    }\n  };\n\n  // Zoom -- disable the zoom in small devices.\n  var ableToZoom = function ableToZoom() {\n    return (_this.isZoomEnabled = _this.width) > 663;\n  };\n}\n\n// Layout -- images using justifiedLayout\nGalleryStore.prototype.computeBoxesLayout = function () {\n  var geometry = justifiedLayout(this.ratios, {\n    containerWidth: this.width,\n    fullWidthBreakoutRowCadence: this.fullWidthCadence\n  });\n  this.entries = this.entries.map(function (entry, idx) {\n    return _extends({}, entry, geometry.boxes[idx], { idx: idx, zoomIn: false, toFront: false });\n  });\n\n  this.height = geometry.containerHeight;\n};\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL3N0b3Jlcy9nYWxsZXJ5LXN0b3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFN0b3JlIGRlZmluaXRpb24uXG4vLyBTdG9yZXMgYXBwbGljYXRpb24gbG9naWMgYW5kIHN0YXRlIHRoYXQgcmVsYXRlIHRvIGEgc3BlY2lmaWMgZG9tYWluLlxuLy8gUmVzcG9uZHMgdG8gcmVsZXZhbnQgZXZlbnRzIGVtaXR0ZWQgYnkgdGhlIGRpc3BhdGNoZXIgYW5kIGVtbWl0c1xuLy8gY2hhbmdlIGV2ZW50cyB0byBhbnkgbGlzdGVuaW5nIHZpZXdzLCBzbyB0aGF0IHRoZXkgbWF5IHJlYWN0L3JlZHJhdyB0aGVtc2VsdmVzLlxuXG5jb25zdCBSaW90ID0gcmVxdWlyZSgncmlvdCcpXG5jb25zdCBjb25maWcgPSByZXF1aXJlKCcuLi8uLi9kYXRhL2NvbmZpZy5qc29uJylcbmNvbnN0IGp1c3RpZmllZExheW91dCA9IHJlcXVpcmUoJ2p1c3RpZmllZC1sYXlvdXQnKVxuY29uc3QgZ2V0SlNPTiA9IHJlcXVpcmUoJy4uL2xpYi9nZXRKU09OJylcbmNvbnN0IHZpZXcgPSByZXF1aXJlKCcuLi9saWIvd2luZG93U2l6ZScpXG5jb25zdCB7Y3JlYXRlU3R5bGVTaGVldCwgYWRkQ1NTUnVsZX0gPSByZXF1aXJlKCcuLi9saWIvc3R5bGVTaGVldFRvb2wnKVxuY29uc3Qge0lOLCBPVVQsIEVORCwgTkVYVCwgUFJFVn0gPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBHYWxsZXJ5U3RvcmUgKGV2ZW50KSB7XG4gIFJpb3Qub2JzZXJ2YWJsZSh0aGlzKSAvLyBSaW90IHByb3ZpZGVzIG91ciBldmVudCBlbWl0dGVyLlxuXG4gIHRoaXMuQ0hBTkdFRF9FVkVOVCA9ICdDSEFOR0VEX0VWRU5UJ1xuICB0aGlzLmRpc3BhdGNoZXIgPSBldmVudFxuICB0aGlzLmNvbmZpZyA9IGNvbmZpZ1xuXG4gIGNvbnN0IHRyaWdnZXJDaGFuZ2VkID0gKCkgPT4ge1xuICAgIC8vIEJydXRlIGZvcmNlIHVwZGF0ZSBhbGwuXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuQ0hBTkdFRF9FVkVOVClcbiAgfVxuXG4gIC8vIEV2ZW50IGhhbmRsZXJzLlxuICB0aGlzLm9uZShldmVudC5HQUxMRVJZX0lOSVQsICgpID0+IHtcbiAgICBpbml0KClcbiAgICBzZXRSb3V0ZXMoKVxuICB9KVxuXG4gIHRoaXMub24oZXZlbnQuR0FMTEVSWV9MT0FELCAoaWQpID0+IHtcbiAgICBsb2FkR2FsbGVyeURhdGEoaWQpXG4gIH0pXG5cbiAgdGhpcy5vbihldmVudC5HQUxMRVJZX0xPQURFRCwgKCkgPT4ge1xuICAgIGNvbXB1dGVMYXlvdXQoKVxuICAgIHRyaWdnZXJDaGFuZ2VkKClcbiAgfSlcblxuICB0aGlzLm9uKGV2ZW50LldJTkRPV19SRVNJWkUsICgpID0+IHtcbiAgICBjb21wdXRlTGF5b3V0KClcbiAgICBpZiAodGhpcy5pc1pvb21JbikgZXZlbnQudHJpZ2dlcihldmVudC5JTUdfWk9PTV9PVVQpXG4gICAgdHJpZ2dlckNoYW5nZWQoKVxuICB9KVxuXG4gIHRoaXMub24oZXZlbnQuSU1BR0VfQ0xJQ0ssIChpZCkgPT4ge1xuICAgIGlmICh0aGlzLmlzWm9vbUVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzWm9vbUluXG4gICAgICAgID8gZXZlbnQudHJpZ2dlcihldmVudC5JTUdfWk9PTV9PVVQsIGlkKVxuICAgICAgICA6IGV2ZW50LnRyaWdnZXIoZXZlbnQuSU1HX1pPT01fSU4sIGlkKVxuICAgIH1cbiAgfSlcblxuICB0aGlzLm9uKGV2ZW50LklNR19aT09NX0lOLCAoaWQpID0+IHtcbiAgICB1cGRhdGVab29tWU9mZnNldCgpXG4gICAgdXBkYXRlWm9vbVN0eWxlKClcbiAgICBoYW5kbGVab29tKElOLCBpZClcbiAgICB0cmlnZ2VyQ2hhbmdlZCgpXG4gIH0pXG5cbiAgdGhpcy5vbihldmVudC5JTUdfWk9PTV9PVVQsIChpZCkgPT4ge1xuICAgIGhhbmRsZVpvb20oT1VULCBpZClcbiAgICB0cmlnZ2VyQ2hhbmdlZCgpXG4gIH0pXG5cbiAgdGhpcy5vbihldmVudC5UUkFOU0lUSU9OX0VORCwgKGlkKSA9PiB7XG4gICAgaGFuZGxlWm9vbShFTkQsIGlkKVxuICAgIHRyaWdnZXJDaGFuZ2VkKClcbiAgfSlcblxuICB0aGlzLm9uKGV2ZW50LlNXSVRDSF9JTUFHRSwgKGltZykgPT4ge1xuICAgIHpvb21OZXh0KGltZylcbiAgfSlcblxuICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgIHRoaXMud2lkdGggPSBjb25maWcud2lkdGhcbiAgICBjcmVhdGVab29tU3R5bGUoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgY29uc3Qgc2V0Um91dGVzID0gKCkgPT4ge1xuICAgIHRoaXMucm91dGVzID0gY29uZmlnLmdhbGxlcmllcy5tYXAoZ2FsbCA9PiBnYWxsLmRpcilcbiAgICBSaW90LnJvdXRlKGAvJHt0aGlzLmNvbmZpZy5yb3V0ZX0vKmAsIHNlbGVjdEdhbGxlcnkpXG4gICAgUmlvdC5yb3V0ZS5zdGFydCh0cnVlKVxuICB9XG5cbiAgY29uc3Qgc2VsZWN0R2FsbGVyeSA9IChnYWxsZXJ5KSA9PiB7XG4gICAgaWYgKHRoaXMucm91dGVzLmluZGV4T2YoZ2FsbGVyeSkgIT09IC0xKSB7XG4gICAgICBldmVudC50cmlnZ2VyKGV2ZW50LkdBTExFUllfTE9BRCwgZ2FsbGVyeSlcbiAgICB9XG4gIH1cblxuICAvLyBMb2FkIC0tIGRhdGFcbiAgY29uc3QgbG9hZEdhbGxlcnlEYXRhID0gKGlkKSA9PiB7XG4gICAgZ2V0SlNPTignL2Fzc2V0cy9nYWxsZXJpZXMvJyArIGlkICsgJy5qc29uJywgbG9hZEdhbGxlcnkpXG4gIH1cblxuICBjb25zdCBsb2FkR2FsbGVyeSA9IChlcnIsIGdhbGxlcnlEYXRhKSA9PiB7XG4gICAgaWYgKGVycikgdGhyb3cgZXJyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBnYWxsZXJ5RGF0YSlcbiAgICB0aGlzLnBhdGggPSBjb25maWcucGF0aCArIHRoaXMuZGlyXG4gICAgdGhpcy56b29tV2lkdGggPSB0aGlzLnpvb21XaWR0aCB8fCBjb25maWcuem9vbVdpZHRoXG4gICAgdGhpcy56b29tSGVpZ2h0ID0gdGhpcy56b29tSGVpZ2h0IHx8IGNvbmZpZy56b29tSGVpZ2h0XG4gICAgZXZlbnQudHJpZ2dlcihldmVudC5HQUxMRVJZX0xPQURFRClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBFc3RvIHB1ZWRlIGlyIGVuIHVuIGNvbXBvbmVudGUgem9vbS1ib3hcblxuICBjb25zdCBjb21wdXRlTGF5b3V0ID0gKCkgPT4ge1xuICAgIHVwZGF0ZVNpemVzKClcbiAgICB0aGlzLmNvbXB1dGVCb3hlc0xheW91dCgpXG4gICAgaWYgKGFibGVUb1pvb20oKSkgY29tcHV0ZVpvb21Cb3goKVxuICB9XG5cbiAgLy8gV2luZG93IHNpemUgY2FsY3VsYXRpb25zIGhlbHBlclxuICBjb25zdCB1cGRhdGVTaXplcyA9ICgpID0+IHtcbiAgICBsZXQgd2luV2lkdGggPSB2aWV3LmdldFdpbmRvd1dpZHRoKClcbiAgICB0aGlzLndpZHRoID0gY29uZmlnLndpZHRoIDwgd2luV2lkdGggPyBjb25maWcud2lkdGggOiB3aW5XaWR0aCAtIDMwXG4gICAgdGhpcy5jbGllbnRIZWlnaHQgPSB2aWV3LmdldFdpbmRvd0hlaWdodCgpXG4gIH1cbiAgLy8gWm9vbSAtLSBjYWxjdWxhdGlvbnNcbiAgY29uc3QgY29tcHV0ZVpvb21Cb3ggPSAoKSA9PiB7XG4gICAgbGV0IHpvb21Cb3ggPSB0aGlzLnpvb21Cb3ggPSB7fVxuICAgIHpvb21Cb3gud2lkdGggPSB0aGlzLnpvb21XaWR0aCA8IHRoaXMud2lkdGggPyB0aGlzLnpvb21XaWR0aCA6IHRoaXMud2lkdGggLSAyMFxuICAgIHpvb21Cb3guaGVpZ2h0ID0gdGhpcy56b29tSGVpZ2h0IDwgdGhpcy5jbGllbnRIZWlnaHQgPyB0aGlzLnpvb21IZWlnaHQgOiB0aGlzLmNsaWVudEhlaWdodCAtIDQwXG4gICAgem9vbUJveC50b3AgPSAodGhpcy5oZWlnaHQgLSB6b29tQm94LmhlaWdodCkgLyAyXG4gICAgem9vbUJveC5sZWZ0ID0gKHRoaXMud2lkdGggLSB6b29tQm94LndpZHRoKSAvIDJcbiAgfVxuICAvLyBab29tIC0tIGNhbGN1bGF0aW9uc1xuICBjb25zdCB1cGRhdGVab29tWU9mZnNldCA9ICgpID0+IHtcbiAgICBsZXQgcm9vbSA9IHZpZXcuZ2V0V2luZG93SGVpZ2h0KCkgPCB0aGlzLmhlaWdodCA/IHZpZXcuZ2V0V2luZG93SGVpZ2h0KCkgOiB0aGlzLmhlaWdodFxuICAgIHRoaXMuem9vbUJveC50b3AgPSAocm9vbSAtIHRoaXMuem9vbUJveC5oZWlnaHQpIC8gMiArIHZpZXcuZ2V0UGFnZVlPZmZzZXQoKSAtIDEwXG4gIH1cbiAgLy8gWm9vbSAtLSB6b29tcyBvdXQgdGhlIGN1cnJlbnQgaW1hZ2UgaWYgYW55IGFuIHpvb21zIGluIHRoZSBuZXggb3IgcHJldmlvdXNcbiAgY29uc3Qgem9vbU5leHQgPSAoZGlyZWN0aW9uKSA9PiB7XG4gICAgY29uc3Qgem9vbUJ5SW5kZXggPSAoaWR4KSA9PiBldmVudC50cmlnZ2VyKGV2ZW50LklNR19aT09NX0lOLCB0aGlzLmVudHJpZXNbaWR4XS5pZClcbiAgICBsZXQgaW5kZXggPSAwXG4gICAgaWYgKHRoaXMuaXNab29tSW4pIHtcbiAgICAgIC8vIEdldCBpbmRleCBvZiBjdXJyZW50IGltYWdlLlxuICAgICAgaW5kZXggPSB0aGlzLmVudHJpZXMuZmluZEluZGV4KGVudHJ5ID0+IGVudHJ5LmlkID09PSB0aGlzLnpvb21JZClcbiAgICAgIC8vIFpvb20gb3V0cyBjdXJyZW50LlxuICAgICAgZXZlbnQudHJpZ2dlcihldmVudC5JTUdfWk9PTV9PVVQsIHRoaXMuem9vbUlkKVxuICAgICAgLy8gZ2V0IHRoZSBpbmRleCB0byBiZSB6b29tZWRcbiAgICAgIGluZGV4ID0gZGlyZWN0aW9uID09PSBORVhUID8gKytpbmRleCA6IGRpcmVjdGlvbiA9PT0gUFJFViA/IC0taW5kZXggOiAwXG5cbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5lbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAvLyB6b29taW4gdGhlIG5leHQgaW1hZ2Ugd2hlbiB0aGUgem9vbW91dHRyYW5zaXRpb24gZmluaXNoZXMuXG4gICAgICAgIHRoaXMub25lKGV2ZW50LlRSQU5TSVRJT05fRU5ELCAoKSA9PiB7XG4gICAgICAgICAgem9vbUJ5SW5kZXgoaW5kZXgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgLy8gSWYgbm8gaW1hZ2UgaXMgem9vbWVkLCB6b29tcyB0aGUgZmlyc3Qgb25lLlxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBORVhUKSB6b29tQnlJbmRleChpbmRleClcbiAgfVxuICAvLyBab29tIC0tIHRvZ2dsaW5nIGNzcyBhbmQga2VlcGluZyBzdGF0ZVxuICBjb25zdCBoYW5kbGVab29tID0gKHR5cGUsIGlkKSA9PiB7XG4gICAgaWQgPSBpZCB8fCB0aGlzLnpvb21JZFxuICAgIGlmICghaWQpIHJldHVybiBmYWxzZVxuXG4gICAgbGV0IGJveCA9IHRoaXMuZW50cmllcy5maW5kKGVudHJ5ID0+IGVudHJ5LmlkID09PSBpZClcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBJTjpcbiAgICAgICAgdGhpcy56b29tSWQgPSBpZFxuICAgICAgICB0aGlzLmlzWm9vbUluID0gdHJ1ZVxuICAgICAgICB0aGlzLnNob3dNb2RhbCA9IHRydWVcbiAgICAgICAgYm94LnRvRnJvbnQgPSB0cnVlXG4gICAgICAgIGJveC56b29tSW4gPSB0cnVlXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBjYXNlIE9VVDpcbiAgICAgICAgLy8gdGhpcy56b29tSWQgPSBudWxsXG4gICAgICAgIHRoaXMuaXNab29tSW4gPSBmYWxzZVxuICAgICAgICB0aGlzLnNob3dNb2RhbCA9IGZhbHNlXG4gICAgICAgIGJveC56b29tSW4gPSBmYWxzZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgY2FzZSBFTkQ6XG4gICAgICAgIGlmICghdGhpcy5pc1pvb21Jbikge1xuICAgICAgICAgIGJveC50b0Zyb250ID0gZmFsc2VcbiAgICAgICAgICB0aGlzLnpvb21JZCA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1pvb20gdHlwZXMgYXJlOiBcIklOXCIsIFwiT1VUXCIsIFwiRU5EXCIuJylcbiAgICB9XG4gIH1cblxuICAvLyBab29tIC0tIGR5bmFtaWMgc3R5bGVcbiAgY29uc3QgY3JlYXRlWm9vbVN0eWxlID0gKCkgPT4ge1xuICAgIC8vIEEgc3R5bGVTaGVldCBmb3IgdGhlIGR5bmFtaWMgc3R5bGVzLlxuICAgIHRoaXMuc3R5bGVTaGVldCA9IGNyZWF0ZVN0eWxlU2hlZXQoe2lkOiAndGhpcy1zdHlsZXMnfSlcbiAgICAvLyBEeW5hbWljIGNzcyBydWxlIGZvciB0aGUgem9vbSBib3guXG4gICAgdGhpcy56b29tQ1NTUnVsZSA9IGFkZENTU1J1bGUoJy56b29taW4ge30nLCB0aGlzLnN0eWxlU2hlZXQpXG4gIH1cblxuICAvLyBab29tIC0tIE1hbnVhbCB1cGRhdGUgem9vbSBzdHlsZSBib3ggcHJvcHM6IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodC5cbiAgY29uc3QgdXBkYXRlWm9vbVN0eWxlID0gKCkgPT4ge1xuICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy56b29tQm94KSB7XG4gICAgICB0aGlzLnpvb21DU1NSdWxlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIHRoaXMuem9vbUJveFtwcm9wXSArICdweCcsICdpbXBvcnRhbnQnKVxuICAgIH1cbiAgfVxuXG4gIC8vIFpvb20gLS0gZGlzYWJsZSB0aGUgem9vbSBpbiBzbWFsbCBkZXZpY2VzLlxuICBjb25zdCBhYmxlVG9ab29tID0gKCkgPT4gKHRoaXMuaXNab29tRW5hYmxlZCA9IHRoaXMud2lkdGgpID4gNjYzXG59XG5cbi8vIExheW91dCAtLSBpbWFnZXMgdXNpbmcganVzdGlmaWVkTGF5b3V0XG5HYWxsZXJ5U3RvcmUucHJvdG90eXBlLmNvbXB1dGVCb3hlc0xheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGdlb21ldHJ5ID0ganVzdGlmaWVkTGF5b3V0KHRoaXMucmF0aW9zLFxuICAgIHtcbiAgICAgIGNvbnRhaW5lcldpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgZnVsbFdpZHRoQnJlYWtvdXRSb3dDYWRlbmNlOiB0aGlzLmZ1bGxXaWR0aENhZGVuY2VcbiAgICB9KVxuICB0aGlzLmVudHJpZXMgPSB0aGlzLmVudHJpZXNcbiAgICAubWFwKChlbnRyeSwgaWR4KSA9PiAoey4uLmVudHJ5LCAuLi5nZW9tZXRyeS5ib3hlc1tpZHhdLCBpZHgsIHpvb21JbjogZmFsc2UsIHRvRnJvbnQ6IGZhbHNlfSkpXG5cbiAgdGhpcy5oZWlnaHQgPSBnZW9tZXRyeS5jb250YWluZXJIZWlnaHRcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zdG9yZXMvZ2FsbGVyeS1zdG9yZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQWFBO0FBUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = PortfolioStore;\nvar GalleryStore = __webpack_require__(18);\nvar inherits = __webpack_require__(7);\n\nfunction PortfolioStore(dispatcher) {\n  GalleryStore.call(this, dispatcher);\n}\n\ninherits(PortfolioStore, GalleryStore);\n\nPortfolioStore.prototype.computeBoxesLayout = function () {\n  // console.log(this.ratios, ' - ', this.width)\n  this.ratios = this.entries.length === 5 && this.width >= 1055 ? [1.33, 1.33, 1.21, 1.21, 1.21] : [1.33, 1.33, 1.33, 1.33, 1.33];\n\n  this.fullWidthCadence = this.entries.length === 5 && this.width > 663 && this.width <= 875 ? 2 : false;\n\n  PortfolioStore.super_.prototype.computeBoxesLayout.call(this);\n};\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL3N0b3Jlcy9wb3J0Zm9saW8tc3RvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgR2FsbGVyeVN0b3JlID0gcmVxdWlyZSgnLi9nYWxsZXJ5LXN0b3JlLmpzJylcbmNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgnLi4vbGliL2luaGVyaXRzJylcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9ydGZvbGlvU3RvcmUgKGRpc3BhdGNoZXIpIHtcbiAgR2FsbGVyeVN0b3JlLmNhbGwodGhpcywgZGlzcGF0Y2hlcilcbn1cblxuaW5oZXJpdHMoUG9ydGZvbGlvU3RvcmUsIEdhbGxlcnlTdG9yZSlcblxuUG9ydGZvbGlvU3RvcmUucHJvdG90eXBlLmNvbXB1dGVCb3hlc0xheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gY29uc29sZS5sb2codGhpcy5yYXRpb3MsICcgLSAnLCB0aGlzLndpZHRoKVxuICB0aGlzLnJhdGlvcyA9IHRoaXMuZW50cmllcy5sZW5ndGggPT09IDUgJiYgdGhpcy53aWR0aCA+PSAxMDU1XG4gICAgPyBbMS4zMywgMS4zMywgMS4yMSwgMS4yMSwgMS4yMV1cbiAgICA6IFsxLjMzLCAxLjMzLCAxLjMzLCAxLjMzLCAxLjMzXVxuXG4gIHRoaXMuZnVsbFdpZHRoQ2FkZW5jZSA9IHRoaXMuZW50cmllcy5sZW5ndGggPT09IDUgJiYgdGhpcy53aWR0aCA+IDY2MyAmJiB0aGlzLndpZHRoIDw9IDg3NVxuICAgID8gMlxuICAgIDogZmFsc2VcblxuICBQb3J0Zm9saW9TdG9yZS5zdXBlcl8ucHJvdG90eXBlLmNvbXB1dGVCb3hlc0xheW91dC5jYWxsKHRoaXMpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc3RvcmVzL3BvcnRmb2xpby1zdG9yZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFHQTtBQUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL2Nzcy9tYWluLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Nzcy9tYWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvYm94L2JveC5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tb2R1bGVzL2JveC9ib3guY3NzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvY29udGFpbmVyL2NvbnRhaW5lci5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tb2R1bGVzL2NvbnRhaW5lci9jb250YWluZXIuY3NzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvZ2FsbGVyaWVzLW1lbnUvZ2FsbGVyaWVzLW1lbnUuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbW9kdWxlcy9nYWxsZXJpZXMtbWVudS9nYWxsZXJpZXMtbWVudS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 24 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvaW1nLWNvbXAvaW1nLWNvbXAuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbW9kdWxlcy9pbWctY29tcC9pbWctY29tcC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 25 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvanVzdGlmaWVkLWdhbGxlcnkvanVzdGlmaWVkLWdhbGxlcnkuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbW9kdWxlcy9qdXN0aWZpZWQtZ2FsbGVyeS9qdXN0aWZpZWQtZ2FsbGVyeS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 26 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvbW9kYWwvbW9kYWwuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbW9kdWxlcy9tb2RhbC9tb2RhbC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 27 */
/***/ (function(module, exports) {

eval("module.exports = {\n\t\"first\": \"Popular_Pensiones_2007\",\n\t\"path\": \"/assets/galleries/\",\n\t\"galleries\": [\n\t\t{\n\t\t\t\"dir\": \"Muebles_Conceptuales\",\n\t\t\t\"name\": \"Muebles Conceptuales\"\n\t\t},\n\t\t{\n\t\t\t\"dir\": \"Popular_Pensiones_2004\",\n\t\t\t\"name\": \"Popular Pensiones 2004\"\n\t\t},\n\t\t{\n\t\t\t\"dir\": \"Popular_Pensiones_2007\",\n\t\t\t\"name\": \"Popular Pensiones 2007\"\n\t\t}\n\t],\n\t\"width\": 1060,\n\t\"zoomWidth\": 768,\n\t\"zoomHeight\": 576,\n\t\"fullWidthCadence\": false,\n\t\"route\": \"Proyecto\",\n\t\"lang\": \"en\"\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvZGF0YS9jb25maWcuanNvbiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJmaXJzdFwiOiBcIlBvcHVsYXJfUGVuc2lvbmVzXzIwMDdcIixcblx0XCJwYXRoXCI6IFwiL2Fzc2V0cy9nYWxsZXJpZXMvXCIsXG5cdFwiZ2FsbGVyaWVzXCI6IFtcblx0XHR7XG5cdFx0XHRcImRpclwiOiBcIk11ZWJsZXNfQ29uY2VwdHVhbGVzXCIsXG5cdFx0XHRcIm5hbWVcIjogXCJNdWVibGVzIENvbmNlcHR1YWxlc1wiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcImRpclwiOiBcIlBvcHVsYXJfUGVuc2lvbmVzXzIwMDRcIixcblx0XHRcdFwibmFtZVwiOiBcIlBvcHVsYXIgUGVuc2lvbmVzIDIwMDRcIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJkaXJcIjogXCJQb3B1bGFyX1BlbnNpb25lc18yMDA3XCIsXG5cdFx0XHRcIm5hbWVcIjogXCJQb3B1bGFyIFBlbnNpb25lcyAyMDA3XCJcblx0XHR9XG5cdF0sXG5cdFwid2lkdGhcIjogMTA2MCxcblx0XCJ6b29tV2lkdGhcIjogNzY4LFxuXHRcInpvb21IZWlnaHRcIjogNTc2LFxuXHRcImZ1bGxXaWR0aENhZGVuY2VcIjogZmFsc2UsXG5cdFwicm91dGVcIjogXCJQcm95ZWN0b1wiLFxuXHRcImxhbmdcIjogXCJlblwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGF0YS9jb25maWcuanNvblxuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright 2016 Yahoo Inc.\n// Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.\n\n\n\nvar merge = __webpack_require__(3),\n    Row = __webpack_require__(29),\n    layoutConfig = {},\n    layoutData = {},\n    currentRow = false;\n\n/**\n* Takes in a bunch of box data and config. Returns\n* geometry to lay them out in a justified view.\n*\n* @method covertSizesToAspectRatios\n* @param sizes {Array} Array of objects with widths and heights\n* @return {Array} A list of aspect ratios\n**/\nmodule.exports = function (input) {\n\tvar config = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t// Defaults\n\tvar defaults = {\n\t\tcontainerWidth: 1060,\n\t\tcontainerPadding: 10,\n\t\tboxSpacing: 10,\n\t\ttargetRowHeight: 320,\n\t\ttargetRowHeightTolerance: 0.25,\n\t\tmaxNumRows: Number.POSITIVE_INFINITY,\n\t\tforceAspectRatio: false,\n\t\tshowWidows: true,\n\t\tfullWidthBreakoutRowCadence: false\n\t};\n\n\t// Merge defaults and config passed in\n\tlayoutConfig = merge(defaults, config);\n\n\t// Sort out padding and spacing values\n\tvar containerPadding = {};\n\tvar boxSpacing = {};\n\n\tcontainerPadding.top = !isNaN(parseFloat(layoutConfig.containerPadding.top)) ? layoutConfig.containerPadding.top : layoutConfig.containerPadding;\n\tcontainerPadding.right = !isNaN(parseFloat(layoutConfig.containerPadding.right)) ? layoutConfig.containerPadding.right : layoutConfig.containerPadding;\n\tcontainerPadding.bottom = !isNaN(parseFloat(layoutConfig.containerPadding.bottom)) ? layoutConfig.containerPadding.bottom : layoutConfig.containerPadding;\n\tcontainerPadding.left = !isNaN(parseFloat(layoutConfig.containerPadding.left)) ? layoutConfig.containerPadding.left : layoutConfig.containerPadding;\n\tboxSpacing.horizontal = !isNaN(parseFloat(layoutConfig.boxSpacing.horizontal)) ? layoutConfig.boxSpacing.horizontal : layoutConfig.boxSpacing;\n\tboxSpacing.vertical = !isNaN(parseFloat(layoutConfig.boxSpacing.vertical)) ? layoutConfig.boxSpacing.vertical : layoutConfig.boxSpacing;\n\n\tlayoutConfig.containerPadding = containerPadding;\n\tlayoutConfig.boxSpacing = boxSpacing;\n\n\t// Local\n\tlayoutData._layoutItems = [];\n\tlayoutData._awakeItems = [];\n\tlayoutData._inViewportItems = [];\n\tlayoutData._leadingOrphans = [];\n\tlayoutData._trailingOrphans = [];\n\tlayoutData._containerHeight = layoutConfig.containerPadding.top;\n\tlayoutData._rows = [];\n\tlayoutData._orphans = [];\n\tlayoutConfig._widowCount = 0;\n\n\t// Convert widths and heights to aspect ratios if we need to\n\treturn computeLayout(input.map(function (item) {\n\t\tif (item.width && item.height) {\n\t\t\treturn { aspectRatio: item.width / item.height };\n\t\t} else {\n\t\t\treturn { aspectRatio: item };\n\t\t}\n\t}));\n};\n\n/**\n* Calculate the current layout for all items in the list that require layout.\n* \"Layout\" means geometry: position within container and size\n*\n* @method computeLayout\n* @param itemLayoutData {Array} Array of items to lay out, with data required to lay out each item\n* @return {Object} The newly-calculated layout, containing the new container height, and lists of layout items\n*/\nfunction computeLayout(itemLayoutData) {\n\n\tvar laidOutItems = [],\n\t    itemAdded,\n\t    currentRow,\n\t    nextToLastRowHeight;\n\n\t// Apply forced aspect ratio if specified, and set a flag.\n\tif (layoutConfig.forceAspectRatio) {\n\t\titemLayoutData.forEach(function (itemData) {\n\t\t\titemData.forcedAspectRatio = true;\n\t\t\titemData.aspectRatio = layoutConfig.forceAspectRatio;\n\t\t});\n\t}\n\n\t// Loop through the items\n\titemLayoutData.some(function (itemData, i) {\n\n\t\tif (isNaN(itemData.aspectRatio)) {\n\t\t\tthrow new Error(\"Item \" + i + \" has an invalid aspect ratio\");\n\t\t}\n\n\t\t// If not currently building up a row, make a new one.\n\t\tif (!currentRow) {\n\t\t\tcurrentRow = createNewRow();\n\t\t}\n\n\t\t// Attempt to add item to the current row.\n\t\titemAdded = currentRow.addItem(itemData);\n\n\t\tif (currentRow.isLayoutComplete()) {\n\n\t\t\t// Row is filled; add it and start a new one\n\t\t\tlaidOutItems = laidOutItems.concat(addRow(currentRow));\n\n\t\t\tif (layoutData._rows.length >= layoutConfig.maxNumRows) {\n\t\t\t\tcurrentRow = null;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tcurrentRow = createNewRow();\n\n\t\t\t// Item was rejected; add it to its own row\n\t\t\tif (!itemAdded) {\n\n\t\t\t\titemAdded = currentRow.addItem(itemData);\n\n\t\t\t\tif (currentRow.isLayoutComplete()) {\n\n\t\t\t\t\t// If the rejected item fills a row on its own, add the row and start another new one\n\t\t\t\t\tlaidOutItems = laidOutItems.concat(addRow(currentRow));\n\t\t\t\t\tif (layoutData._rows.length >= layoutConfig.maxNumRows) {\n\t\t\t\t\t\tcurrentRow = null;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentRow = createNewRow();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Handle any leftover content (orphans) depending on where they lie\n\t// in this layout update, and in the total content set.\n\tif (currentRow && currentRow.getItems().length && layoutConfig.showWidows) {\n\n\t\t// Last page of all content or orphan suppression is suppressed; lay out orphans.\n\t\tif (layoutData._rows.length) {\n\n\t\t\t// Only Match previous row's height if it exists and it isn't a breakout row\n\t\t\tif (layoutData._rows[layoutData._rows.length - 1].isBreakoutRow) {\n\t\t\t\tnextToLastRowHeight = layoutData._rows[layoutData._rows.length - 1].targetRowHeight;\n\t\t\t} else {\n\t\t\t\tnextToLastRowHeight = layoutData._rows[layoutData._rows.length - 1].height;\n\t\t\t}\n\n\t\t\tcurrentRow.forceComplete(false, nextToLastRowHeight);\n\t\t} else {\n\n\t\t\t// ...else use target height if there is no other row height to reference.\n\t\t\tcurrentRow.forceComplete(false);\n\t\t}\n\n\t\tlaidOutItems = laidOutItems.concat(addRow(currentRow));\n\t\tlayoutConfig._widowCount = currentRow.getItems().length;\n\t}\n\n\t// We need to clean up the bottom container padding\n\t// First remove the height added for box spacing\n\tlayoutData._containerHeight = layoutData._containerHeight - layoutConfig.boxSpacing.vertical;\n\t// Then add our bottom container padding\n\tlayoutData._containerHeight = layoutData._containerHeight + layoutConfig.containerPadding.bottom;\n\n\treturn {\n\t\tcontainerHeight: layoutData._containerHeight,\n\t\twidowCount: layoutConfig._widowCount,\n\t\tboxes: layoutData._layoutItems\n\t};\n}\n\n/**\n* Create a new, empty row.\n*\n* @method createNewRow\n* @return A new, empty row of the type specified by this layout.\n*/\nfunction createNewRow() {\n\n\t// Work out if this is a full width breakout row\n\tif (layoutConfig.fullWidthBreakoutRowCadence !== false) {\n\t\tif ((layoutData._rows.length + 1) % layoutConfig.fullWidthBreakoutRowCadence === 0) {\n\t\t\tvar isBreakoutRow = true;\n\t\t}\n\t}\n\n\treturn new Row({\n\t\ttop: layoutData._containerHeight,\n\t\tleft: layoutConfig.containerPadding.left,\n\t\twidth: layoutConfig.containerWidth - layoutConfig.containerPadding.left - layoutConfig.containerPadding.right,\n\t\tspacing: layoutConfig.boxSpacing.horizontal,\n\t\ttargetRowHeight: layoutConfig.targetRowHeight,\n\t\ttargetRowHeightTolerance: layoutConfig.targetRowHeightTolerance,\n\t\tedgeCaseMinRowHeight: 0.5 * layoutConfig.targetRowHeight,\n\t\tedgeCaseMaxRowHeight: 2 * layoutConfig.targetRowHeight,\n\t\trightToLeft: false,\n\t\tisBreakoutRow: isBreakoutRow\n\t});\n}\n\n/**\n * Add a completed row to the layout.\n * Note: the row must have already been completed.\n *\n * @method addRow\n * @param row {Row} The row to add.\n * @return {Array} Each item added to the row.\n */\nfunction addRow(row) {\n\n\tlayoutData._rows.push(row);\n\tlayoutData._layoutItems = layoutData._layoutItems.concat(row.getItems());\n\n\t// Increment the container height\n\tlayoutData._containerHeight += row.height + layoutConfig.boxSpacing.vertical;\n\n\treturn row.items;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvbm9kZV9tb2R1bGVzL2p1c3RpZmllZC1sYXlvdXQvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE2IFlhaG9vIEluYy5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIGxpY2Vuc2UuIFBsZWFzZSBzZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIHRlcm1zLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtZXJnZSA9IHJlcXVpcmUoJ21lcmdlJyksXG4gICAgUm93ID0gcmVxdWlyZSgnLi9yb3cnKSxcbiAgICBsYXlvdXRDb25maWcgPSB7fSxcbiAgICBsYXlvdXREYXRhID0ge30sXG4gICAgY3VycmVudFJvdyA9IGZhbHNlO1xuXG4vKipcbiogVGFrZXMgaW4gYSBidW5jaCBvZiBib3ggZGF0YSBhbmQgY29uZmlnLiBSZXR1cm5zXG4qIGdlb21ldHJ5IHRvIGxheSB0aGVtIG91dCBpbiBhIGp1c3RpZmllZCB2aWV3LlxuKlxuKiBAbWV0aG9kIGNvdmVydFNpemVzVG9Bc3BlY3RSYXRpb3NcbiogQHBhcmFtIHNpemVzIHtBcnJheX0gQXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHdpZHRocyBhbmQgaGVpZ2h0c1xuKiBAcmV0dXJuIHtBcnJheX0gQSBsaXN0IG9mIGFzcGVjdCByYXRpb3NcbioqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblx0dmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG5cdC8vIERlZmF1bHRzXG5cdHZhciBkZWZhdWx0cyA9IHtcblx0XHRjb250YWluZXJXaWR0aDogMTA2MCxcblx0XHRjb250YWluZXJQYWRkaW5nOiAxMCxcblx0XHRib3hTcGFjaW5nOiAxMCxcblx0XHR0YXJnZXRSb3dIZWlnaHQ6IDMyMCxcblx0XHR0YXJnZXRSb3dIZWlnaHRUb2xlcmFuY2U6IDAuMjUsXG5cdFx0bWF4TnVtUm93czogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuXHRcdGZvcmNlQXNwZWN0UmF0aW86IGZhbHNlLFxuXHRcdHNob3dXaWRvd3M6IHRydWUsXG5cdFx0ZnVsbFdpZHRoQnJlYWtvdXRSb3dDYWRlbmNlOiBmYWxzZVxuXHR9O1xuXG5cdC8vIE1lcmdlIGRlZmF1bHRzIGFuZCBjb25maWcgcGFzc2VkIGluXG5cdGxheW91dENvbmZpZyA9IG1lcmdlKGRlZmF1bHRzLCBjb25maWcpO1xuXG5cdC8vIFNvcnQgb3V0IHBhZGRpbmcgYW5kIHNwYWNpbmcgdmFsdWVzXG5cdHZhciBjb250YWluZXJQYWRkaW5nID0ge307XG5cdHZhciBib3hTcGFjaW5nID0ge307XG5cblx0Y29udGFpbmVyUGFkZGluZy50b3AgPSAhaXNOYU4ocGFyc2VGbG9hdChsYXlvdXRDb25maWcuY29udGFpbmVyUGFkZGluZy50b3ApKSA/IGxheW91dENvbmZpZy5jb250YWluZXJQYWRkaW5nLnRvcCA6IGxheW91dENvbmZpZy5jb250YWluZXJQYWRkaW5nO1xuXHRjb250YWluZXJQYWRkaW5nLnJpZ2h0ID0gIWlzTmFOKHBhcnNlRmxvYXQobGF5b3V0Q29uZmlnLmNvbnRhaW5lclBhZGRpbmcucmlnaHQpKSA/IGxheW91dENvbmZpZy5jb250YWluZXJQYWRkaW5nLnJpZ2h0IDogbGF5b3V0Q29uZmlnLmNvbnRhaW5lclBhZGRpbmc7XG5cdGNvbnRhaW5lclBhZGRpbmcuYm90dG9tID0gIWlzTmFOKHBhcnNlRmxvYXQobGF5b3V0Q29uZmlnLmNvbnRhaW5lclBhZGRpbmcuYm90dG9tKSkgPyBsYXlvdXRDb25maWcuY29udGFpbmVyUGFkZGluZy5ib3R0b20gOiBsYXlvdXRDb25maWcuY29udGFpbmVyUGFkZGluZztcblx0Y29udGFpbmVyUGFkZGluZy5sZWZ0ID0gIWlzTmFOKHBhcnNlRmxvYXQobGF5b3V0Q29uZmlnLmNvbnRhaW5lclBhZGRpbmcubGVmdCkpID8gbGF5b3V0Q29uZmlnLmNvbnRhaW5lclBhZGRpbmcubGVmdCA6IGxheW91dENvbmZpZy5jb250YWluZXJQYWRkaW5nO1xuXHRib3hTcGFjaW5nLmhvcml6b250YWwgPSAhaXNOYU4ocGFyc2VGbG9hdChsYXlvdXRDb25maWcuYm94U3BhY2luZy5ob3Jpem9udGFsKSkgPyBsYXlvdXRDb25maWcuYm94U3BhY2luZy5ob3Jpem9udGFsIDogbGF5b3V0Q29uZmlnLmJveFNwYWNpbmc7XG5cdGJveFNwYWNpbmcudmVydGljYWwgPSAhaXNOYU4ocGFyc2VGbG9hdChsYXlvdXRDb25maWcuYm94U3BhY2luZy52ZXJ0aWNhbCkpID8gbGF5b3V0Q29uZmlnLmJveFNwYWNpbmcudmVydGljYWwgOiBsYXlvdXRDb25maWcuYm94U3BhY2luZztcblxuXHRsYXlvdXRDb25maWcuY29udGFpbmVyUGFkZGluZyA9IGNvbnRhaW5lclBhZGRpbmc7XG5cdGxheW91dENvbmZpZy5ib3hTcGFjaW5nID0gYm94U3BhY2luZztcblxuXHQvLyBMb2NhbFxuXHRsYXlvdXREYXRhLl9sYXlvdXRJdGVtcyA9IFtdO1xuXHRsYXlvdXREYXRhLl9hd2FrZUl0ZW1zID0gW107XG5cdGxheW91dERhdGEuX2luVmlld3BvcnRJdGVtcyA9IFtdO1xuXHRsYXlvdXREYXRhLl9sZWFkaW5nT3JwaGFucyA9IFtdO1xuXHRsYXlvdXREYXRhLl90cmFpbGluZ09ycGhhbnMgPSBbXTtcblx0bGF5b3V0RGF0YS5fY29udGFpbmVySGVpZ2h0ID0gbGF5b3V0Q29uZmlnLmNvbnRhaW5lclBhZGRpbmcudG9wO1xuXHRsYXlvdXREYXRhLl9yb3dzID0gW107XG5cdGxheW91dERhdGEuX29ycGhhbnMgPSBbXTtcblx0bGF5b3V0Q29uZmlnLl93aWRvd0NvdW50ID0gMDtcblxuXHQvLyBDb252ZXJ0IHdpZHRocyBhbmQgaGVpZ2h0cyB0byBhc3BlY3QgcmF0aW9zIGlmIHdlIG5lZWQgdG9cblx0cmV0dXJuIGNvbXB1dGVMYXlvdXQoaW5wdXQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0aWYgKGl0ZW0ud2lkdGggJiYgaXRlbS5oZWlnaHQpIHtcblx0XHRcdHJldHVybiB7IGFzcGVjdFJhdGlvOiBpdGVtLndpZHRoIC8gaXRlbS5oZWlnaHQgfTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHsgYXNwZWN0UmF0aW86IGl0ZW0gfTtcblx0XHR9XG5cdH0pKTtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGUgdGhlIGN1cnJlbnQgbGF5b3V0IGZvciBhbGwgaXRlbXMgaW4gdGhlIGxpc3QgdGhhdCByZXF1aXJlIGxheW91dC5cbiogXCJMYXlvdXRcIiBtZWFucyBnZW9tZXRyeTogcG9zaXRpb24gd2l0aGluIGNvbnRhaW5lciBhbmQgc2l6ZVxuKlxuKiBAbWV0aG9kIGNvbXB1dGVMYXlvdXRcbiogQHBhcmFtIGl0ZW1MYXlvdXREYXRhIHtBcnJheX0gQXJyYXkgb2YgaXRlbXMgdG8gbGF5IG91dCwgd2l0aCBkYXRhIHJlcXVpcmVkIHRvIGxheSBvdXQgZWFjaCBpdGVtXG4qIEByZXR1cm4ge09iamVjdH0gVGhlIG5ld2x5LWNhbGN1bGF0ZWQgbGF5b3V0LCBjb250YWluaW5nIHRoZSBuZXcgY29udGFpbmVyIGhlaWdodCwgYW5kIGxpc3RzIG9mIGxheW91dCBpdGVtc1xuKi9cbmZ1bmN0aW9uIGNvbXB1dGVMYXlvdXQoaXRlbUxheW91dERhdGEpIHtcblxuXHR2YXIgbGFpZE91dEl0ZW1zID0gW10sXG5cdCAgICBpdGVtQWRkZWQsXG5cdCAgICBjdXJyZW50Um93LFxuXHQgICAgbmV4dFRvTGFzdFJvd0hlaWdodDtcblxuXHQvLyBBcHBseSBmb3JjZWQgYXNwZWN0IHJhdGlvIGlmIHNwZWNpZmllZCwgYW5kIHNldCBhIGZsYWcuXG5cdGlmIChsYXlvdXRDb25maWcuZm9yY2VBc3BlY3RSYXRpbykge1xuXHRcdGl0ZW1MYXlvdXREYXRhLmZvckVhY2goZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG5cdFx0XHRpdGVtRGF0YS5mb3JjZWRBc3BlY3RSYXRpbyA9IHRydWU7XG5cdFx0XHRpdGVtRGF0YS5hc3BlY3RSYXRpbyA9IGxheW91dENvbmZpZy5mb3JjZUFzcGVjdFJhdGlvO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gTG9vcCB0aHJvdWdoIHRoZSBpdGVtc1xuXHRpdGVtTGF5b3V0RGF0YS5zb21lKGZ1bmN0aW9uIChpdGVtRGF0YSwgaSkge1xuXG5cdFx0aWYgKGlzTmFOKGl0ZW1EYXRhLmFzcGVjdFJhdGlvKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSXRlbSBcIiArIGkgKyBcIiBoYXMgYW4gaW52YWxpZCBhc3BlY3QgcmF0aW9cIik7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm90IGN1cnJlbnRseSBidWlsZGluZyB1cCBhIHJvdywgbWFrZSBhIG5ldyBvbmUuXG5cdFx0aWYgKCFjdXJyZW50Um93KSB7XG5cdFx0XHRjdXJyZW50Um93ID0gY3JlYXRlTmV3Um93KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0ZW1wdCB0byBhZGQgaXRlbSB0byB0aGUgY3VycmVudCByb3cuXG5cdFx0aXRlbUFkZGVkID0gY3VycmVudFJvdy5hZGRJdGVtKGl0ZW1EYXRhKTtcblxuXHRcdGlmIChjdXJyZW50Um93LmlzTGF5b3V0Q29tcGxldGUoKSkge1xuXG5cdFx0XHQvLyBSb3cgaXMgZmlsbGVkOyBhZGQgaXQgYW5kIHN0YXJ0IGEgbmV3IG9uZVxuXHRcdFx0bGFpZE91dEl0ZW1zID0gbGFpZE91dEl0ZW1zLmNvbmNhdChhZGRSb3coY3VycmVudFJvdykpO1xuXG5cdFx0XHRpZiAobGF5b3V0RGF0YS5fcm93cy5sZW5ndGggPj0gbGF5b3V0Q29uZmlnLm1heE51bVJvd3MpIHtcblx0XHRcdFx0Y3VycmVudFJvdyA9IG51bGw7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50Um93ID0gY3JlYXRlTmV3Um93KCk7XG5cblx0XHRcdC8vIEl0ZW0gd2FzIHJlamVjdGVkOyBhZGQgaXQgdG8gaXRzIG93biByb3dcblx0XHRcdGlmICghaXRlbUFkZGVkKSB7XG5cblx0XHRcdFx0aXRlbUFkZGVkID0gY3VycmVudFJvdy5hZGRJdGVtKGl0ZW1EYXRhKTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFJvdy5pc0xheW91dENvbXBsZXRlKCkpIHtcblxuXHRcdFx0XHRcdC8vIElmIHRoZSByZWplY3RlZCBpdGVtIGZpbGxzIGEgcm93IG9uIGl0cyBvd24sIGFkZCB0aGUgcm93IGFuZCBzdGFydCBhbm90aGVyIG5ldyBvbmVcblx0XHRcdFx0XHRsYWlkT3V0SXRlbXMgPSBsYWlkT3V0SXRlbXMuY29uY2F0KGFkZFJvdyhjdXJyZW50Um93KSk7XG5cdFx0XHRcdFx0aWYgKGxheW91dERhdGEuX3Jvd3MubGVuZ3RoID49IGxheW91dENvbmZpZy5tYXhOdW1Sb3dzKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50Um93ID0gbnVsbDtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJyZW50Um93ID0gY3JlYXRlTmV3Um93KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8vIEhhbmRsZSBhbnkgbGVmdG92ZXIgY29udGVudCAob3JwaGFucykgZGVwZW5kaW5nIG9uIHdoZXJlIHRoZXkgbGllXG5cdC8vIGluIHRoaXMgbGF5b3V0IHVwZGF0ZSwgYW5kIGluIHRoZSB0b3RhbCBjb250ZW50IHNldC5cblx0aWYgKGN1cnJlbnRSb3cgJiYgY3VycmVudFJvdy5nZXRJdGVtcygpLmxlbmd0aCAmJiBsYXlvdXRDb25maWcuc2hvd1dpZG93cykge1xuXG5cdFx0Ly8gTGFzdCBwYWdlIG9mIGFsbCBjb250ZW50IG9yIG9ycGhhbiBzdXBwcmVzc2lvbiBpcyBzdXBwcmVzc2VkOyBsYXkgb3V0IG9ycGhhbnMuXG5cdFx0aWYgKGxheW91dERhdGEuX3Jvd3MubGVuZ3RoKSB7XG5cblx0XHRcdC8vIE9ubHkgTWF0Y2ggcHJldmlvdXMgcm93J3MgaGVpZ2h0IGlmIGl0IGV4aXN0cyBhbmQgaXQgaXNuJ3QgYSBicmVha291dCByb3dcblx0XHRcdGlmIChsYXlvdXREYXRhLl9yb3dzW2xheW91dERhdGEuX3Jvd3MubGVuZ3RoIC0gMV0uaXNCcmVha291dFJvdykge1xuXHRcdFx0XHRuZXh0VG9MYXN0Um93SGVpZ2h0ID0gbGF5b3V0RGF0YS5fcm93c1tsYXlvdXREYXRhLl9yb3dzLmxlbmd0aCAtIDFdLnRhcmdldFJvd0hlaWdodDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5leHRUb0xhc3RSb3dIZWlnaHQgPSBsYXlvdXREYXRhLl9yb3dzW2xheW91dERhdGEuX3Jvd3MubGVuZ3RoIC0gMV0uaGVpZ2h0O1xuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50Um93LmZvcmNlQ29tcGxldGUoZmFsc2UsIG5leHRUb0xhc3RSb3dIZWlnaHQpO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIC4uLmVsc2UgdXNlIHRhcmdldCBoZWlnaHQgaWYgdGhlcmUgaXMgbm8gb3RoZXIgcm93IGhlaWdodCB0byByZWZlcmVuY2UuXG5cdFx0XHRjdXJyZW50Um93LmZvcmNlQ29tcGxldGUoZmFsc2UpO1xuXHRcdH1cblxuXHRcdGxhaWRPdXRJdGVtcyA9IGxhaWRPdXRJdGVtcy5jb25jYXQoYWRkUm93KGN1cnJlbnRSb3cpKTtcblx0XHRsYXlvdXRDb25maWcuX3dpZG93Q291bnQgPSBjdXJyZW50Um93LmdldEl0ZW1zKCkubGVuZ3RoO1xuXHR9XG5cblx0Ly8gV2UgbmVlZCB0byBjbGVhbiB1cCB0aGUgYm90dG9tIGNvbnRhaW5lciBwYWRkaW5nXG5cdC8vIEZpcnN0IHJlbW92ZSB0aGUgaGVpZ2h0IGFkZGVkIGZvciBib3ggc3BhY2luZ1xuXHRsYXlvdXREYXRhLl9jb250YWluZXJIZWlnaHQgPSBsYXlvdXREYXRhLl9jb250YWluZXJIZWlnaHQgLSBsYXlvdXRDb25maWcuYm94U3BhY2luZy52ZXJ0aWNhbDtcblx0Ly8gVGhlbiBhZGQgb3VyIGJvdHRvbSBjb250YWluZXIgcGFkZGluZ1xuXHRsYXlvdXREYXRhLl9jb250YWluZXJIZWlnaHQgPSBsYXlvdXREYXRhLl9jb250YWluZXJIZWlnaHQgKyBsYXlvdXRDb25maWcuY29udGFpbmVyUGFkZGluZy5ib3R0b207XG5cblx0cmV0dXJuIHtcblx0XHRjb250YWluZXJIZWlnaHQ6IGxheW91dERhdGEuX2NvbnRhaW5lckhlaWdodCxcblx0XHR3aWRvd0NvdW50OiBsYXlvdXRDb25maWcuX3dpZG93Q291bnQsXG5cdFx0Ym94ZXM6IGxheW91dERhdGEuX2xheW91dEl0ZW1zXG5cdH07XG59XG5cbi8qKlxuKiBDcmVhdGUgYSBuZXcsIGVtcHR5IHJvdy5cbipcbiogQG1ldGhvZCBjcmVhdGVOZXdSb3dcbiogQHJldHVybiBBIG5ldywgZW1wdHkgcm93IG9mIHRoZSB0eXBlIHNwZWNpZmllZCBieSB0aGlzIGxheW91dC5cbiovXG5mdW5jdGlvbiBjcmVhdGVOZXdSb3coKSB7XG5cblx0Ly8gV29yayBvdXQgaWYgdGhpcyBpcyBhIGZ1bGwgd2lkdGggYnJlYWtvdXQgcm93XG5cdGlmIChsYXlvdXRDb25maWcuZnVsbFdpZHRoQnJlYWtvdXRSb3dDYWRlbmNlICE9PSBmYWxzZSkge1xuXHRcdGlmICgobGF5b3V0RGF0YS5fcm93cy5sZW5ndGggKyAxKSAlIGxheW91dENvbmZpZy5mdWxsV2lkdGhCcmVha291dFJvd0NhZGVuY2UgPT09IDApIHtcblx0XHRcdHZhciBpc0JyZWFrb3V0Um93ID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3IFJvdyh7XG5cdFx0dG9wOiBsYXlvdXREYXRhLl9jb250YWluZXJIZWlnaHQsXG5cdFx0bGVmdDogbGF5b3V0Q29uZmlnLmNvbnRhaW5lclBhZGRpbmcubGVmdCxcblx0XHR3aWR0aDogbGF5b3V0Q29uZmlnLmNvbnRhaW5lcldpZHRoIC0gbGF5b3V0Q29uZmlnLmNvbnRhaW5lclBhZGRpbmcubGVmdCAtIGxheW91dENvbmZpZy5jb250YWluZXJQYWRkaW5nLnJpZ2h0LFxuXHRcdHNwYWNpbmc6IGxheW91dENvbmZpZy5ib3hTcGFjaW5nLmhvcml6b250YWwsXG5cdFx0dGFyZ2V0Um93SGVpZ2h0OiBsYXlvdXRDb25maWcudGFyZ2V0Um93SGVpZ2h0LFxuXHRcdHRhcmdldFJvd0hlaWdodFRvbGVyYW5jZTogbGF5b3V0Q29uZmlnLnRhcmdldFJvd0hlaWdodFRvbGVyYW5jZSxcblx0XHRlZGdlQ2FzZU1pblJvd0hlaWdodDogMC41ICogbGF5b3V0Q29uZmlnLnRhcmdldFJvd0hlaWdodCxcblx0XHRlZGdlQ2FzZU1heFJvd0hlaWdodDogMiAqIGxheW91dENvbmZpZy50YXJnZXRSb3dIZWlnaHQsXG5cdFx0cmlnaHRUb0xlZnQ6IGZhbHNlLFxuXHRcdGlzQnJlYWtvdXRSb3c6IGlzQnJlYWtvdXRSb3dcblx0fSk7XG59XG5cbi8qKlxuICogQWRkIGEgY29tcGxldGVkIHJvdyB0byB0aGUgbGF5b3V0LlxuICogTm90ZTogdGhlIHJvdyBtdXN0IGhhdmUgYWxyZWFkeSBiZWVuIGNvbXBsZXRlZC5cbiAqXG4gKiBAbWV0aG9kIGFkZFJvd1xuICogQHBhcmFtIHJvdyB7Um93fSBUaGUgcm93IHRvIGFkZC5cbiAqIEByZXR1cm4ge0FycmF5fSBFYWNoIGl0ZW0gYWRkZWQgdG8gdGhlIHJvdy5cbiAqL1xuZnVuY3Rpb24gYWRkUm93KHJvdykge1xuXG5cdGxheW91dERhdGEuX3Jvd3MucHVzaChyb3cpO1xuXHRsYXlvdXREYXRhLl9sYXlvdXRJdGVtcyA9IGxheW91dERhdGEuX2xheW91dEl0ZW1zLmNvbmNhdChyb3cuZ2V0SXRlbXMoKSk7XG5cblx0Ly8gSW5jcmVtZW50IHRoZSBjb250YWluZXIgaGVpZ2h0XG5cdGxheW91dERhdGEuX2NvbnRhaW5lckhlaWdodCArPSByb3cuaGVpZ2h0ICsgbGF5b3V0Q29uZmlnLmJveFNwYWNpbmcudmVydGljYWw7XG5cblx0cmV0dXJuIHJvdy5pdGVtcztcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanVzdGlmaWVkLWxheW91dC9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Copyright 2016 Yahoo Inc.\n// Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.\n\nvar merge = __webpack_require__(3);\n\n/**\n* Row\n* Wrapper for each row in a justified layout.\n* Stores relevant values and provides methods for calculating layout of individual rows.\n*\n* @param {Object} layoutConfig - The same as that passed\n* @param {Object} Initialization paramters. The following are all required:\n* @param params.top {Number} Top of row, relative to container\n* @param params.left {Number} Left side of row relative to container (equal to container left padding)\n* @param params.width {Number} Width of row, not including container padding\n* @param params.spacing {Number} Horizontal spacing between items\n* @param params.targetRowHeight {Number} Layout algorithm will aim for this row height\n* @param params.targetRowHeightTolerance {Number} Row heights may vary +/- (`targetRowHeight` x `targetRowHeightTolerance`)\n* @param params.edgeCaseMinRowHeight {Number} Absolute minimum row height for edge cases that cannot be resolved within tolerance.\n* @param params.edgeCaseMaxRowHeight {Number} Absolute maximum row height for edge cases that cannot be resolved within tolerance.\n* @param params.isBreakoutRow {Boolean} Is this row in particular one of those breakout rows? Always false if it's not that kind of photo list\n* @constructor\n*/\nvar Row = module.exports = function (params) {\n\n\t// Top of row, relative to container\n\tthis.top = params.top;\n\n\t// Left side of row relative to container (equal to container left padding)\n\tthis.left = params.left;\n\n\t// Width of row, not including container padding\n\tthis.width = params.width;\n\n\t// Horizontal spacing between items\n\tthis.spacing = params.spacing;\n\n\t// Row height calculation values\n\tthis.targetRowHeight = params.targetRowHeight;\n\tthis.targetRowHeightTolerance = params.targetRowHeightTolerance;\n\tthis.minAspectRatio = this.width / params.targetRowHeight * (1 - params.targetRowHeightTolerance);\n\tthis.maxAspectRatio = this.width / params.targetRowHeight * (1 + params.targetRowHeightTolerance);\n\n\t// Edge case row height minimum/maximum\n\tthis.edgeCaseMinRowHeight = params.edgeCaseMinRowHeight;\n\tthis.edgeCaseMaxRowHeight = params.edgeCaseMaxRowHeight;\n\n\t// Layout direction\n\tthis.rightToLeft = params.rightToLeft;\n\n\t// Full width breakout rows\n\tthis.isBreakoutRow = params.isBreakoutRow;\n\n\t// Store layout data for each item in row\n\tthis.items = [];\n\n\t// Height remains at 0 until it's been calculated\n\tthis.height = 0;\n};\n\nRow.prototype = {\n\n\t/**\n * Attempt to add a single item to the row.\n * This is the heart of the justified algorithm.\n * This method is direction-agnostic; it deals only with sizes, not positions.\n *\n * If the item fits in the row, without pushing row height beyond min/max tolerance,\n * the item is added and the method returns true.\n *\n * If the item leaves row height too high, there may be room to scale it down and add another item.\n * In this case, the item is added and the method returns true, but the row is incomplete.\n *\n * If the item leaves row height too short, there are too many items to fit within tolerance.\n * The method will either accept or reject the new item, favoring the resulting row height closest to within tolerance.\n * If the item is rejected, left/right padding will be required to fit the row height within tolerance;\n * if the item is accepted, top/bottom cropping will be required to fit the row height within tolerance.\n *\n * @method addItem\n * @param itemData {Object} Item layout data, containing item aspect ratio.\n * @return {Boolean} True if successfully added; false if rejected.\n */\n\taddItem: function addItem(itemData) {\n\n\t\tvar newItems = this.items.concat(itemData),\n\n\t\t// Calculate aspect ratios for items only; exclude spacing\n\t\trowWidthWithoutSpacing = this.width - (newItems.length - 1) * this.spacing,\n\t\t    newAspectRatio = newItems.reduce(function (sum, item) {\n\t\t\treturn sum + item.aspectRatio;\n\t\t}, 0),\n\t\t    targetAspectRatio = rowWidthWithoutSpacing / this.targetRowHeight,\n\t\t    previousRowWidthWithoutSpacing,\n\t\t    previousAspectRatio,\n\t\t    previousTargetAspectRatio;\n\n\t\t// Handle big full-width breakout photos if we're doing them\n\t\tif (this.isBreakoutRow) {\n\t\t\t// Only do it if there's no other items in this row\n\t\t\tif (this.items.length === 0) {\n\t\t\t\t// Only go full width if this photo is a square or landscape\n\t\t\t\tif (itemData.aspectRatio >= 1) {\n\t\t\t\t\t// Close out the row with a full width photo\n\t\t\t\t\tthis.items.push(itemData);\n\t\t\t\t\tthis.completeLayout(rowWidthWithoutSpacing / itemData.aspectRatio);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newAspectRatio < this.minAspectRatio) {\n\n\t\t\t// New aspect ratio is too narrow / scaled row height is too tall.\n\t\t\t// Accept this item and leave row open for more items.\n\n\t\t\tthis.items.push(merge(itemData));\n\t\t\treturn true;\n\t\t} else if (newAspectRatio > this.maxAspectRatio) {\n\n\t\t\t// New aspect ratio is too wide / scaled row height will be too short.\n\t\t\t// Accept item if the resulting aspect ratio is closer to target than it would be without the item.\n\t\t\t// NOTE: Any row that falls into this block will require cropping/padding on individual items.\n\n\t\t\tif (this.items.length === 0) {\n\n\t\t\t\t// When there are no existing items, force acceptance of the new item and complete the layout.\n\t\t\t\t// This is the pano special case.\n\t\t\t\tthis.items.push(merge(itemData));\n\t\t\t\tthis.completeLayout(rowWidthWithoutSpacing / newAspectRatio);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Calculate width/aspect ratio for row before adding new item\n\t\t\tpreviousRowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing;\n\t\t\tpreviousAspectRatio = this.items.reduce(function (sum, item) {\n\t\t\t\treturn sum + item.aspectRatio;\n\t\t\t}, 0);\n\t\t\tpreviousTargetAspectRatio = previousRowWidthWithoutSpacing / this.targetRowHeight;\n\n\t\t\tif (Math.abs(newAspectRatio - targetAspectRatio) > Math.abs(previousAspectRatio - previousTargetAspectRatio)) {\n\n\t\t\t\t// Row with new item is us farther away from target than row without; complete layout and reject item.\n\t\t\t\tthis.completeLayout(previousRowWidthWithoutSpacing / previousAspectRatio);\n\t\t\t\treturn false;\n\t\t\t} else {\n\n\t\t\t\t// Row with new item is us closer to target than row without;\n\t\t\t\t// accept the new item and complete the row layout.\n\t\t\t\tthis.items.push(merge(itemData));\n\t\t\t\tthis.completeLayout(rowWidthWithoutSpacing / newAspectRatio);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// New aspect ratio / scaled row height is within tolerance;\n\t\t\t// accept the new item and complete the row layout.\n\t\t\tthis.items.push(merge(itemData));\n\t\t\tthis.completeLayout(rowWidthWithoutSpacing / newAspectRatio);\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t/**\n * Check if a row has completed its layout.\n *\n * @method isLayoutComplete\n * @return {Boolean} True if complete; false if not.\n */\n\tisLayoutComplete: function isLayoutComplete() {\n\t\treturn this.height > 0;\n\t},\n\n\t/**\n * Set row height and compute item geometry from that height.\n * Will justify items within the row unless instructed not to.\n *\n * @method completeLayout\n * @param newHeight {Number} Set row height to this value.\n * @param justify Apply error correction to ensure photos exactly fill the row. Defaults to `true`.\n */\n\tcompleteLayout: function completeLayout(newHeight, justify) {\n\n\t\tvar itemWidthSum = this.left,\n\t\t    rowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing,\n\t\t    clampedToNativeRatio,\n\t\t    roundedHeight,\n\t\t    clampedHeight,\n\t\t    errorWidthPerItem,\n\t\t    roundedCumulativeErrors,\n\t\t    singleItemGeometry,\n\t\t    self = this;\n\n\t\t// Justify unless explicitly specified otherwise.\n\t\tif (typeof justify === 'undefined') {\n\t\t\tjustify = true;\n\t\t}\n\n\t\t// Don't set fractional values in the layout.\n\t\troundedHeight = Math.round(newHeight);\n\n\t\t// Clamp row height to edge case minimum/maximum.\n\t\tclampedHeight = Math.max(this.edgeCaseMinRowHeight, Math.min(roundedHeight, this.edgeCaseMaxRowHeight));\n\n\t\tif (roundedHeight !== clampedHeight) {\n\n\t\t\t// If row height was clamped, the resulting row/item aspect ratio will be off,\n\t\t\t// so force it to fit the width (recalculate aspectRatio to match clamped height).\n\t\t\t// NOTE: this will result in cropping/padding commensurate to the amount of clamping.\n\t\t\tthis.height = clampedHeight;\n\t\t\tclampedToNativeRatio = rowWidthWithoutSpacing / clampedHeight / (rowWidthWithoutSpacing / roundedHeight);\n\t\t} else {\n\n\t\t\t// If not clamped, leave ratio at 1.0.\n\t\t\tthis.height = roundedHeight;\n\t\t\tclampedToNativeRatio = 1.0;\n\t\t}\n\n\t\t// Compute item geometry based on newHeight.\n\t\tthis.items.forEach(function (item, i) {\n\n\t\t\titem.top = self.top;\n\t\t\titem.width = Math.round(item.aspectRatio * self.height * clampedToNativeRatio);\n\t\t\titem.height = self.height;\n\n\t\t\t// Left-to-right.\n\t\t\t// TODO right to left\n\t\t\t// item.left = self.width - itemWidthSum - item.width;\n\t\t\titem.left = itemWidthSum;\n\n\t\t\t// Incrememnt width.\n\t\t\titemWidthSum += item.width + self.spacing;\n\t\t});\n\n\t\t// If specified, ensure items fill row and distribute error\n\t\t// caused by rounding width and height across all items.\n\t\tif (justify) {\n\n\t\t\t// TODO Right to left\n\t\t\t// Left-to-right increments itemWidthSum differently;\n\t\t\t// account for that before distributing error.\n\t\t\t// if (!this.rightToLeft) {\n\t\t\titemWidthSum -= this.spacing + this.left;\n\n\t\t\terrorWidthPerItem = (itemWidthSum - this.width) / this.items.length;\n\t\t\troundedCumulativeErrors = this.items.map(function (item, i) {\n\t\t\t\treturn Math.round((i + 1) * errorWidthPerItem);\n\t\t\t});\n\n\t\t\tif (this.items.length === 1) {\n\n\t\t\t\t// For rows with only one item, adjust item width to fill row.\n\t\t\t\tsingleItemGeometry = this.items[0];\n\t\t\t\tsingleItemGeometry.width -= Math.round(errorWidthPerItem);\n\n\t\t\t\t// In right-to-left layouts, shift item to account for width change.\n\t\t\t\t// TODO Right to left\n\t\t\t\t// if (this.rightToLeft) {\n\t\t\t\t// \tsingleItemGeometry.left += Math.round(errorWidthPerItem);\n\t\t\t\t// }\n\t\t\t} else {\n\n\t\t\t\t\t// For rows with multiple items, adjust item width and shift items to fill the row,\n\t\t\t\t\t// while maintaining equal spacing between items in the row.\n\t\t\t\t\tthis.items.forEach(function (item, i) {\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\titem.left -= roundedCumulativeErrors[i - 1];\n\t\t\t\t\t\t\titem.width -= roundedCumulativeErrors[i] - roundedCumulativeErrors[i - 1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titem.width -= roundedCumulativeErrors[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t}\n\t},\n\n\t/**\n * Force completion of row layout with current items.\n *\n * @method forceComplete\n * @param fitToWidth {Boolean} Stretch current items to fill the row width.\n *                             This will likely result in padding.\n * @param fitToWidth {Number}\n */\n\tforceComplete: function forceComplete(fitToWidth, rowHeight) {\n\n\t\tvar rowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing,\n\t\t    currentAspectRatio = this.items.reduce(function (sum, item) {\n\t\t\treturn sum + item.aspectRatio;\n\t\t}, 0);\n\n\t\t// TODO Handle fitting to width\n\n\t\tif (typeof rowHeight === 'number') {\n\n\t\t\tthis.completeLayout(rowHeight, false);\n\t\t} else {\n\n\t\t\t// Complete using target row height.\n\t\t\tthis.completeLayout(this.targetRowHeight, false);\n\t\t}\n\t},\n\n\t/**\n * Return layout data for items within row.\n * Note: returns actual list, not a copy.\n *\n * @method getItems\n * @return Layout data for items within row.\n */\n\tgetItems: function getItems() {\n\t\treturn this.items;\n\t}\n\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvbm9kZV9tb2R1bGVzL2p1c3RpZmllZC1sYXlvdXQvbGliL3Jvdy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIENvcHlyaWdodCAyMDE2IFlhaG9vIEluYy5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIGxpY2Vuc2UuIFBsZWFzZSBzZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIHRlcm1zLlxuXG52YXIgbWVyZ2UgPSByZXF1aXJlKCdtZXJnZScpO1xuXG4vKipcbiogUm93XG4qIFdyYXBwZXIgZm9yIGVhY2ggcm93IGluIGEganVzdGlmaWVkIGxheW91dC5cbiogU3RvcmVzIHJlbGV2YW50IHZhbHVlcyBhbmQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgY2FsY3VsYXRpbmcgbGF5b3V0IG9mIGluZGl2aWR1YWwgcm93cy5cbipcbiogQHBhcmFtIHtPYmplY3R9IGxheW91dENvbmZpZyAtIFRoZSBzYW1lIGFzIHRoYXQgcGFzc2VkXG4qIEBwYXJhbSB7T2JqZWN0fSBJbml0aWFsaXphdGlvbiBwYXJhbXRlcnMuIFRoZSBmb2xsb3dpbmcgYXJlIGFsbCByZXF1aXJlZDpcbiogQHBhcmFtIHBhcmFtcy50b3Age051bWJlcn0gVG9wIG9mIHJvdywgcmVsYXRpdmUgdG8gY29udGFpbmVyXG4qIEBwYXJhbSBwYXJhbXMubGVmdCB7TnVtYmVyfSBMZWZ0IHNpZGUgb2Ygcm93IHJlbGF0aXZlIHRvIGNvbnRhaW5lciAoZXF1YWwgdG8gY29udGFpbmVyIGxlZnQgcGFkZGluZylcbiogQHBhcmFtIHBhcmFtcy53aWR0aCB7TnVtYmVyfSBXaWR0aCBvZiByb3csIG5vdCBpbmNsdWRpbmcgY29udGFpbmVyIHBhZGRpbmdcbiogQHBhcmFtIHBhcmFtcy5zcGFjaW5nIHtOdW1iZXJ9IEhvcml6b250YWwgc3BhY2luZyBiZXR3ZWVuIGl0ZW1zXG4qIEBwYXJhbSBwYXJhbXMudGFyZ2V0Um93SGVpZ2h0IHtOdW1iZXJ9IExheW91dCBhbGdvcml0aG0gd2lsbCBhaW0gZm9yIHRoaXMgcm93IGhlaWdodFxuKiBAcGFyYW0gcGFyYW1zLnRhcmdldFJvd0hlaWdodFRvbGVyYW5jZSB7TnVtYmVyfSBSb3cgaGVpZ2h0cyBtYXkgdmFyeSArLy0gKGB0YXJnZXRSb3dIZWlnaHRgIHggYHRhcmdldFJvd0hlaWdodFRvbGVyYW5jZWApXG4qIEBwYXJhbSBwYXJhbXMuZWRnZUNhc2VNaW5Sb3dIZWlnaHQge051bWJlcn0gQWJzb2x1dGUgbWluaW11bSByb3cgaGVpZ2h0IGZvciBlZGdlIGNhc2VzIHRoYXQgY2Fubm90IGJlIHJlc29sdmVkIHdpdGhpbiB0b2xlcmFuY2UuXG4qIEBwYXJhbSBwYXJhbXMuZWRnZUNhc2VNYXhSb3dIZWlnaHQge051bWJlcn0gQWJzb2x1dGUgbWF4aW11bSByb3cgaGVpZ2h0IGZvciBlZGdlIGNhc2VzIHRoYXQgY2Fubm90IGJlIHJlc29sdmVkIHdpdGhpbiB0b2xlcmFuY2UuXG4qIEBwYXJhbSBwYXJhbXMuaXNCcmVha291dFJvdyB7Qm9vbGVhbn0gSXMgdGhpcyByb3cgaW4gcGFydGljdWxhciBvbmUgb2YgdGhvc2UgYnJlYWtvdXQgcm93cz8gQWx3YXlzIGZhbHNlIGlmIGl0J3Mgbm90IHRoYXQga2luZCBvZiBwaG90byBsaXN0XG4qIEBjb25zdHJ1Y3RvclxuKi9cbnZhciBSb3cgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcblxuXHQvLyBUb3Agb2Ygcm93LCByZWxhdGl2ZSB0byBjb250YWluZXJcblx0dGhpcy50b3AgPSBwYXJhbXMudG9wO1xuXG5cdC8vIExlZnQgc2lkZSBvZiByb3cgcmVsYXRpdmUgdG8gY29udGFpbmVyIChlcXVhbCB0byBjb250YWluZXIgbGVmdCBwYWRkaW5nKVxuXHR0aGlzLmxlZnQgPSBwYXJhbXMubGVmdDtcblxuXHQvLyBXaWR0aCBvZiByb3csIG5vdCBpbmNsdWRpbmcgY29udGFpbmVyIHBhZGRpbmdcblx0dGhpcy53aWR0aCA9IHBhcmFtcy53aWR0aDtcblxuXHQvLyBIb3Jpem9udGFsIHNwYWNpbmcgYmV0d2VlbiBpdGVtc1xuXHR0aGlzLnNwYWNpbmcgPSBwYXJhbXMuc3BhY2luZztcblxuXHQvLyBSb3cgaGVpZ2h0IGNhbGN1bGF0aW9uIHZhbHVlc1xuXHR0aGlzLnRhcmdldFJvd0hlaWdodCA9IHBhcmFtcy50YXJnZXRSb3dIZWlnaHQ7XG5cdHRoaXMudGFyZ2V0Um93SGVpZ2h0VG9sZXJhbmNlID0gcGFyYW1zLnRhcmdldFJvd0hlaWdodFRvbGVyYW5jZTtcblx0dGhpcy5taW5Bc3BlY3RSYXRpbyA9IHRoaXMud2lkdGggLyBwYXJhbXMudGFyZ2V0Um93SGVpZ2h0ICogKDEgLSBwYXJhbXMudGFyZ2V0Um93SGVpZ2h0VG9sZXJhbmNlKTtcblx0dGhpcy5tYXhBc3BlY3RSYXRpbyA9IHRoaXMud2lkdGggLyBwYXJhbXMudGFyZ2V0Um93SGVpZ2h0ICogKDEgKyBwYXJhbXMudGFyZ2V0Um93SGVpZ2h0VG9sZXJhbmNlKTtcblxuXHQvLyBFZGdlIGNhc2Ugcm93IGhlaWdodCBtaW5pbXVtL21heGltdW1cblx0dGhpcy5lZGdlQ2FzZU1pblJvd0hlaWdodCA9IHBhcmFtcy5lZGdlQ2FzZU1pblJvd0hlaWdodDtcblx0dGhpcy5lZGdlQ2FzZU1heFJvd0hlaWdodCA9IHBhcmFtcy5lZGdlQ2FzZU1heFJvd0hlaWdodDtcblxuXHQvLyBMYXlvdXQgZGlyZWN0aW9uXG5cdHRoaXMucmlnaHRUb0xlZnQgPSBwYXJhbXMucmlnaHRUb0xlZnQ7XG5cblx0Ly8gRnVsbCB3aWR0aCBicmVha291dCByb3dzXG5cdHRoaXMuaXNCcmVha291dFJvdyA9IHBhcmFtcy5pc0JyZWFrb3V0Um93O1xuXG5cdC8vIFN0b3JlIGxheW91dCBkYXRhIGZvciBlYWNoIGl0ZW0gaW4gcm93XG5cdHRoaXMuaXRlbXMgPSBbXTtcblxuXHQvLyBIZWlnaHQgcmVtYWlucyBhdCAwIHVudGlsIGl0J3MgYmVlbiBjYWxjdWxhdGVkXG5cdHRoaXMuaGVpZ2h0ID0gMDtcbn07XG5cblJvdy5wcm90b3R5cGUgPSB7XG5cblx0LyoqXG4gKiBBdHRlbXB0IHRvIGFkZCBhIHNpbmdsZSBpdGVtIHRvIHRoZSByb3cuXG4gKiBUaGlzIGlzIHRoZSBoZWFydCBvZiB0aGUganVzdGlmaWVkIGFsZ29yaXRobS5cbiAqIFRoaXMgbWV0aG9kIGlzIGRpcmVjdGlvbi1hZ25vc3RpYzsgaXQgZGVhbHMgb25seSB3aXRoIHNpemVzLCBub3QgcG9zaXRpb25zLlxuICpcbiAqIElmIHRoZSBpdGVtIGZpdHMgaW4gdGhlIHJvdywgd2l0aG91dCBwdXNoaW5nIHJvdyBoZWlnaHQgYmV5b25kIG1pbi9tYXggdG9sZXJhbmNlLFxuICogdGhlIGl0ZW0gaXMgYWRkZWQgYW5kIHRoZSBtZXRob2QgcmV0dXJucyB0cnVlLlxuICpcbiAqIElmIHRoZSBpdGVtIGxlYXZlcyByb3cgaGVpZ2h0IHRvbyBoaWdoLCB0aGVyZSBtYXkgYmUgcm9vbSB0byBzY2FsZSBpdCBkb3duIGFuZCBhZGQgYW5vdGhlciBpdGVtLlxuICogSW4gdGhpcyBjYXNlLCB0aGUgaXRlbSBpcyBhZGRlZCBhbmQgdGhlIG1ldGhvZCByZXR1cm5zIHRydWUsIGJ1dCB0aGUgcm93IGlzIGluY29tcGxldGUuXG4gKlxuICogSWYgdGhlIGl0ZW0gbGVhdmVzIHJvdyBoZWlnaHQgdG9vIHNob3J0LCB0aGVyZSBhcmUgdG9vIG1hbnkgaXRlbXMgdG8gZml0IHdpdGhpbiB0b2xlcmFuY2UuXG4gKiBUaGUgbWV0aG9kIHdpbGwgZWl0aGVyIGFjY2VwdCBvciByZWplY3QgdGhlIG5ldyBpdGVtLCBmYXZvcmluZyB0aGUgcmVzdWx0aW5nIHJvdyBoZWlnaHQgY2xvc2VzdCB0byB3aXRoaW4gdG9sZXJhbmNlLlxuICogSWYgdGhlIGl0ZW0gaXMgcmVqZWN0ZWQsIGxlZnQvcmlnaHQgcGFkZGluZyB3aWxsIGJlIHJlcXVpcmVkIHRvIGZpdCB0aGUgcm93IGhlaWdodCB3aXRoaW4gdG9sZXJhbmNlO1xuICogaWYgdGhlIGl0ZW0gaXMgYWNjZXB0ZWQsIHRvcC9ib3R0b20gY3JvcHBpbmcgd2lsbCBiZSByZXF1aXJlZCB0byBmaXQgdGhlIHJvdyBoZWlnaHQgd2l0aGluIHRvbGVyYW5jZS5cbiAqXG4gKiBAbWV0aG9kIGFkZEl0ZW1cbiAqIEBwYXJhbSBpdGVtRGF0YSB7T2JqZWN0fSBJdGVtIGxheW91dCBkYXRhLCBjb250YWluaW5nIGl0ZW0gYXNwZWN0IHJhdGlvLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBzdWNjZXNzZnVsbHkgYWRkZWQ7IGZhbHNlIGlmIHJlamVjdGVkLlxuICovXG5cdGFkZEl0ZW06IGZ1bmN0aW9uIGFkZEl0ZW0oaXRlbURhdGEpIHtcblxuXHRcdHZhciBuZXdJdGVtcyA9IHRoaXMuaXRlbXMuY29uY2F0KGl0ZW1EYXRhKSxcblxuXHRcdC8vIENhbGN1bGF0ZSBhc3BlY3QgcmF0aW9zIGZvciBpdGVtcyBvbmx5OyBleGNsdWRlIHNwYWNpbmdcblx0XHRyb3dXaWR0aFdpdGhvdXRTcGFjaW5nID0gdGhpcy53aWR0aCAtIChuZXdJdGVtcy5sZW5ndGggLSAxKSAqIHRoaXMuc3BhY2luZyxcblx0XHQgICAgbmV3QXNwZWN0UmF0aW8gPSBuZXdJdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgaXRlbSkge1xuXHRcdFx0cmV0dXJuIHN1bSArIGl0ZW0uYXNwZWN0UmF0aW87XG5cdFx0fSwgMCksXG5cdFx0ICAgIHRhcmdldEFzcGVjdFJhdGlvID0gcm93V2lkdGhXaXRob3V0U3BhY2luZyAvIHRoaXMudGFyZ2V0Um93SGVpZ2h0LFxuXHRcdCAgICBwcmV2aW91c1Jvd1dpZHRoV2l0aG91dFNwYWNpbmcsXG5cdFx0ICAgIHByZXZpb3VzQXNwZWN0UmF0aW8sXG5cdFx0ICAgIHByZXZpb3VzVGFyZ2V0QXNwZWN0UmF0aW87XG5cblx0XHQvLyBIYW5kbGUgYmlnIGZ1bGwtd2lkdGggYnJlYWtvdXQgcGhvdG9zIGlmIHdlJ3JlIGRvaW5nIHRoZW1cblx0XHRpZiAodGhpcy5pc0JyZWFrb3V0Um93KSB7XG5cdFx0XHQvLyBPbmx5IGRvIGl0IGlmIHRoZXJlJ3Mgbm8gb3RoZXIgaXRlbXMgaW4gdGhpcyByb3dcblx0XHRcdGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHQvLyBPbmx5IGdvIGZ1bGwgd2lkdGggaWYgdGhpcyBwaG90byBpcyBhIHNxdWFyZSBvciBsYW5kc2NhcGVcblx0XHRcdFx0aWYgKGl0ZW1EYXRhLmFzcGVjdFJhdGlvID49IDEpIHtcblx0XHRcdFx0XHQvLyBDbG9zZSBvdXQgdGhlIHJvdyB3aXRoIGEgZnVsbCB3aWR0aCBwaG90b1xuXHRcdFx0XHRcdHRoaXMuaXRlbXMucHVzaChpdGVtRGF0YSk7XG5cdFx0XHRcdFx0dGhpcy5jb21wbGV0ZUxheW91dChyb3dXaWR0aFdpdGhvdXRTcGFjaW5nIC8gaXRlbURhdGEuYXNwZWN0UmF0aW8pO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5ld0FzcGVjdFJhdGlvIDwgdGhpcy5taW5Bc3BlY3RSYXRpbykge1xuXG5cdFx0XHQvLyBOZXcgYXNwZWN0IHJhdGlvIGlzIHRvbyBuYXJyb3cgLyBzY2FsZWQgcm93IGhlaWdodCBpcyB0b28gdGFsbC5cblx0XHRcdC8vIEFjY2VwdCB0aGlzIGl0ZW0gYW5kIGxlYXZlIHJvdyBvcGVuIGZvciBtb3JlIGl0ZW1zLlxuXG5cdFx0XHR0aGlzLml0ZW1zLnB1c2gobWVyZ2UoaXRlbURhdGEpKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAobmV3QXNwZWN0UmF0aW8gPiB0aGlzLm1heEFzcGVjdFJhdGlvKSB7XG5cblx0XHRcdC8vIE5ldyBhc3BlY3QgcmF0aW8gaXMgdG9vIHdpZGUgLyBzY2FsZWQgcm93IGhlaWdodCB3aWxsIGJlIHRvbyBzaG9ydC5cblx0XHRcdC8vIEFjY2VwdCBpdGVtIGlmIHRoZSByZXN1bHRpbmcgYXNwZWN0IHJhdGlvIGlzIGNsb3NlciB0byB0YXJnZXQgdGhhbiBpdCB3b3VsZCBiZSB3aXRob3V0IHRoZSBpdGVtLlxuXHRcdFx0Ly8gTk9URTogQW55IHJvdyB0aGF0IGZhbGxzIGludG8gdGhpcyBibG9jayB3aWxsIHJlcXVpcmUgY3JvcHBpbmcvcGFkZGluZyBvbiBpbmRpdmlkdWFsIGl0ZW1zLlxuXG5cdFx0XHRpZiAodGhpcy5pdGVtcy5sZW5ndGggPT09IDApIHtcblxuXHRcdFx0XHQvLyBXaGVuIHRoZXJlIGFyZSBubyBleGlzdGluZyBpdGVtcywgZm9yY2UgYWNjZXB0YW5jZSBvZiB0aGUgbmV3IGl0ZW0gYW5kIGNvbXBsZXRlIHRoZSBsYXlvdXQuXG5cdFx0XHRcdC8vIFRoaXMgaXMgdGhlIHBhbm8gc3BlY2lhbCBjYXNlLlxuXHRcdFx0XHR0aGlzLml0ZW1zLnB1c2gobWVyZ2UoaXRlbURhdGEpKTtcblx0XHRcdFx0dGhpcy5jb21wbGV0ZUxheW91dChyb3dXaWR0aFdpdGhvdXRTcGFjaW5nIC8gbmV3QXNwZWN0UmF0aW8pO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHdpZHRoL2FzcGVjdCByYXRpbyBmb3Igcm93IGJlZm9yZSBhZGRpbmcgbmV3IGl0ZW1cblx0XHRcdHByZXZpb3VzUm93V2lkdGhXaXRob3V0U3BhY2luZyA9IHRoaXMud2lkdGggLSAodGhpcy5pdGVtcy5sZW5ndGggLSAxKSAqIHRoaXMuc3BhY2luZztcblx0XHRcdHByZXZpb3VzQXNwZWN0UmF0aW8gPSB0aGlzLml0ZW1zLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBpdGVtKSB7XG5cdFx0XHRcdHJldHVybiBzdW0gKyBpdGVtLmFzcGVjdFJhdGlvO1xuXHRcdFx0fSwgMCk7XG5cdFx0XHRwcmV2aW91c1RhcmdldEFzcGVjdFJhdGlvID0gcHJldmlvdXNSb3dXaWR0aFdpdGhvdXRTcGFjaW5nIC8gdGhpcy50YXJnZXRSb3dIZWlnaHQ7XG5cblx0XHRcdGlmIChNYXRoLmFicyhuZXdBc3BlY3RSYXRpbyAtIHRhcmdldEFzcGVjdFJhdGlvKSA+IE1hdGguYWJzKHByZXZpb3VzQXNwZWN0UmF0aW8gLSBwcmV2aW91c1RhcmdldEFzcGVjdFJhdGlvKSkge1xuXG5cdFx0XHRcdC8vIFJvdyB3aXRoIG5ldyBpdGVtIGlzIHVzIGZhcnRoZXIgYXdheSBmcm9tIHRhcmdldCB0aGFuIHJvdyB3aXRob3V0OyBjb21wbGV0ZSBsYXlvdXQgYW5kIHJlamVjdCBpdGVtLlxuXHRcdFx0XHR0aGlzLmNvbXBsZXRlTGF5b3V0KHByZXZpb3VzUm93V2lkdGhXaXRob3V0U3BhY2luZyAvIHByZXZpb3VzQXNwZWN0UmF0aW8pO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFJvdyB3aXRoIG5ldyBpdGVtIGlzIHVzIGNsb3NlciB0byB0YXJnZXQgdGhhbiByb3cgd2l0aG91dDtcblx0XHRcdFx0Ly8gYWNjZXB0IHRoZSBuZXcgaXRlbSBhbmQgY29tcGxldGUgdGhlIHJvdyBsYXlvdXQuXG5cdFx0XHRcdHRoaXMuaXRlbXMucHVzaChtZXJnZShpdGVtRGF0YSkpO1xuXHRcdFx0XHR0aGlzLmNvbXBsZXRlTGF5b3V0KHJvd1dpZHRoV2l0aG91dFNwYWNpbmcgLyBuZXdBc3BlY3RSYXRpbyk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIE5ldyBhc3BlY3QgcmF0aW8gLyBzY2FsZWQgcm93IGhlaWdodCBpcyB3aXRoaW4gdG9sZXJhbmNlO1xuXHRcdFx0Ly8gYWNjZXB0IHRoZSBuZXcgaXRlbSBhbmQgY29tcGxldGUgdGhlIHJvdyBsYXlvdXQuXG5cdFx0XHR0aGlzLml0ZW1zLnB1c2gobWVyZ2UoaXRlbURhdGEpKTtcblx0XHRcdHRoaXMuY29tcGxldGVMYXlvdXQocm93V2lkdGhXaXRob3V0U3BhY2luZyAvIG5ld0FzcGVjdFJhdGlvKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHQvKipcbiAqIENoZWNrIGlmIGEgcm93IGhhcyBjb21wbGV0ZWQgaXRzIGxheW91dC5cbiAqXG4gKiBAbWV0aG9kIGlzTGF5b3V0Q29tcGxldGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgY29tcGxldGU7IGZhbHNlIGlmIG5vdC5cbiAqL1xuXHRpc0xheW91dENvbXBsZXRlOiBmdW5jdGlvbiBpc0xheW91dENvbXBsZXRlKCkge1xuXHRcdHJldHVybiB0aGlzLmhlaWdodCA+IDA7XG5cdH0sXG5cblx0LyoqXG4gKiBTZXQgcm93IGhlaWdodCBhbmQgY29tcHV0ZSBpdGVtIGdlb21ldHJ5IGZyb20gdGhhdCBoZWlnaHQuXG4gKiBXaWxsIGp1c3RpZnkgaXRlbXMgd2l0aGluIHRoZSByb3cgdW5sZXNzIGluc3RydWN0ZWQgbm90IHRvLlxuICpcbiAqIEBtZXRob2QgY29tcGxldGVMYXlvdXRcbiAqIEBwYXJhbSBuZXdIZWlnaHQge051bWJlcn0gU2V0IHJvdyBoZWlnaHQgdG8gdGhpcyB2YWx1ZS5cbiAqIEBwYXJhbSBqdXN0aWZ5IEFwcGx5IGVycm9yIGNvcnJlY3Rpb24gdG8gZW5zdXJlIHBob3RvcyBleGFjdGx5IGZpbGwgdGhlIHJvdy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICovXG5cdGNvbXBsZXRlTGF5b3V0OiBmdW5jdGlvbiBjb21wbGV0ZUxheW91dChuZXdIZWlnaHQsIGp1c3RpZnkpIHtcblxuXHRcdHZhciBpdGVtV2lkdGhTdW0gPSB0aGlzLmxlZnQsXG5cdFx0ICAgIHJvd1dpZHRoV2l0aG91dFNwYWNpbmcgPSB0aGlzLndpZHRoIC0gKHRoaXMuaXRlbXMubGVuZ3RoIC0gMSkgKiB0aGlzLnNwYWNpbmcsXG5cdFx0ICAgIGNsYW1wZWRUb05hdGl2ZVJhdGlvLFxuXHRcdCAgICByb3VuZGVkSGVpZ2h0LFxuXHRcdCAgICBjbGFtcGVkSGVpZ2h0LFxuXHRcdCAgICBlcnJvcldpZHRoUGVySXRlbSxcblx0XHQgICAgcm91bmRlZEN1bXVsYXRpdmVFcnJvcnMsXG5cdFx0ICAgIHNpbmdsZUl0ZW1HZW9tZXRyeSxcblx0XHQgICAgc2VsZiA9IHRoaXM7XG5cblx0XHQvLyBKdXN0aWZ5IHVubGVzcyBleHBsaWNpdGx5IHNwZWNpZmllZCBvdGhlcndpc2UuXG5cdFx0aWYgKHR5cGVvZiBqdXN0aWZ5ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0anVzdGlmeSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gRG9uJ3Qgc2V0IGZyYWN0aW9uYWwgdmFsdWVzIGluIHRoZSBsYXlvdXQuXG5cdFx0cm91bmRlZEhlaWdodCA9IE1hdGgucm91bmQobmV3SGVpZ2h0KTtcblxuXHRcdC8vIENsYW1wIHJvdyBoZWlnaHQgdG8gZWRnZSBjYXNlIG1pbmltdW0vbWF4aW11bS5cblx0XHRjbGFtcGVkSGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5lZGdlQ2FzZU1pblJvd0hlaWdodCwgTWF0aC5taW4ocm91bmRlZEhlaWdodCwgdGhpcy5lZGdlQ2FzZU1heFJvd0hlaWdodCkpO1xuXG5cdFx0aWYgKHJvdW5kZWRIZWlnaHQgIT09IGNsYW1wZWRIZWlnaHQpIHtcblxuXHRcdFx0Ly8gSWYgcm93IGhlaWdodCB3YXMgY2xhbXBlZCwgdGhlIHJlc3VsdGluZyByb3cvaXRlbSBhc3BlY3QgcmF0aW8gd2lsbCBiZSBvZmYsXG5cdFx0XHQvLyBzbyBmb3JjZSBpdCB0byBmaXQgdGhlIHdpZHRoIChyZWNhbGN1bGF0ZSBhc3BlY3RSYXRpbyB0byBtYXRjaCBjbGFtcGVkIGhlaWdodCkuXG5cdFx0XHQvLyBOT1RFOiB0aGlzIHdpbGwgcmVzdWx0IGluIGNyb3BwaW5nL3BhZGRpbmcgY29tbWVuc3VyYXRlIHRvIHRoZSBhbW91bnQgb2YgY2xhbXBpbmcuXG5cdFx0XHR0aGlzLmhlaWdodCA9IGNsYW1wZWRIZWlnaHQ7XG5cdFx0XHRjbGFtcGVkVG9OYXRpdmVSYXRpbyA9IHJvd1dpZHRoV2l0aG91dFNwYWNpbmcgLyBjbGFtcGVkSGVpZ2h0IC8gKHJvd1dpZHRoV2l0aG91dFNwYWNpbmcgLyByb3VuZGVkSGVpZ2h0KTtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBub3QgY2xhbXBlZCwgbGVhdmUgcmF0aW8gYXQgMS4wLlxuXHRcdFx0dGhpcy5oZWlnaHQgPSByb3VuZGVkSGVpZ2h0O1xuXHRcdFx0Y2xhbXBlZFRvTmF0aXZlUmF0aW8gPSAxLjA7XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZSBpdGVtIGdlb21ldHJ5IGJhc2VkIG9uIG5ld0hlaWdodC5cblx0XHR0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcblxuXHRcdFx0aXRlbS50b3AgPSBzZWxmLnRvcDtcblx0XHRcdGl0ZW0ud2lkdGggPSBNYXRoLnJvdW5kKGl0ZW0uYXNwZWN0UmF0aW8gKiBzZWxmLmhlaWdodCAqIGNsYW1wZWRUb05hdGl2ZVJhdGlvKTtcblx0XHRcdGl0ZW0uaGVpZ2h0ID0gc2VsZi5oZWlnaHQ7XG5cblx0XHRcdC8vIExlZnQtdG8tcmlnaHQuXG5cdFx0XHQvLyBUT0RPIHJpZ2h0IHRvIGxlZnRcblx0XHRcdC8vIGl0ZW0ubGVmdCA9IHNlbGYud2lkdGggLSBpdGVtV2lkdGhTdW0gLSBpdGVtLndpZHRoO1xuXHRcdFx0aXRlbS5sZWZ0ID0gaXRlbVdpZHRoU3VtO1xuXG5cdFx0XHQvLyBJbmNyZW1lbW50IHdpZHRoLlxuXHRcdFx0aXRlbVdpZHRoU3VtICs9IGl0ZW0ud2lkdGggKyBzZWxmLnNwYWNpbmc7XG5cdFx0fSk7XG5cblx0XHQvLyBJZiBzcGVjaWZpZWQsIGVuc3VyZSBpdGVtcyBmaWxsIHJvdyBhbmQgZGlzdHJpYnV0ZSBlcnJvclxuXHRcdC8vIGNhdXNlZCBieSByb3VuZGluZyB3aWR0aCBhbmQgaGVpZ2h0IGFjcm9zcyBhbGwgaXRlbXMuXG5cdFx0aWYgKGp1c3RpZnkpIHtcblxuXHRcdFx0Ly8gVE9ETyBSaWdodCB0byBsZWZ0XG5cdFx0XHQvLyBMZWZ0LXRvLXJpZ2h0IGluY3JlbWVudHMgaXRlbVdpZHRoU3VtIGRpZmZlcmVudGx5O1xuXHRcdFx0Ly8gYWNjb3VudCBmb3IgdGhhdCBiZWZvcmUgZGlzdHJpYnV0aW5nIGVycm9yLlxuXHRcdFx0Ly8gaWYgKCF0aGlzLnJpZ2h0VG9MZWZ0KSB7XG5cdFx0XHRpdGVtV2lkdGhTdW0gLT0gdGhpcy5zcGFjaW5nICsgdGhpcy5sZWZ0O1xuXG5cdFx0XHRlcnJvcldpZHRoUGVySXRlbSA9IChpdGVtV2lkdGhTdW0gLSB0aGlzLndpZHRoKSAvIHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0cm91bmRlZEN1bXVsYXRpdmVFcnJvcnMgPSB0aGlzLml0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSwgaSkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCgoaSArIDEpICogZXJyb3JXaWR0aFBlckl0ZW0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMSkge1xuXG5cdFx0XHRcdC8vIEZvciByb3dzIHdpdGggb25seSBvbmUgaXRlbSwgYWRqdXN0IGl0ZW0gd2lkdGggdG8gZmlsbCByb3cuXG5cdFx0XHRcdHNpbmdsZUl0ZW1HZW9tZXRyeSA9IHRoaXMuaXRlbXNbMF07XG5cdFx0XHRcdHNpbmdsZUl0ZW1HZW9tZXRyeS53aWR0aCAtPSBNYXRoLnJvdW5kKGVycm9yV2lkdGhQZXJJdGVtKTtcblxuXHRcdFx0XHQvLyBJbiByaWdodC10by1sZWZ0IGxheW91dHMsIHNoaWZ0IGl0ZW0gdG8gYWNjb3VudCBmb3Igd2lkdGggY2hhbmdlLlxuXHRcdFx0XHQvLyBUT0RPIFJpZ2h0IHRvIGxlZnRcblx0XHRcdFx0Ly8gaWYgKHRoaXMucmlnaHRUb0xlZnQpIHtcblx0XHRcdFx0Ly8gXHRzaW5nbGVJdGVtR2VvbWV0cnkubGVmdCArPSBNYXRoLnJvdW5kKGVycm9yV2lkdGhQZXJJdGVtKTtcblx0XHRcdFx0Ly8gfVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIEZvciByb3dzIHdpdGggbXVsdGlwbGUgaXRlbXMsIGFkanVzdCBpdGVtIHdpZHRoIGFuZCBzaGlmdCBpdGVtcyB0byBmaWxsIHRoZSByb3csXG5cdFx0XHRcdFx0Ly8gd2hpbGUgbWFpbnRhaW5pbmcgZXF1YWwgc3BhY2luZyBiZXR3ZWVuIGl0ZW1zIGluIHRoZSByb3cuXG5cdFx0XHRcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG5cdFx0XHRcdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0XHRcdFx0aXRlbS5sZWZ0IC09IHJvdW5kZWRDdW11bGF0aXZlRXJyb3JzW2kgLSAxXTtcblx0XHRcdFx0XHRcdFx0aXRlbS53aWR0aCAtPSByb3VuZGVkQ3VtdWxhdGl2ZUVycm9yc1tpXSAtIHJvdW5kZWRDdW11bGF0aXZlRXJyb3JzW2kgLSAxXTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGl0ZW0ud2lkdGggLT0gcm91bmRlZEN1bXVsYXRpdmVFcnJvcnNbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG4gKiBGb3JjZSBjb21wbGV0aW9uIG9mIHJvdyBsYXlvdXQgd2l0aCBjdXJyZW50IGl0ZW1zLlxuICpcbiAqIEBtZXRob2QgZm9yY2VDb21wbGV0ZVxuICogQHBhcmFtIGZpdFRvV2lkdGgge0Jvb2xlYW59IFN0cmV0Y2ggY3VycmVudCBpdGVtcyB0byBmaWxsIHRoZSByb3cgd2lkdGguXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyB3aWxsIGxpa2VseSByZXN1bHQgaW4gcGFkZGluZy5cbiAqIEBwYXJhbSBmaXRUb1dpZHRoIHtOdW1iZXJ9XG4gKi9cblx0Zm9yY2VDb21wbGV0ZTogZnVuY3Rpb24gZm9yY2VDb21wbGV0ZShmaXRUb1dpZHRoLCByb3dIZWlnaHQpIHtcblxuXHRcdHZhciByb3dXaWR0aFdpdGhvdXRTcGFjaW5nID0gdGhpcy53aWR0aCAtICh0aGlzLml0ZW1zLmxlbmd0aCAtIDEpICogdGhpcy5zcGFjaW5nLFxuXHRcdCAgICBjdXJyZW50QXNwZWN0UmF0aW8gPSB0aGlzLml0ZW1zLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBpdGVtKSB7XG5cdFx0XHRyZXR1cm4gc3VtICsgaXRlbS5hc3BlY3RSYXRpbztcblx0XHR9LCAwKTtcblxuXHRcdC8vIFRPRE8gSGFuZGxlIGZpdHRpbmcgdG8gd2lkdGhcblxuXHRcdGlmICh0eXBlb2Ygcm93SGVpZ2h0ID09PSAnbnVtYmVyJykge1xuXG5cdFx0XHR0aGlzLmNvbXBsZXRlTGF5b3V0KHJvd0hlaWdodCwgZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbXBsZXRlIHVzaW5nIHRhcmdldCByb3cgaGVpZ2h0LlxuXHRcdFx0dGhpcy5jb21wbGV0ZUxheW91dCh0aGlzLnRhcmdldFJvd0hlaWdodCwgZmFsc2UpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcbiAqIFJldHVybiBsYXlvdXQgZGF0YSBmb3IgaXRlbXMgd2l0aGluIHJvdy5cbiAqIE5vdGU6IHJldHVybnMgYWN0dWFsIGxpc3QsIG5vdCBhIGNvcHkuXG4gKlxuICogQG1ldGhvZCBnZXRJdGVtc1xuICogQHJldHVybiBMYXlvdXQgZGF0YSBmb3IgaXRlbXMgd2l0aGluIHJvdy5cbiAqL1xuXHRnZXRJdGVtczogZnVuY3Rpb24gZ2V0SXRlbXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlbXM7XG5cdH1cblxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanVzdGlmaWVkLWxheW91dC9saWIvcm93LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

eval("var riot = __webpack_require__(0);\n\n\nriot.tag2('box', '<a href=\"{opts.zoom_enabled ? \\'#\\'+id : \\'\\'}\" onclick=\"{click}\" class=\"{opts.zoom_enabled ? \\'zoom-cursor\\' : \\'\\'}\"> <img-comp runup=\"{img_comp.runup}\" back=\"{opts.path}/{img_comp.back}\" fore=\"{opts.path}/{img_comp.fore}\"></img-comp></a>', '', '', function(opts) {\nvar _this = this;\n\nvar throttle = __webpack_require__(2);\nvar event = opts.dispatcher;\n\nthis.click = function (ev) {\n  event.trigger(event.IMAGE_CLICK, _this.id);\n};\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvYm94L2JveC50YWcucHVnIl0sInNvdXJjZXNDb250ZW50IjpbInZhciByaW90ID0gcmVxdWlyZShcInJpb3RcIik7XG5cblxucmlvdC50YWcyKCdib3gnLCAnPGEgaHJlZj1cIntvcHRzLnpvb21fZW5hYmxlZCA/IFxcJyNcXCcraWQgOiBcXCdcXCd9XCIgb25jbGljaz1cIntjbGlja31cIiBjbGFzcz1cIntvcHRzLnpvb21fZW5hYmxlZCA/IFxcJ3pvb20tY3Vyc29yXFwnIDogXFwnXFwnfVwiPiA8aW1nLWNvbXAgcnVudXA9XCJ7aW1nX2NvbXAucnVudXB9XCIgYmFjaz1cIntvcHRzLnBhdGh9L3tpbWdfY29tcC5iYWNrfVwiIGZvcmU9XCJ7b3B0cy5wYXRofS97aW1nX2NvbXAuZm9yZX1cIj48L2ltZy1jb21wPjwvYT4nLCAnJywgJycsIGZ1bmN0aW9uKG9wdHMpIHtcbnZhciBfdGhpcyA9IHRoaXM7XG5cbnZhciB0aHJvdHRsZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi90aHJvdHRsZScpO1xudmFyIGV2ZW50ID0gb3B0cy5kaXNwYXRjaGVyO1xuXG50aGlzLmNsaWNrID0gZnVuY3Rpb24gKGV2KSB7XG4gIGV2ZW50LnRyaWdnZXIoZXZlbnQuSU1BR0VfQ0xJQ0ssIF90aGlzLmlkKTtcbn07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tb2R1bGVzL2JveC9ib3gudGFnLnB1Z1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

eval("var riot = __webpack_require__(0);\n\n\nriot.tag2('container', '<div data-is=\"box\" each=\"{opts.entries}\" id=\"{id}\" riot-style=\"width: {width}px; height: {height}px; top: {top}px; left: {left}px\" path=\"{parent.opts.path}\" dispatcher=\"{parent.opts.dispatcher}\" zoom_enabled=\"{parent.opts.zoom_enabled}\" class=\" {toFront ? \\'tofront\\' : \\'\\'} {zoomIn ? \\'zoomin\\' : \\'\\'}\"></div>', '', '', function(opts) {\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvY29udGFpbmVyL2NvbnRhaW5lci50YWcucHVnIl0sInNvdXJjZXNDb250ZW50IjpbInZhciByaW90ID0gcmVxdWlyZShcInJpb3RcIik7XG5cblxucmlvdC50YWcyKCdjb250YWluZXInLCAnPGRpdiBkYXRhLWlzPVwiYm94XCIgZWFjaD1cIntvcHRzLmVudHJpZXN9XCIgaWQ9XCJ7aWR9XCIgcmlvdC1zdHlsZT1cIndpZHRoOiB7d2lkdGh9cHg7IGhlaWdodDoge2hlaWdodH1weDsgdG9wOiB7dG9wfXB4OyBsZWZ0OiB7bGVmdH1weFwiIHBhdGg9XCJ7cGFyZW50Lm9wdHMucGF0aH1cIiBkaXNwYXRjaGVyPVwie3BhcmVudC5vcHRzLmRpc3BhdGNoZXJ9XCIgem9vbV9lbmFibGVkPVwie3BhcmVudC5vcHRzLnpvb21fZW5hYmxlZH1cIiBjbGFzcz1cIiB7dG9Gcm9udCA/IFxcJ3RvZnJvbnRcXCcgOiBcXCdcXCd9IHt6b29tSW4gPyBcXCd6b29taW5cXCcgOiBcXCdcXCd9XCI+PC9kaXY+JywgJycsICcnLCBmdW5jdGlvbihvcHRzKSB7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tb2R1bGVzL2NvbnRhaW5lci9jb250YWluZXIudGFnLnB1Z1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

eval("var riot = __webpack_require__(0);\n\n\nriot.tag2('galleries-menu', '<ul> <li each=\"{opts.galleries}\"><a href=\"#{parent.opts.route}/{dir}\">{name}</a></li> </ul>', '', '', function(opts) {\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvZ2FsbGVyaWVzLW1lbnUvZ2FsbGVyaWVzLW1lbnUudGFnLnB1ZyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmlvdCA9IHJlcXVpcmUoXCJyaW90XCIpO1xuXG5cbnJpb3QudGFnMignZ2FsbGVyaWVzLW1lbnUnLCAnPHVsPiA8bGkgZWFjaD1cIntvcHRzLmdhbGxlcmllc31cIj48YSBocmVmPVwiI3twYXJlbnQub3B0cy5yb3V0ZX0ve2Rpcn1cIj57bmFtZX08L2E+PC9saT4gPC91bD4nLCAnJywgJycsIGZ1bmN0aW9uKG9wdHMpIHtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL21vZHVsZXMvZ2FsbGVyaWVzLW1lbnUvZ2FsbGVyaWVzLW1lbnUudGFnLnB1Z1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

eval("var riot = __webpack_require__(0);\n\n\nriot.tag2('img-comp', '<div class=\"image\"><img id=\"runup\" if=\"{!loaded}\" riot-src=\"{opts.runup}\" class=\"full blur\"> <div id=\"texture\" if=\"{!loaded}\" class=\"full tl\"></div><img id=\"back\" riot-src=\"{opts.back}\" class=\"fadein pos max border\"><img id=\"fore\" if=\"{opts.fore}\" riot-src=\"{opts.fore}\" class=\"fadein pos max\"> </div>', '', '', function(opts) {\nvar _this = this;\n\nthis.loaded = false;\nthis.back.addEventListener('animationend', function () {\n  _this.texture.classList.add('hide');\n  _this.runup.classList.add('hide');\n  _this.loaded = true;\n}, false);\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvaW1nLWNvbXAvaW1nLWNvbXAudGFnLnB1ZyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmlvdCA9IHJlcXVpcmUoXCJyaW90XCIpO1xuXG5cbnJpb3QudGFnMignaW1nLWNvbXAnLCAnPGRpdiBjbGFzcz1cImltYWdlXCI+PGltZyBpZD1cInJ1bnVwXCIgaWY9XCJ7IWxvYWRlZH1cIiByaW90LXNyYz1cIntvcHRzLnJ1bnVwfVwiIGNsYXNzPVwiZnVsbCBibHVyXCI+IDxkaXYgaWQ9XCJ0ZXh0dXJlXCIgaWY9XCJ7IWxvYWRlZH1cIiBjbGFzcz1cImZ1bGwgdGxcIj48L2Rpdj48aW1nIGlkPVwiYmFja1wiIHJpb3Qtc3JjPVwie29wdHMuYmFja31cIiBjbGFzcz1cImZhZGVpbiBwb3MgbWF4IGJvcmRlclwiPjxpbWcgaWQ9XCJmb3JlXCIgaWY9XCJ7b3B0cy5mb3JlfVwiIHJpb3Qtc3JjPVwie29wdHMuZm9yZX1cIiBjbGFzcz1cImZhZGVpbiBwb3MgbWF4XCI+IDwvZGl2PicsICcnLCAnJywgZnVuY3Rpb24ob3B0cykge1xudmFyIF90aGlzID0gdGhpcztcblxudGhpcy5sb2FkZWQgPSBmYWxzZTtcbnRoaXMuYmFjay5hZGRFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBmdW5jdGlvbiAoKSB7XG4gIF90aGlzLnRleHR1cmUuY2xhc3NMaXN0LmFkZCgnaGlkZScpO1xuICBfdGhpcy5ydW51cC5jbGFzc0xpc3QuYWRkKCdoaWRlJyk7XG4gIF90aGlzLmxvYWRlZCA9IHRydWU7XG59LCBmYWxzZSk7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tb2R1bGVzL2ltZy1jb21wL2ltZy1jb21wLnRhZy5wdWdcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

eval("var riot = __webpack_require__(0);\n\n\nriot.tag2('justified-gallery', '<galleries-menu galleries=\"{store.config.galleries}\" route=\"{store.config.route}\"></galleries-menu> <div data-is=\"container\" riot-style=\"height: {store.height}px; width: {store.width}px;\" entries=\"{store.entries}\" path=\"{store.path}\" dispatcher=\"{store.dispatcher}\" zoom_enabled=\"{store.isZoomEnabled}\"></div> <div id=\"desciption\" riot-style=\"width: {store.width}px\"> <h3 class=\"header\">{store.name}</h3> <div data-is=\"raw\" html=\"{store.desc[store.config.lang]}\" class=\"body\"></div> </div> <modal is_modal=\"{store.showModal}\" zoom_id=\"{store.zoomId}\" dispatcher=\"{store.dispatcher}\"></modal>', '', '', function(opts) {\nvar _this = this;\n\nvar throttle = __webpack_require__(2);\nvar PREV = __webpack_require__(1).PREV;\nvar NEXT = __webpack_require__(1).NEXT;\nvar store = this.store = opts.store;\nvar event = store.dispatcher;\nvar keyHanlers = {\n  37: function _(e) {\n    return e.trigger(e.SWITCH_IMAGE, PREV);\n  },\n  39: function _(e) {\n    return e.trigger(e.SWITCH_IMAGE, NEXT);\n  },\n  27: function _(e) {\n    return e.trigger(e.IMG_ZOOM_OUT);\n  }\n};\nvar keyHandler = function keyHandler(code, event) {\n  return keyHanlers[code] && keyHanlers[code](event);\n};\n\nevent.trigger(event.GALLERY_INIT);\n\nstore.on(store.CHANGED_EVENT, function () {\n  return _this.update();\n});\n\nwindow.addEventListener('resize', throttle(function (ev) {\n  return event.trigger(event.WINDOW_RESIZE, ev);\n}, 200));\n\nwindow.addEventListener('keydown', function (ev) {\n  return keyHandler(ev.keyCode, event);\n}, false);\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvanVzdGlmaWVkLWdhbGxlcnkvanVzdGlmaWVkLWdhbGxlcnkudGFnLnB1ZyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmlvdCA9IHJlcXVpcmUoXCJyaW90XCIpO1xuXG5cbnJpb3QudGFnMignanVzdGlmaWVkLWdhbGxlcnknLCAnPGdhbGxlcmllcy1tZW51IGdhbGxlcmllcz1cIntzdG9yZS5jb25maWcuZ2FsbGVyaWVzfVwiIHJvdXRlPVwie3N0b3JlLmNvbmZpZy5yb3V0ZX1cIj48L2dhbGxlcmllcy1tZW51PiA8ZGl2IGRhdGEtaXM9XCJjb250YWluZXJcIiByaW90LXN0eWxlPVwiaGVpZ2h0OiB7c3RvcmUuaGVpZ2h0fXB4OyB3aWR0aDoge3N0b3JlLndpZHRofXB4O1wiIGVudHJpZXM9XCJ7c3RvcmUuZW50cmllc31cIiBwYXRoPVwie3N0b3JlLnBhdGh9XCIgZGlzcGF0Y2hlcj1cIntzdG9yZS5kaXNwYXRjaGVyfVwiIHpvb21fZW5hYmxlZD1cIntzdG9yZS5pc1pvb21FbmFibGVkfVwiPjwvZGl2PiA8ZGl2IGlkPVwiZGVzY2lwdGlvblwiIHJpb3Qtc3R5bGU9XCJ3aWR0aDoge3N0b3JlLndpZHRofXB4XCI+IDxoMyBjbGFzcz1cImhlYWRlclwiPntzdG9yZS5uYW1lfTwvaDM+IDxkaXYgZGF0YS1pcz1cInJhd1wiIGh0bWw9XCJ7c3RvcmUuZGVzY1tzdG9yZS5jb25maWcubGFuZ119XCIgY2xhc3M9XCJib2R5XCI+PC9kaXY+IDwvZGl2PiA8bW9kYWwgaXNfbW9kYWw9XCJ7c3RvcmUuc2hvd01vZGFsfVwiIHpvb21faWQ9XCJ7c3RvcmUuem9vbUlkfVwiIGRpc3BhdGNoZXI9XCJ7c3RvcmUuZGlzcGF0Y2hlcn1cIj48L21vZGFsPicsICcnLCAnJywgZnVuY3Rpb24ob3B0cykge1xudmFyIF90aGlzID0gdGhpcztcblxudmFyIHRocm90dGxlID0gcmVxdWlyZSgnLi4vLi4vbGliL3Rocm90dGxlJyk7XG52YXIgUFJFViA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0YW50cycpLlBSRVY7XG52YXIgTkVYVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0YW50cycpLk5FWFQ7XG52YXIgc3RvcmUgPSB0aGlzLnN0b3JlID0gb3B0cy5zdG9yZTtcbnZhciBldmVudCA9IHN0b3JlLmRpc3BhdGNoZXI7XG52YXIga2V5SGFubGVycyA9IHtcbiAgMzc6IGZ1bmN0aW9uIF8oZSkge1xuICAgIHJldHVybiBlLnRyaWdnZXIoZS5TV0lUQ0hfSU1BR0UsIFBSRVYpO1xuICB9LFxuICAzOTogZnVuY3Rpb24gXyhlKSB7XG4gICAgcmV0dXJuIGUudHJpZ2dlcihlLlNXSVRDSF9JTUFHRSwgTkVYVCk7XG4gIH0sXG4gIDI3OiBmdW5jdGlvbiBfKGUpIHtcbiAgICByZXR1cm4gZS50cmlnZ2VyKGUuSU1HX1pPT01fT1VUKTtcbiAgfVxufTtcbnZhciBrZXlIYW5kbGVyID0gZnVuY3Rpb24ga2V5SGFuZGxlcihjb2RlLCBldmVudCkge1xuICByZXR1cm4ga2V5SGFubGVyc1tjb2RlXSAmJiBrZXlIYW5sZXJzW2NvZGVdKGV2ZW50KTtcbn07XG5cbmV2ZW50LnRyaWdnZXIoZXZlbnQuR0FMTEVSWV9JTklUKTtcblxuc3RvcmUub24oc3RvcmUuQ0hBTkdFRF9FVkVOVCwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX3RoaXMudXBkYXRlKCk7XG59KTtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRocm90dGxlKGZ1bmN0aW9uIChldikge1xuICByZXR1cm4gZXZlbnQudHJpZ2dlcihldmVudC5XSU5ET1dfUkVTSVpFLCBldik7XG59LCAyMDApKTtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcbiAgcmV0dXJuIGtleUhhbmRsZXIoZXYua2V5Q29kZSwgZXZlbnQpO1xufSwgZmFsc2UpO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbW9kdWxlcy9qdXN0aWZpZWQtZ2FsbGVyeS9qdXN0aWZpZWQtZ2FsbGVyeS50YWcucHVnXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

eval("var riot = __webpack_require__(0);\n\n\nriot.tag2('modal', '<div id=\"panel\" onclick=\"{zoomOut}\" class=\"modal {opts.is_modal ? \\'show\\' : \\'\\'}\"></div>', '', '', function(opts) {\nvar event = opts.dispatcher;\nvar throttle = __webpack_require__(2);\n\nthis.root.addEventListener('transitionend', throttle(function (ev) {\n  return !opts.is_modal && event.trigger(event.TRANSITION_END);\n}, 20), false);\n\nthis.zoomOut = function () {\n  return event.trigger(event.IMG_ZOOM_OUT);\n};\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvbW9kYWwvbW9kYWwudGFnLnB1ZyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmlvdCA9IHJlcXVpcmUoXCJyaW90XCIpO1xuXG5cbnJpb3QudGFnMignbW9kYWwnLCAnPGRpdiBpZD1cInBhbmVsXCIgb25jbGljaz1cInt6b29tT3V0fVwiIGNsYXNzPVwibW9kYWwge29wdHMuaXNfbW9kYWwgPyBcXCdzaG93XFwnIDogXFwnXFwnfVwiPjwvZGl2PicsICcnLCAnJywgZnVuY3Rpb24ob3B0cykge1xudmFyIGV2ZW50ID0gb3B0cy5kaXNwYXRjaGVyO1xudmFyIHRocm90dGxlID0gcmVxdWlyZSgnLi4vLi4vbGliL3Rocm90dGxlJyk7XG5cbnRoaXMucm9vdC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhyb3R0bGUoZnVuY3Rpb24gKGV2KSB7XG4gIHJldHVybiAhb3B0cy5pc19tb2RhbCAmJiBldmVudC50cmlnZ2VyKGV2ZW50LlRSQU5TSVRJT05fRU5EKTtcbn0sIDIwKSwgZmFsc2UpO1xuXG50aGlzLnpvb21PdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBldmVudC50cmlnZ2VyKGV2ZW50LklNR19aT09NX09VVCk7XG59O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbW9kdWxlcy9tb2RhbC9tb2RhbC50YWcucHVnXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

eval("var riot = __webpack_require__(0);\n\n\nriot.tag2('raw', '<div id=\"just\" call=\"{this.setInnerHtml(this.opts.html)}\"></div>', '', '', function(opts) {\nvar _this = this;\n\nthis.setInnerHtml = function () {\n  var html = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  return _this.root.innerHTML = html;\n};\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvc3JjL21vZHVsZXMvcmF3L3Jhdy50YWcucHVnIl0sInNvdXJjZXNDb250ZW50IjpbInZhciByaW90ID0gcmVxdWlyZShcInJpb3RcIik7XG5cblxucmlvdC50YWcyKCdyYXcnLCAnPGRpdiBpZD1cImp1c3RcIiBjYWxsPVwie3RoaXMuc2V0SW5uZXJIdG1sKHRoaXMub3B0cy5odG1sKX1cIj48L2Rpdj4nLCAnJywgJycsIGZ1bmN0aW9uKG9wdHMpIHtcbnZhciBfdGhpcyA9IHRoaXM7XG5cbnRoaXMuc2V0SW5uZXJIdG1sID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaHRtbCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/ICcnIDogYXJndW1lbnRzWzBdO1xuICByZXR1cm4gX3RoaXMucm9vdC5pbm5lckhUTUwgPSBodG1sO1xufTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL21vZHVsZXMvcmF3L3Jhdy50YWcucHVnXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 37 */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9hbWQtb3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 38 */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvam9yZ2UvZGV2L2dhbGwvbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(4);


/***/ })
/******/ ]);